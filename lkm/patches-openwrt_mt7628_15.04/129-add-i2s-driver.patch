Index: linux-3.10.108/sound/soc/codecs/Kconfig
===================================================================
--- linux-3.10.108.orig/sound/soc/codecs/Kconfig
+++ linux-3.10.108/sound/soc/codecs/Kconfig
@@ -529,3 +529,6 @@ config SND_SOC_ML26124
 
 config SND_SOC_TPA6130A2
 	tristate
+
+config SND_SOC_ES8311
+	tristate "Everest Semi ES8311 CODEC"
\ No newline at end of file
Index: linux-3.10.108/sound/soc/codecs/Makefile
===================================================================
--- linux-3.10.108.orig/sound/soc/codecs/Makefile
+++ linux-3.10.108/sound/soc/codecs/Makefile
@@ -123,6 +123,8 @@ snd-soc-wm-hubs-objs := wm_hubs.o
 snd-soc-max9877-objs := max9877.o
 snd-soc-tpa6130a2-objs := tpa6130a2.o
 
+snd-soc-es8311-objs := es8311.o
+
 obj-$(CONFIG_SND_SOC_88PM860X)	+= snd-soc-88pm860x.o
 obj-$(CONFIG_SND_SOC_AB8500_CODEC)	+= snd-soc-ab8500-codec.o
 obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
@@ -246,3 +248,4 @@ obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
 obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
+obj-$(CONFIG_SND_SOC_ES8311)	+= snd-soc-es8311.o
\ No newline at end of file
Index: linux-3.10.108/sound/soc/codecs/es8311.c
===================================================================
--- /dev/null
+++ linux-3.10.108/sound/soc/codecs/es8311.c
@@ -0,0 +1,1329 @@
+/*
+ * es8311.c  --  ES8311/ES8312 ALSA SoC Audio Codec
+ *
+ * Version 1.0 2021.1.12
+ *
+ * Copyright (C) 2018 Everest Semiconductor Co., Ltd
+ *
+ * Authors:  David Yang(yangxiaohua@everest-semi.com)
+ *
+ *
+ * Based on es8374.c by David Yang(yangxiaohua@everest-semi.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/regmap.h>
+#include <linux/stddef.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/tlv.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include "es8311.h"
+
+#ifndef CONFIG_OF
+#define CONFIG_OF
+#endif
+
+/*
+ * es8311 register cache
+ */
+static struct reg_default  es8311_reg_defaults[] = {
+    { 0x00, 0x1f },
+    { 0x01, 0x00 },
+    { 0x02, 0x00 },
+    { 0x03, 0x10 },
+    { 0x04, 0x10 },
+    { 0x05, 0x00 },
+    { 0x06, 0x03 },
+    { 0x07, 0x00 },
+    { 0x08, 0xff },
+    { 0x09, 0x00 },
+    { 0x0a, 0x00 },
+    { 0x0b, 0x00 },
+    { 0x0c, 0x20 },
+    { 0x0d, 0xfc },
+    { 0x0e, 0x6a },
+    { 0x0f, 0x00 },
+
+    { 0x10, 0x13 },
+    { 0x11, 0x7c },
+    { 0x12, 0x02 },
+    { 0x13, 0x40 },
+    { 0x14, 0x10 },
+    { 0x15, 0x00 },
+    { 0x16, 0x04 },
+    { 0x17, 0x00 },
+    { 0x18, 0x00 },
+    { 0x19, 0x00 },
+    { 0x1a, 0x00 },
+    { 0x1b, 0x0c },
+    { 0x1c, 0x4c },
+    { 0x1d, 0x00 },
+    { 0x1e, 0x00 },
+    { 0x1f, 0x00 },
+
+    { 0x20, 0x00 },
+    { 0x21, 0x00 },
+    { 0x22, 0x00 },
+    { 0x23, 0x00 },
+    { 0x24, 0x00 },
+    { 0x25, 0x00 },
+    { 0x26, 0x00 },
+    { 0x27, 0x00 },
+    { 0x28, 0x00 },
+    { 0x29, 0x00 },
+    { 0x2a, 0x00 },
+    { 0x2b, 0x00 },
+    { 0x2c, 0x00 },
+    { 0x2d, 0x00 },
+    { 0x2e, 0x00 },
+    { 0x2f, 0x00 },
+
+    { 0x30, 0x00 },
+    { 0x31, 0x00 },
+    { 0x32, 0x00 },
+    { 0x33, 0x00 },
+    { 0x34, 0x00 },
+    { 0x35, 0x00 },
+    { 0x36, 0x00 },
+    { 0x37, 0x08 },
+    { 0x38, 0x00 },
+    { 0x39, 0x00 },
+    { 0x3a, 0x00 },
+    { 0x3b, 0x00 },
+    { 0x3c, 0x00 },
+    { 0x3d, 0x00 },
+    { 0x3e, 0x00 },
+    { 0x3f, 0x00 },
+
+    { 0x40, 0x00 },
+    { 0x41, 0x00 },
+    { 0x42, 0x00 },
+    { 0x43, 0x00 },
+    { 0x44, 0x00 },
+    { 0x45, 0x00 },
+};
+
+struct sp_config {
+    u8 spc, mmcc, spfs;
+    u32 srate;
+    u8 lrcdiv;
+    u8 sclkdiv;
+};
+
+/* codec private data */
+struct  es8311_private {
+    struct snd_soc_codec *codec;
+    struct regmap *regmap;
+    u32 mclk;
+    bool sclkinv;
+    bool mclkinv;
+    bool dmic_enable;
+};
+
+struct es8311_private *es8311_data;
+struct snd_soc_codec *es8311_codec;
+
+static bool es8311_volatile_register(struct device *dev,
+            unsigned int reg)
+{
+    if ((reg  <= 0xff)) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+static bool es8311_readable_register(struct device *dev,
+            unsigned int reg)
+{
+    if ((reg  <= 0xff)) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+static bool es8311_writable_register(struct device *dev,
+            unsigned int reg)
+{
+    if ((reg  <= 0xff)) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+static const DECLARE_TLV_DB_SCALE(vdac_tlv,
+                -9550, 50, 1);
+static const DECLARE_TLV_DB_SCALE(vadc_tlv,
+                -9550, 50, 1);
+static const DECLARE_TLV_DB_SCALE(mic_pga_tlv,
+                0, 300, 1);
+static const DECLARE_TLV_DB_SCALE(adc_scale_tlv,
+                0, 600, 0);
+static const DECLARE_TLV_DB_SCALE(alc_winsize_tlv,
+                0, 25, 0);
+static const DECLARE_TLV_DB_SCALE(alc_maxlevel_tlv,
+                -3600, 200, 0);
+static const DECLARE_TLV_DB_SCALE(alc_minlevel_tlv,
+                -3600, 200, 0);
+static const DECLARE_TLV_DB_SCALE(alc_noisegate_tlv,
+                -9600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(alc_noisegate_winsize_tlv,
+                2048, 2048, 0);
+static const DECLARE_TLV_DB_SCALE(alc_automute_gain_tlv,
+                0, -400, 0);
+static const DECLARE_TLV_DB_SCALE(adc_ramprate_tlv,
+                0, 25, 0);
+
+static const char * const dmic_type_txt[] = {
+    "dmic at high level",
+    "dmic at low level"
+};
+
+static const struct soc_enum dmic_type = SOC_ENUM_SINGLE(ES8311_ADC_REG15, 0, 1, dmic_type_txt);
+
+static const char * const automute_type_txt[] = {
+    "automute disabled",
+    "automute enable"
+};
+static const struct soc_enum alc_automute_type =
+SOC_ENUM_SINGLE(ES8311_ADC_REG18, 6, 1, automute_type_txt);
+
+static const char * const dacdsm_mute_type_txt[] = {
+    "mute to 8",
+    "mute to 7/9"
+};
+static const struct soc_enum dacdsm_mute_type =
+SOC_ENUM_SINGLE(ES8311_DAC_REG31, 7, 1, dacdsm_mute_type_txt);
+
+static const char * const aec_type_txt[] = {
+    "adc left, adc right",
+    "adc left, null right",
+    "null left, adc right",
+    "null left, null right",
+    "dac left, adc right",
+    "adc left, dac right",
+    "dac left, dac right",
+    "N/A"
+};
+static const struct soc_enum aec_type =
+SOC_ENUM_SINGLE(ES8311_GPIO_REG44, 4, 7, aec_type_txt);
+
+static const char * const adc2dac_sel_txt[] = {
+    "disable",
+    "adc data to dac",
+};
+static const struct soc_enum adc2dac_sel =
+SOC_ENUM_SINGLE(ES8311_GPIO_REG44, 7, 1, adc2dac_sel_txt);
+
+static const char * const mclk_sel_txt[] = {
+    "from mclk pin",
+    "from bclk",
+};
+static const struct soc_enum mclk_src =
+SOC_ENUM_SINGLE(ES8311_CLK_MANAGER_REG01, 7, 1, mclk_sel_txt);
+
+/*
+ * es8311 Controls
+ */
+static const struct snd_kcontrol_new es8311_snd_controls[] = {
+    SOC_SINGLE_TLV("MIC PGA GAIN", ES8311_SYSTEM_REG14,
+            0, 10, 0, mic_pga_tlv),
+    SOC_SINGLE_TLV("ADC SCALE", ES8311_ADC_REG16,
+            0, 7, 0, adc_scale_tlv),
+    SOC_ENUM("DMIC TYPE", dmic_type),
+    SOC_SINGLE_TLV("ADC RAMP RATE", ES8311_ADC_REG15,
+            4, 15, 0, adc_ramprate_tlv),
+    SOC_SINGLE("ADC SDP MUTE", ES8311_SDPOUT_REG0A, 6, 1, 1),
+    SOC_SINGLE("ADC INVERTED", ES8311_ADC_REG16, 4, 1, 0),
+    SOC_SINGLE("ADC SYNC", ES8311_ADC_REG16, 5, 1, 1),
+    SOC_SINGLE("ADC RAM CLR", ES8311_ADC_REG16, 3, 1, 0),
+    SOC_SINGLE_TLV("ADC VOLUME", ES8311_ADC_REG17,
+            0, 255, 0, vadc_tlv),
+    SOC_SINGLE("ALC ENABLE", ES8311_ADC_REG18, 7, 1, 0),
+    SOC_ENUM("ALC AUTOMUTE TYPE", alc_automute_type),
+    SOC_SINGLE_TLV("ALC WIN SIZE", ES8311_ADC_REG18,
+            0, 15, 0, alc_winsize_tlv),
+    SOC_SINGLE_TLV("ALC MAX LEVEL", ES8311_ADC_REG19,
+            4, 15, 0, alc_maxlevel_tlv),
+    SOC_SINGLE_TLV("ALC MIN LEVEL", ES8311_ADC_REG19,
+            0, 15, 0, alc_minlevel_tlv),
+    SOC_SINGLE_TLV("ALC AUTOMUTE WINSIZE", ES8311_ADC_REG1A,
+            4, 15, 0, alc_noisegate_winsize_tlv),
+    SOC_SINGLE_TLV("ALC AUTOMUTE GATE THRESHOLD", ES8311_ADC_REG1A,
+            0, 15, 0, alc_noisegate_tlv),
+    SOC_SINGLE_TLV("ALC AUTOMUTE VOLUME", ES8311_ADC_REG1B,
+            5, 7, 0, alc_automute_gain_tlv),
+    SOC_SINGLE("ADC FS MODE", ES8311_CLK_MANAGER_REG03, 6, 1, 0),
+    SOC_SINGLE("ADC OSR", ES8311_CLK_MANAGER_REG03, 0, 63, 0),
+    SOC_SINGLE("DAC SDP MUTE", ES8311_SDPIN_REG09, 6, 1, 0),
+    SOC_SINGLE("DAC DEM  MUTE", ES8311_DAC_REG31, 5, 1, 0),
+    SOC_SINGLE("DAC INVERT", ES8311_DAC_REG31, 4, 1, 0),
+    SOC_SINGLE("DAC RAM CLR", ES8311_DAC_REG31, 3, 1, 0),
+    SOC_ENUM("DAC DSM MUTE", dacdsm_mute_type),
+    SOC_SINGLE("DAC OFFSET", ES8311_DAC_REG33, 0, 255, 0),
+    SOC_SINGLE_TLV("DAC VOLUME", ES8311_DAC_REG32,
+            0, 255, 0, vdac_tlv),
+    SOC_SINGLE("DRC ENABLE", ES8311_DAC_REG34, 7, 1, 0),
+    SOC_SINGLE_TLV("DRC WIN SIZE",  ES8311_DAC_REG34,
+            0, 15, 0, alc_winsize_tlv),
+    SOC_SINGLE_TLV("DRC MAX LEVEL", ES8311_DAC_REG35,
+            4, 15, 0, alc_maxlevel_tlv),
+    SOC_SINGLE_TLV("DRC MIN LEVEL", ES8311_DAC_REG35,
+            0, 15, 0, alc_minlevel_tlv),
+    SOC_SINGLE_TLV("DAC RAMP RATE", ES8311_DAC_REG37,
+            4, 15, 0, adc_ramprate_tlv),
+    SOC_SINGLE("DAC OSR", ES8311_CLK_MANAGER_REG04, 0, 127, 0),
+    SOC_ENUM("AEC MODE", aec_type),
+    SOC_ENUM("ADC DATA TO DAC TEST MODE", adc2dac_sel),
+    SOC_SINGLE("MCLK INVERT", ES8311_CLK_MANAGER_REG01, 6, 1, 0),
+    SOC_SINGLE("BCLK INVERT", ES8311_CLK_MANAGER_REG06, 5, 1, 0),
+    SOC_ENUM("MCLK SOURCE", mclk_src),
+};
+
+/*
+ * DAPM Controls
+ */
+static const char * const es8311_dmic_mux_txt[] = {
+    "DMIC DISABLE",
+    "DMIC ENABLE"
+};
+static const unsigned int es8311_dmic_mux_values[] = {
+    0, 1
+};
+static const struct soc_enum es8311_dmic_mux_enum =
+    SOC_VALUE_ENUM_SINGLE(ES8311_SYSTEM_REG14, 6, 1,
+        ARRAY_SIZE(es8311_dmic_mux_txt),
+        es8311_dmic_mux_txt,
+        es8311_dmic_mux_values);
+static const struct snd_kcontrol_new es8311_dmic_mux_controls =
+    SOC_DAPM_ENUM("DMIC ROUTE", es8311_dmic_mux_enum);
+
+static const char * const es8311_adc_sdp_mux_txt[] = {
+
+    "FROM EQUALIZER",
+    "FROM ADC OUT",
+};
+static const unsigned int es8311_adc_sdp_mux_values[] = {
+    0, 1
+};
+static const struct soc_enum es8311_adc_sdp_mux_enum =
+    SOC_VALUE_ENUM_SINGLE(ES8311_ADC_REG1C, 6, 1,
+        ARRAY_SIZE(es8311_adc_sdp_mux_txt),
+        es8311_adc_sdp_mux_txt,
+        es8311_adc_sdp_mux_values);
+static const struct snd_kcontrol_new es8311_adc_sdp_mux_controls =
+    SOC_DAPM_ENUM("ADC SDP ROUTE", es8311_adc_sdp_mux_enum);
+
+/*
+ * DAC data  soure
+ */
+static const char * const es8311_dac_data_mux_txt[] = {
+    "SELECT SDP LEFT DATA",
+    "SELECT SDP RIGHT DATA",
+};
+static const unsigned int  es8311_dac_data_mux_values[] = {
+    0, 1
+};
+static const struct soc_enum  es8311_dac_data_mux_enum =
+    SOC_VALUE_ENUM_SINGLE(ES8311_SDPIN_REG09, 7, 1,
+        ARRAY_SIZE(es8311_dac_data_mux_txt),
+        es8311_dac_data_mux_txt,
+        es8311_dac_data_mux_values);
+static const struct snd_kcontrol_new  es8311_dac_data_mux_controls =
+    SOC_DAPM_ENUM("DAC SDP ROUTE", es8311_dac_data_mux_enum);
+
+static const struct snd_soc_dapm_widget es8311_dapm_widgets[] = {
+    /* Input*/
+    SND_SOC_DAPM_INPUT("DMIC"),
+    SND_SOC_DAPM_INPUT("AMIC"),
+
+    SND_SOC_DAPM_PGA("INPUT PGA", ES8311_SYSTEM_REG0E,
+            6, 0, NULL, 0),
+    /* ADCs */
+    SND_SOC_DAPM_ADC("MONO ADC", NULL, ES8311_SYSTEM_REG0E, 5, 0),
+    /* Dmic MUX */
+    SND_SOC_DAPM_MUX("DMIC MUX", SND_SOC_NOPM, 0, 0,
+            &es8311_dmic_mux_controls),
+    /* sdp MUX */
+    SND_SOC_DAPM_MUX("SDP OUT MUX", SND_SOC_NOPM, 0, 0,
+        &es8311_adc_sdp_mux_controls),
+    /* Digital Interface */
+    SND_SOC_DAPM_AIF_OUT("I2S OUT", "I2S1 Capture",  1,
+            SND_SOC_NOPM, 0, 0),
+    /* Render path  */
+    SND_SOC_DAPM_AIF_IN("I2S IN", "I2S1 Playback", 0,
+            SND_SOC_NOPM, 0, 0),
+    /*DACs SDP DATA SRC MUX */
+    SND_SOC_DAPM_MUX("DAC SDP SRC MUX", SND_SOC_NOPM, 0, 0,
+            &es8311_dac_data_mux_controls),
+    SND_SOC_DAPM_DAC("MONO DAC", NULL, SND_SOC_NOPM, 0, 0),
+
+    /* Output Lines */
+    SND_SOC_DAPM_OUTPUT("DIFFERENTIAL OUT"),
+};
+
+
+static const struct snd_soc_dapm_route es8311_dapm_routes[] = {
+    /* record route map */
+    {"INPUT PGA", NULL, "AMIC"},
+    {"MONO ADC", NULL, "INPUT PGA"},
+    {"DMIC MUX", "DMIC DISABLE", "MONO ADC"},
+    {"DMIC MUX", "DMIC ENABLE", "DMIC"},
+    {"SDP OUT MUX", "FROM ADC OUT", "DMIC MUX"},
+    {"SDP OUT MUX", "FROM EQUALIZER", "DMIC MUX"},
+    {"I2S OUT", NULL, "SDP OUT MUX"},
+    /* playback route map */
+    {"DAC SDP SRC MUX", "SELECT SDP LEFT DATA", "I2S IN"},
+    {"DAC SDP SRC MUX", "SELECT SDP RIGHT DATA", "I2S IN"},
+    {"MONO DAC", NULL, "DAC SDP SRC MUX"},
+    {"DIFFERENTIAL OUT", NULL, "MONO DAC"},
+};
+
+struct _coeff_div {
+    u32 mclk;       /* mclk frequency */
+    u32 rate;       /* sample rate */
+    u8 prediv;      /* the pre divider with range from 1 to 8 */
+    u8 premulti;    /* the pre multiplier with x1, x2, x4 and x8 selection */
+    u8 adcdiv;      /* adcclk divider */
+    u8 dacdiv;      /* dacclk divider */
+    u8 fsmode;      /* double speed or single speed, =0, ss, =1, ds */
+    u8 lrck_h;      /* adclrck divider and daclrck divider */
+    u8 lrck_l;
+    u8 bclkdiv;     /* sclk divider */
+    u8 adcosr;      /* adc osr */
+    u8 dacosr;      /* dac osr */
+};
+
+/* codec hifi mclk clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+    //mclk     rate   prediv  mult  adcdiv dacdiv fsmode lrch  lrcl  bckdiv osr
+    /* 8k */
+    {12288000, 8000 , 0x06, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {18432000, 8000 , 0x03, 0x02, 0x03, 0x03, 0x00, 0x05, 0xff, 0x18, 0x10, 0x10},
+    {16384000, 8000 , 0x08, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {8192000 , 8000 , 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 8000 , 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {4096000 , 8000 , 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {3072000 , 8000 , 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {2048000 , 8000 , 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 8000 , 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1024000 , 8000 , 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+
+    /* 11.025k */
+    {11289600, 11025, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {5644800 , 11025, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {2822400 , 11025, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1411200 , 11025, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+
+    /* 12k */
+    {12288000, 12000, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 12000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {3072000 , 12000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 12000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+
+    /* 16k */
+    {12288000, 16000, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {18432000, 16000, 0x03, 0x02, 0x03, 0x03, 0x00, 0x02, 0xff, 0x0c, 0x10, 0x10},
+    {16384000, 16000, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {8192000 , 16000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 16000, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {4096000 , 16000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {3072000 , 16000, 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {2048000 , 16000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 16000, 0x03, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1024000 , 16000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    
+    /* 22.05k */
+    {11289600, 22050, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {5644800 , 22050, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {2822400 , 22050, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1411200 , 22050, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+
+    /* 24k */
+    {12288000, 24000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {18432000, 24000, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 24000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {3072000 , 24000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 24000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    
+    /* 32k */
+    {12288000, 32000, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {18432000, 32000, 0x03, 0x04, 0x03, 0x03, 0x00, 0x02, 0xff, 0x0c, 0x10, 0x10},
+    {16384000, 32000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {8192000 , 32000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 32000, 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {4096000 , 32000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {3072000 , 32000, 0x03, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {2048000 , 32000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 32000, 0x03, 0x08, 0x01, 0x01, 0x01, 0x00, 0x7f, 0x02, 0x10, 0x10},
+    {1024000 , 32000, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+
+    /* 44.1k */
+    {11289600, 44100, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {5644800 , 44100, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {2822400 , 44100, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1411200 , 44100, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+
+    /* 48k */
+    //{24576000, 48000, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {12288000, 48000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {18432000, 48000, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 48000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+     {3072000 , 48000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 48000, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+
+    /* 64k */
+    {12288000, 64000, 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {18432000, 64000, 0x03, 0x04, 0x03, 0x03, 0x01, 0x01, 0x7f, 0x06, 0x10, 0x10},
+    {16384000, 64000, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {8192000 , 64000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 64000, 0x01, 0x04, 0x03, 0x03, 0x01, 0x01, 0x7f, 0x06, 0x10, 0x10},
+    {4096000 , 64000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {3072000 , 64000, 0x01, 0x08, 0x03, 0x03, 0x01, 0x01, 0x7f, 0x06, 0x10, 0x10},
+    {2048000 , 64000, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 64000, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0xbf, 0x03, 0x18, 0x18},
+    {1024000 , 64000, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0x7f, 0x02, 0x10, 0x10},
+
+    /* 88.2k */
+    {11289600, 88200, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {5644800 , 88200, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {2822400 , 88200, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1411200 , 88200, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0x7f, 0x02, 0x10, 0x10},
+
+    /* 96k */
+    {12288000, 96000, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {18432000, 96000, 0x03, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {6144000 , 96000, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {3072000 , 96000, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0xff, 0x04, 0x10, 0x10},
+    {1536000 , 96000, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0x7f, 0x02, 0x10, 0x10},
+};
+
+static inline int get_coeff(int mclk, int rate)
+{
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
+        if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
+            return i;
+    }
+    return 7;
+}
+
+/*
+ * if PLL not be used, use internal clk1 for mclk,otherwise, use internal clk2 for PLL source.
+ */
+static int es8311_set_dai_sysclk(struct snd_soc_dai *dai,
+            int clk_id, unsigned int freq, int dir)
+{
+    struct snd_soc_codec *codec = dai->codec;
+    struct es8311_private *es8311 = snd_soc_codec_get_drvdata(codec);
+    printk("Enter into %s()\n", __func__);
+    switch (freq) {
+    case 11289600:
+    case 22579200:
+        es8311->mclk = freq;
+        return 0;
+
+    case 12288000:
+    case 16384000:
+    case 18432000:
+    case 24576000:
+        es8311->mclk = freq;
+        return 0;
+    }
+
+    es8311->mclk =12288000;
+    return 0;
+}
+
+static int es8311_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+    struct snd_soc_codec *codec = codec_dai->codec;
+    u8 iface = 0;
+    u8 adciface = 0;
+    u8 daciface = 0;
+    printk("Enter into %s()\n", __func__);
+    iface    = snd_soc_read(codec, ES8311_RESET_REG00);
+    adciface = snd_soc_read(codec, ES8311_SDPOUT_REG0A);
+    daciface = snd_soc_read(codec, ES8311_SDPIN_REG09);
+
+    /* set master/slave audio interface */
+    switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+    case SND_SOC_DAIFMT_CBM_CFM:    /* MASTER MODE */
+        printk("ES8311 in Master mode\n");
+        iface |= 0x40;
+        break;
+    case SND_SOC_DAIFMT_CBS_CFS:    /* SLAVE MODE */
+        printk("ES8311 in Slave mode\n");
+        iface &= 0xBF;
+        break;
+    default:
+        return -EINVAL;
+    }
+    snd_soc_write(codec, ES8311_RESET_REG00, iface);
+
+
+    /* interface format */
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_I2S:
+        printk("ES8311 in I2S Format\n");
+        adciface &= 0xFC;
+        daciface &= 0xFC;
+        break;
+    case SND_SOC_DAIFMT_RIGHT_J:
+        return -EINVAL;
+    case SND_SOC_DAIFMT_LEFT_J:
+        printk("ES8311 in LJ Format\n");
+        adciface &= 0xFC;
+        daciface &= 0xFC;
+        adciface |= 0x01;
+        daciface |= 0x01;
+        break;
+    case SND_SOC_DAIFMT_DSP_A:
+        printk("ES8311 in DSP-A Format\n");
+        adciface &= 0xDC;
+        daciface &= 0xDC;
+        adciface |= 0x03;
+        daciface |= 0x03;
+        break;
+    case SND_SOC_DAIFMT_DSP_B:
+        printk("ES8311 in DSP-B Format\n");
+        adciface &= 0xDC;
+        daciface &= 0xDC;
+        adciface |= 0x23;
+        daciface |= 0x23;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    iface = snd_soc_read(codec, ES8311_CLK_MANAGER_REG06);
+    /* clock inversion */
+    if(((fmt & SND_SOC_DAIFMT_FORMAT_MASK)==SND_SOC_DAIFMT_I2S) ||
+        ((fmt & SND_SOC_DAIFMT_FORMAT_MASK)==SND_SOC_DAIFMT_LEFT_J))
+        {
+
+        switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+        case SND_SOC_DAIFMT_NB_NF:
+
+            iface    &= 0xDF;
+            adciface &= 0xDF;
+            daciface &= 0xDF;
+            break;
+        case SND_SOC_DAIFMT_IB_IF:
+            iface    |= 0x20;
+            adciface |= 0x20;
+            daciface |= 0x20;
+            break;
+        case SND_SOC_DAIFMT_IB_NF:
+            iface    |= 0x20;
+            adciface &= 0xDF;
+            daciface &= 0xDF;
+            break;
+        case SND_SOC_DAIFMT_NB_IF:
+            iface    &= 0xDF;
+            adciface |= 0x20;
+            daciface |= 0x20;
+            break;
+        default:
+            return -EINVAL;
+        }
+    }
+
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG06, iface);
+    snd_soc_write(codec, ES8311_SDPOUT_REG0A, adciface);
+    snd_soc_write(codec, ES8311_SDPIN_REG09, daciface);
+    return 0;
+}
+
+static int es8311_pcm_startup(struct snd_pcm_substream *substream,
+        struct snd_soc_dai *dai)
+{
+    return 0;
+}
+
+static int es8311_pcm_hw_params(struct snd_pcm_substream *substream,
+            struct snd_pcm_hw_params *params,
+            struct snd_soc_dai *dai)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_codec *codec = rtd->codec;
+    struct es8311_private *es8311 = snd_soc_codec_get_drvdata(codec);
+    u16 iface;
+    int coeff;
+    u8 regv, datmp;
+    printk("Enter into %s(), es8311->mclk: %d, rate: %d\n", __func__, es8311->mclk, params_rate(params));
+
+    coeff = get_coeff(es8311->mclk, params_rate(params));
+    if (coeff < 0) {
+        printk("Unable to configure sample rate %dHz with %dHz MCLK\n",
+            params_rate(params), es8311->mclk);
+        return coeff;
+    }
+    /*
+     * set clock parammeters
+     */
+    if(coeff >= 0) {
+        regv = snd_soc_read(codec, ES8311_CLK_MANAGER_REG02) & 0x07;
+        regv |= (coeff_div[coeff].prediv - 1) << 5;
+        datmp = 0;
+        switch(coeff_div[coeff].premulti)
+        {
+        case 1:
+            datmp = 0;
+            break;
+        case 2:
+            datmp = 1;
+            break;
+        case 4:
+            datmp = 2;
+            break;
+        case 8:
+            datmp = 3;
+            break;
+        default:
+            break;
+        }
+        regv |= (datmp) << 3;
+        snd_soc_write(codec, ES8311_CLK_MANAGER_REG02, regv);
+
+        regv = snd_soc_read(codec, ES8311_CLK_MANAGER_REG05) & 0x00;
+        regv |= (coeff_div[coeff].adcdiv -1)<< 4;
+        regv |= (coeff_div[coeff].dacdiv -1)<< 0;
+        snd_soc_write(codec, ES8311_CLK_MANAGER_REG05, regv);
+
+        regv = snd_soc_read(codec, ES8311_CLK_MANAGER_REG03) & 0x80;
+        regv |= coeff_div[coeff].fsmode << 6;
+        regv |= coeff_div[coeff].adcosr << 0;
+        snd_soc_write(codec, ES8311_CLK_MANAGER_REG03, regv);
+
+        regv = snd_soc_read(codec, ES8311_CLK_MANAGER_REG04) & 0x80;
+        regv |= coeff_div[coeff].dacosr << 0;
+        snd_soc_write(codec, ES8311_CLK_MANAGER_REG04, regv);
+
+        regv = snd_soc_read(codec, ES8311_CLK_MANAGER_REG07) & 0xf0;
+        regv |= coeff_div[coeff].lrck_h << 0;
+        snd_soc_write(codec, ES8311_CLK_MANAGER_REG07, regv);
+
+        regv = snd_soc_read(codec, ES8311_CLK_MANAGER_REG08) & 0x00;
+        regv |= coeff_div[coeff].lrck_l << 0;
+        snd_soc_write(codec, ES8311_CLK_MANAGER_REG08, regv);
+
+        regv = snd_soc_read(codec, ES8311_CLK_MANAGER_REG06) & 0xE0;
+        regv |= coeff_div[coeff].bclkdiv << 0;
+        snd_soc_write(codec, ES8311_CLK_MANAGER_REG06, regv);
+    }
+
+    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        iface = snd_soc_read(codec, ES8311_SDPIN_REG09) & 0xE3;
+        /* bit size */
+        switch (params_format(params)) {
+        case SNDRV_PCM_FORMAT_S16_LE:
+            iface |= 0x0c;
+            break;
+        case SNDRV_PCM_FORMAT_S20_3LE:
+            iface |= 0x04;
+            break;
+        case SNDRV_PCM_FORMAT_S24_LE:
+            break;
+        case SNDRV_PCM_FORMAT_S32_LE:
+            iface |= 0x10;
+            break;
+        }
+        /* set iface */
+        snd_soc_write(codec, ES8311_SDPIN_REG09, iface);
+    } else {
+        iface = snd_soc_read(codec, ES8311_SDPOUT_REG0A) & 0xE3;
+        /* bit size */
+        switch (params_format(params)) {
+        case SNDRV_PCM_FORMAT_S16_LE:
+            iface |= 0x0c;
+            break;
+        case SNDRV_PCM_FORMAT_S20_3LE:
+            iface |= 0x04;
+            break;
+        case SNDRV_PCM_FORMAT_S24_LE:
+            break;
+        case SNDRV_PCM_FORMAT_S32_LE:
+            iface |= 0x10;
+            break;
+        }
+        /* set iface */
+        snd_soc_write(codec, ES8311_SDPOUT_REG0A, iface);
+    }
+    return 0;
+}
+
+static int es8311_set_bias_level(struct snd_soc_codec *codec,
+            enum snd_soc_bias_level level)
+{
+    int regv;
+    struct es8311_private *es8311 = snd_soc_codec_get_drvdata(codec);
+    printk("Enter into %s(), level = %d\n", __func__, level);
+    switch (level) {
+    case SND_SOC_BIAS_PREPARE:
+    case SND_SOC_BIAS_ON:
+        snd_soc_write(codec, ES8311_GP_REG45, 0x00);
+        snd_soc_write(codec, ES8311_ADC_REG16, 0x24);
+        snd_soc_write(codec, ES8311_SYSTEM_REG0B, 0x00);
+        snd_soc_write(codec, ES8311_SYSTEM_REG0C, 0x00);
+        snd_soc_write(codec, ES8311_SYSTEM_REG10, 0x1F);
+        snd_soc_write(codec, ES8311_SYSTEM_REG11, 0x7F);
+        snd_soc_write(codec, ES8311_RESET_REG00, 0x80);
+        snd_soc_write(codec, ES8311_SYSTEM_REG0D, 0x01);
+        snd_soc_write(codec, ES8311_CLK_MANAGER_REG01, 0x3F);
+        if (es8311->mclkinv == true) {
+            snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG01,
+                    0x40, 0x40);
+        }
+        else {
+            snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG01,
+                    0x40, 0x00);
+        }
+        if (es8311->sclkinv == true) {
+            snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG06,
+                    0x20, 0x20);
+        }
+        else {
+            snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG06,
+                    0x20, 0x00);
+        }
+        regv = snd_soc_read(codec, ES8311_SYSTEM_REG14) & 0xCF;
+        regv |= 0x1A;
+        snd_soc_write(codec, ES8311_SYSTEM_REG14, regv);
+        if (es8311->dmic_enable == true) {
+            snd_soc_update_bits(codec, ES8311_SYSTEM_REG14,
+                    0x40, 0x40);
+        }
+        else {
+            snd_soc_update_bits(codec, ES8311_SYSTEM_REG14,
+                    0x40, 0x00);
+        }
+        snd_soc_write(codec, ES8311_SYSTEM_REG13, 0x10);
+        snd_soc_write(codec, ES8311_SYSTEM_REG0E, 0x02);
+        snd_soc_write(codec, ES8311_ADC_REG15, 0x40);
+        snd_soc_write(codec, ES8311_ADC_REG1B, 0x0A);
+        snd_soc_write(codec, ES8311_ADC_REG1C, 0x6A);
+        snd_soc_write(codec, ES8311_DAC_REG37, 0x48);
+        snd_soc_write(codec, ES8311_GPIO_REG44, 0x08);
+        snd_soc_write(codec, ES8311_ADC_REG17, 0xBF);
+        // snd_soc_write(codec, ES8311_DAC_REG32, 0xBF);
+        break;
+    case SND_SOC_BIAS_STANDBY:
+        snd_soc_write(codec, ES8311_SYSTEM_REG12, 0x02);
+        // snd_soc_write(codec, ES8311_DAC_REG32, 0x00);
+        //snd_soc_write(codec, ES8311_ADC_REG17, 0x00);
+        snd_soc_write(codec, ES8311_SYSTEM_REG0E, 0xFF);
+        snd_soc_write(codec, ES8311_SYSTEM_REG0D, 0xFA);
+        snd_soc_write(codec, ES8311_ADC_REG15, 0x00);
+        snd_soc_write(codec, ES8311_DAC_REG37, 0x08);
+        snd_soc_write(codec, ES8311_RESET_REG00, 0x00);
+        snd_soc_write(codec, ES8311_RESET_REG00, 0x1F);
+        snd_soc_write(codec, ES8311_CLK_MANAGER_REG01, 0x30);
+        snd_soc_write(codec, ES8311_CLK_MANAGER_REG01, 0x00);
+        snd_soc_write(codec, ES8311_GP_REG45, 0x01);
+        break;
+    case SND_SOC_BIAS_OFF:
+        break;
+    }
+//  codec->dapm.bias_level = level;
+    return 0;
+}
+
+static int es8311_set_tristate(struct snd_soc_dai *dai, int tristate)
+{
+    struct snd_soc_codec *codec = dai->codec;
+    printk("Enter into %s(), tristate = %d\n", __func__, tristate);
+    if (tristate) {
+        snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG07,
+            0x30, 0x30);
+    }
+    else {
+        snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG07,
+            0x30, 0x00);
+    }
+    return 0;
+}
+
+static int es8311_mute(struct snd_soc_dai *dai, int mute)
+{
+    struct snd_soc_codec *codec = dai->codec;
+    printk("Enter into %s(), mute = %d\n", __func__, mute);
+    if (mute) {
+        snd_soc_write(codec, ES8311_SYSTEM_REG12, 0x02);
+        snd_soc_update_bits(codec, ES8311_DAC_REG31, 0x60, 0x60);
+        // snd_soc_write(codec, ES8311_DAC_REG32, 0x00);
+        snd_soc_write(codec, ES8311_DAC_REG37, 0x08);
+    }
+    else {
+        snd_soc_update_bits(codec, ES8311_DAC_REG31, 0x60, 0x00);
+        snd_soc_write(codec, ES8311_SYSTEM_REG12, 0x00);
+    }
+    return 0;
+}
+
+#define es8311_RATES SNDRV_PCM_RATE_8000_96000
+
+#define es8311_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+        SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_ops es8311_ops = {
+    .startup = es8311_pcm_startup,
+    .hw_params = es8311_pcm_hw_params,
+    .set_fmt = es8311_set_dai_fmt,
+    .set_sysclk = es8311_set_dai_sysclk,
+    .digital_mute = es8311_mute,
+    .set_tristate = es8311_set_tristate,
+};
+
+static struct snd_soc_dai_driver es8311_dai = {
+    .name = "es8311-hifi",
+    .playback = {
+        .stream_name = "Playback",
+        .channels_min = 1,
+        .channels_max = 2,
+        .rates = es8311_RATES,
+        .formats = es8311_FORMATS,
+    },
+    .capture = {
+        .stream_name = "Capture",
+        .channels_min = 1,
+        .channels_max = 2,
+        .rates = es8311_RATES,
+        .formats = es8311_FORMATS,
+    },
+    .ops = &es8311_ops,
+    .symmetric_rates = 1,
+};
+
+static int es8311_suspend(struct snd_soc_codec *codec)
+{
+    printk("Enter into %s()\n", __func__);
+    // snd_soc_write(codec, ES8311_DAC_REG32, 0x00);
+    snd_soc_write(codec, ES8311_ADC_REG17, 0x00);
+    snd_soc_write(codec, ES8311_SYSTEM_REG0E, 0xFF);
+    snd_soc_write(codec, ES8311_SYSTEM_REG12, 0x02);
+    snd_soc_write(codec, ES8311_SYSTEM_REG14, 0x00);
+    snd_soc_write(codec, ES8311_SYSTEM_REG0D, 0xFA);
+    snd_soc_write(codec, ES8311_ADC_REG15, 0x00);
+    snd_soc_write(codec, ES8311_DAC_REG37, 0x08);
+    snd_soc_write(codec, ES8311_RESET_REG00, 0x00);
+    snd_soc_write(codec, ES8311_RESET_REG00, 0x1F);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG01, 0xb0);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG01, 0x00);
+    snd_soc_write(codec, ES8311_GP_REG45, 0x01);
+    return 0;
+}
+
+static int es8311_resume(struct snd_soc_codec *codec)
+{
+    struct es8311_private *es8311 = snd_soc_codec_get_drvdata(codec);
+    printk("Enter into %s()\n", __func__);
+    snd_soc_write(codec, ES8311_GP_REG45, 0x00);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG01, 0x30);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG02, 0x00);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG03, 0x10);
+    snd_soc_write(codec, ES8311_ADC_REG16, 0x24);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG04, 0x10);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG05, 0x00);
+    snd_soc_write(codec, ES8311_SYSTEM_REG0B, 0x00);
+    snd_soc_write(codec, ES8311_SYSTEM_REG0C, 0x00);
+    snd_soc_write(codec, ES8311_SYSTEM_REG10, 0x1F);
+    snd_soc_write(codec, ES8311_SYSTEM_REG11, 0x7F);
+    snd_soc_write(codec, ES8311_RESET_REG00, 0x80);
+    snd_soc_write(codec, ES8311_SYSTEM_REG0D, 0x01);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG01, 0x3F);
+    if (es8311->mclkinv == true) {
+        snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG01,
+                0x40, 0x40);
+    }
+    else {
+        snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG01,
+                0x40, 0x00);
+    }
+    if (es8311->sclkinv == true) {
+        snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG06,
+                0x20, 0x20);
+    }
+    else {
+        snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG06,
+                0x20, 0x00);
+    }
+    snd_soc_write(codec, ES8311_SYSTEM_REG14, 0x1A);
+    if (es8311->dmic_enable == true) {
+        snd_soc_update_bits(codec, ES8311_SYSTEM_REG14,
+                0x40, 0x40);
+    }
+    else {
+        snd_soc_update_bits(codec, ES8311_SYSTEM_REG14,
+                0x40, 0x00);
+    }
+    snd_soc_write(codec, ES8311_SYSTEM_REG12, 0x00);
+    snd_soc_write(codec, ES8311_SYSTEM_REG13, 0x10);
+    snd_soc_write(codec, ES8311_SDPIN_REG09, 0x00);
+    snd_soc_write(codec, ES8311_SDPOUT_REG0A, 0x00);
+    snd_soc_write(codec, ES8311_SYSTEM_REG0E, 0x02);
+    snd_soc_write(codec, ES8311_ADC_REG15, 0x40);
+    snd_soc_write(codec, ES8311_ADC_REG1B, 0x0A);
+    snd_soc_write(codec, ES8311_ADC_REG1C, 0x6A);
+    snd_soc_write(codec, ES8311_DAC_REG37, 0x48);
+    snd_soc_write(codec, ES8311_GPIO_REG44, 0x08);
+    snd_soc_write(codec, ES8311_ADC_REG17, 0xBF);
+    // snd_soc_write(codec, ES8311_DAC_REG32, 0xBF);
+
+    return 0;
+}
+
+static int es8311_probe(struct snd_soc_codec *codec)
+{
+    int ret = 0;
+    struct es8311_private *es8311 = es8311_data;
+    printk("Enter into %s()\n", __func__);
+    if (codec == NULL) {
+        dev_err(codec->dev, "Codec device not registered\n");
+        return -ENODEV;
+    }
+    snd_soc_codec_set_drvdata(codec, es8311);
+    codec->using_regmap = 1;
+    codec->control_data = es8311->regmap;
+
+    es8311_codec = codec;
+    es8311->codec = codec;
+
+    snd_soc_write(codec, ES8311_GP_REG45, 0x00);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG01, 0x30);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG02, 0x10);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG02, 0x9a);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG03, 0x19);
+    snd_soc_write(codec, ES8311_ADC_REG16, 0x20);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG04, 0x19);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG05, 0x22);
+    snd_soc_write(codec, ES8311_SYSTEM_REG0B, 0x00);
+    snd_soc_write(codec, ES8311_SYSTEM_REG0C, 0x00);
+    snd_soc_write(codec, ES8311_SYSTEM_REG10, 0x1F);
+    snd_soc_write(codec, ES8311_SYSTEM_REG11, 0x7F);
+    snd_soc_write(codec, ES8311_RESET_REG00, 0x80);
+    msleep(5);
+    snd_soc_write(codec, ES8311_SYSTEM_REG0D, 0x01);
+    snd_soc_write(codec, ES8311_CLK_MANAGER_REG01, 0x3F);
+    if(es8311->mclkinv == true) {
+        snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG01, 
+                0x40, 0x40);
+    }
+    else {
+        snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG01, 
+                0x40, 0x00);
+    }
+    if(es8311->sclkinv == true) {
+        snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG06,
+                0x20, 0x20); 
+    }
+    else {
+        snd_soc_update_bits(codec, ES8311_CLK_MANAGER_REG06,
+                0x20, 0x00); 
+    }
+    snd_soc_write(codec, ES8311_SYSTEM_REG14, 0x10);
+    if(es8311->dmic_enable == true) {
+        snd_soc_update_bits(codec, ES8311_SYSTEM_REG14,
+                0x40, 0x40);
+    }
+    else {
+        snd_soc_update_bits(codec, ES8311_SYSTEM_REG14,
+                0x40, 0x00);
+    } 
+    snd_soc_write(codec, ES8311_SYSTEM_REG12, 0x00);
+    snd_soc_write(codec, ES8311_SYSTEM_REG13, 0x00);
+    snd_soc_write(codec, ES8311_SDPIN_REG09, 0x00);
+    snd_soc_write(codec, ES8311_SDPOUT_REG0A, 0x00);
+    snd_soc_write(codec, ES8311_SYSTEM_REG0E, 0x02);
+    snd_soc_write(codec, 0x0F, 0x44);
+    snd_soc_write(codec, ES8311_ADC_REG15, 0x00);
+    snd_soc_write(codec, ES8311_ADC_REG1B, 0x0A);
+    snd_soc_write(codec, ES8311_ADC_REG1C, 0x6A);
+    snd_soc_write(codec, ES8311_DAC_REG37, 0x08);
+    // snd_soc_write(codec, ES8311_GPIO_REG44, 0x08);
+    snd_soc_write(codec, ES8311_ADC_REG17, 0xBF);
+    // snd_soc_write(codec, ES8311_DAC_REG32, 0x00);
+
+    msleep(100);
+    es8311_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+    printk("Exit %s()\n", __func__);
+    return ret;
+}
+
+static int es8311_remove(struct snd_soc_codec *codec)
+{
+    es8311_set_bias_level(codec, SND_SOC_BIAS_OFF);
+    return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_es8311 = {
+    .probe = es8311_probe,
+    .remove = es8311_remove,
+    .suspend = es8311_suspend,
+    .resume = es8311_resume,
+    .set_bias_level = es8311_set_bias_level,
+
+    // .reg_cache_size = ARRAY_SIZE(es8311_reg_defaults),
+    // .reg_word_size = sizeof(u8),
+    // .reg_cache_default = es8311_reg_defaults,
+
+    .controls = es8311_snd_controls,
+    .num_controls = ARRAY_SIZE(es8311_snd_controls),
+    .dapm_widgets = es8311_dapm_widgets,
+    .num_dapm_widgets = ARRAY_SIZE(es8311_dapm_widgets),
+    .dapm_routes = es8311_dapm_routes,
+    .num_dapm_routes = ARRAY_SIZE(es8311_dapm_routes),
+};
+
+static struct regmap_config es8311_regmap = {
+    .reg_bits = 8,
+    .val_bits = 8,
+
+    .max_register = ES8311_MAX_REGISTER,
+    .reg_defaults = es8311_reg_defaults,
+    .num_reg_defaults = ARRAY_SIZE(es8311_reg_defaults),
+    .volatile_reg = es8311_volatile_register,
+    .writeable_reg = es8311_writable_register,
+    .readable_reg  = es8311_readable_register,
+    .cache_type = REGCACHE_RBTREE,
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id es8311_if_dt_ids[] = {
+    { .compatible = "ambarella,es8311", },
+    { }
+};
+#endif
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+static void es8311_i2c_shutdown(struct i2c_client *i2c)
+{
+    struct snd_soc_codec *codec;
+    struct es8311_private *es8311;
+    es8311 = i2c_get_clientdata(i2c);
+    codec = es8311->codec;
+    return;
+}
+static u32 cur_reg = 0;
+
+static ssize_t es8311_show(struct device *dev, 
+			struct device_attribute *attr, char *_buf)
+{
+	int i = 0;
+	int ret;
+
+	for(i = 0; i < 0xff;i++)
+	{
+		printk("es8311_show:reg 0x%04x=0x%04x\n", i,snd_soc_read(es8311_codec, i));
+	}
+
+	ret = sprintf(_buf, "%s(): get 0x%04x=0x%04x\n",
+			__FUNCTION__, cur_reg,
+			snd_soc_read(es8311_codec, cur_reg));
+	return ret;
+}
+/*
+static u32 strtol(const char *nptr, int base)
+{
+	u32 ret; 
+	if(!nptr || (base!=16 && base!=10 && base!=8))
+	{
+		printk("%s(): NULL pointer input\n", __FUNCTION__);
+		return -1;
+	}
+	for(ret=0; *nptr; nptr++)
+	{
+		if((base==16 && *nptr>='A' && *nptr<='F') ||
+			(base==16 && *nptr>='a' && *nptr<='f') ||
+			(base>=10 && *nptr>='0' && *nptr<='9') ||
+			(base>=8 && *nptr>='0' && *nptr<='7') )
+		{
+			ret *= base;
+			if(base==16 && *nptr>='A' && *nptr<='F')
+				ret += *nptr-'A'+10;
+			else if(base==16 && *nptr>='a' && *nptr<='f')
+				ret += *nptr-'a'+10;
+			else if(base>=10 && *nptr>='0' && *nptr<='9')
+				ret += *nptr-'0';
+			else if(base>=8 && *nptr>='0' && *nptr<='7')
+				ret += *nptr-'0';
+		}
+		else
+			return ret;
+	}
+	return ret;
+}
+*/
+static ssize_t es8311_store(struct device *dev,
+            struct device_attribute *attr,
+            const char *buf, size_t count)
+{
+    int val = 0, flag = 0;
+    u8 i = 0, reg, num, value_w, value_r;
+
+    val = simple_strtol(buf, NULL, 16);
+    flag = (val >> 16) & 0xFF;
+
+    if (flag) {
+        reg = (val >> 8) & 0xFF;
+        value_w = val & 0xFF;
+        printk("\nWrite: start REG:0x%02x,val:0x%02x,count:0x%02x\n",
+                reg, value_w, flag);
+        while (flag--) {
+            snd_soc_write(es8311_codec, reg, value_w);
+            printk("Write 0x%02x to REG:0x%02x\n",
+                value_w,
+                reg);
+            reg++;
+        }
+    }
+    else {
+        reg = (val >> 8) & 0xFF;
+        num = val & 0xff;
+        printk("\nRead: start REG:0x%02x,count:0x%02x\n",
+            reg, num);
+        do {
+            value_r = 0;
+            value_r = snd_soc_read(es8311_codec, reg);
+            printk("REG[0x%02x]: 0x%02x;  \n",
+            reg, value_r);
+            reg++;
+            i++;
+        } while (i<num);
+    }
+
+    return count;
+}
+
+//static struct device *es8311_dev = NULL;
+//static struct class *es8311_class = NULL;
+static DEVICE_ATTR(es8311, 0664, es8311_show, es8311_store);
+
+static struct attribute *es8311_debug_attrs[] = {
+    &dev_attr_es8311.attr,
+    NULL,
+};
+
+static struct attribute_group es8311_debug_attr_group = {
+    .name   = "es8311_debug",
+    .attrs  = es8311_debug_attrs,
+};
+
+static int es8311_i2c_probe(struct i2c_client *i2c_client,
+                    const struct i2c_device_id *id)
+{
+    struct es8311_private *es8311;
+    int ret = -1;
+    printk("Enter into %s\n", __func__);
+    es8311 = devm_kzalloc(&i2c_client->dev,
+            sizeof(*es8311), GFP_KERNEL);
+    if (es8311 == NULL)
+        return -ENOMEM;
+
+    printk("Enter into %s---1\n", __func__);
+    es8311->dmic_enable = false;     // dmic interface disabled
+    es8311->mclk = 12000000;
+    /* the edge of lrck is always at the falling edge of mclk */
+    es8311->mclkinv = false;
+    /* the edge of lrck is always at the falling edge of sclk */
+    es8311->sclkinv = false;
+
+    printk("Enter into %s----2\n", __func__);
+    i2c_set_clientdata(i2c_client, es8311);
+    es8311->regmap = devm_regmap_init_i2c(i2c_client, &es8311_regmap);
+    if (IS_ERR(es8311->regmap)) {
+        ret = PTR_ERR(es8311->regmap);
+        dev_err(&i2c_client->dev, "regmap_init() failed: %d\n", ret);
+        return ret;
+    }
+//  dev_set_drvdata(&i2c_client->dev,  es8311);
+    es8311_data = es8311;
+    printk("Enter into %s---3\n", __func__);
+    ret = snd_soc_register_codec(&i2c_client->dev,
+            &soc_codec_dev_es8311,
+            &es8311_dai,
+            1);
+    if (ret < 0) {
+        kfree(es8311);
+        return ret;
+    }
+
+    printk("Enter into %s-----4\n", __func__);
+    ret = sysfs_create_group(&i2c_client->dev.kobj,
+                &es8311_debug_attr_group);
+    if (ret) {
+        pr_err("failed to create attr group\n");
+    }
+
+    printk("Exit %s\n", __func__);
+    return ret;
+}
+
+static int es8311_i2c_remove(struct i2c_client *client)
+{
+    snd_soc_unregister_codec(&client->dev);
+    kfree(i2c_get_clientdata(client));
+    return 0;
+}
+
+static const struct i2c_device_id es8311_i2c_id[] = {
+    {"es8311", 0 },
+    { }
+};
+MODULE_DEVICE_TABLE(i2c, es8311_i2c_id);
+
+static struct i2c_driver es8311_i2c_driver = {
+    .driver = {
+        .name   = "es8311",
+        .owner  = THIS_MODULE,
+#ifdef CONFIG_OF
+        .of_match_table = of_match_ptr(es8311_if_dt_ids),
+#endif
+    },
+    .shutdown = es8311_i2c_shutdown,
+    .probe = es8311_i2c_probe,
+    .remove = es8311_i2c_remove,
+    .id_table   = es8311_i2c_id,
+};
+#endif
+
+static int __init es8311_init(void)
+{
+    int ret;
+    printk("%s enter\n", __func__);
+    ret = i2c_add_driver(&es8311_i2c_driver);
+    if (ret != 0)
+        printk("Failed to register es8311 i2c driver\n");
+    return ret;
+}
+
+static void __exit es8311_exit(void)
+{
+    return i2c_del_driver(&es8311_i2c_driver);
+}
+
+late_initcall(es8311_init);
+module_exit(es8311_exit);
+
+MODULE_DESCRIPTION("ASoC es8311 driver");
+MODULE_AUTHOR("David Yang <yangxiaohua@everest-semi.com>");
+MODULE_LICENSE("GPL");
+
+
Index: linux-3.10.108/sound/soc/codecs/es8311.h
===================================================================
--- /dev/null
+++ linux-3.10.108/sound/soc/codecs/es8311.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2012-2020. All rights reserved.
+ * Description: Sound Balong ES8316 Codec Driver Header
+ */
+
+#ifndef _ES8311_H
+#define _ES8311_H
+
+/*
+ *   ES8311_REGISTER NAME_REG_REGISTER ADDRESS
+ */
+#define ES8311_RESET_REG00          0x00 /*reset digital,csm,clock manager etc.*/
+
+/*
+ * Clock Scheme Register definition
+ */
+#define ES8311_CLK_MANAGER_REG01    0x01 /* select clk src for mclk, enable clock for codec */
+#define ES8311_CLK_MANAGER_REG02    0x02 /* clk divider and clk multiplier */
+#define ES8311_CLK_MANAGER_REG03    0x03 /* adc fsmode and osr  */
+#define ES8311_CLK_MANAGER_REG04    0x04 /* dac osr */
+#define ES8311_CLK_MANAGER_REG05    0x05 /* clk divier for adc and dac */
+#define ES8311_CLK_MANAGER_REG06    0x06 /* bclk inverter and divider */
+#define ES8311_CLK_MANAGER_REG07    0x07 /* tri-state, lrck divider */
+#define ES8311_CLK_MANAGER_REG08    0x08 /* lrck divider */
+#define ES8311_SDPIN_REG09          0x09 /* dac serial digital port */
+#define ES8311_SDPOUT_REG0A         0x0A /* adc serial digital port */
+#define ES8311_SYSTEM_REG0B         0x0B /* system */
+#define ES8311_SYSTEM_REG0C         0x0C /* system */
+#define ES8311_SYSTEM_REG0D         0x0D /* system, power up/down */
+#define ES8311_SYSTEM_REG0E         0x0E /* system, power up/down */
+#define ES8311_SYSTEM_REG0F         0x0F /* system, low power */
+#define ES8311_SYSTEM_REG10         0x10 /* system */
+#define ES8311_SYSTEM_REG11         0x11 /* system */
+#define ES8311_SYSTEM_REG12         0x12 /* system, Enable DAC */
+#define ES8311_SYSTEM_REG13         0x13 /* system */
+#define ES8311_SYSTEM_REG14         0x14 /* system, select DMIC, select analog pga gain */
+#define ES8311_ADC_REG15            0x15 /* ADC, adc ramp rate, dmic sense */
+#define ES8311_ADC_REG16            0x16 /* ADC */
+#define ES8311_ADC_REG17            0x17 /* ADC, volume */
+#define ES8311_ADC_REG18            0x18 /* ADC, alc enable and winsize */
+#define ES8311_ADC_REG19            0x19 /* ADC, alc maxlevel */
+#define ES8311_ADC_REG1A            0x1A /* ADC, alc automute */
+#define ES8311_ADC_REG1B            0x1B /* ADC, alc automute, adc hpf s1 */
+#define ES8311_ADC_REG1C            0x1C /* ADC, equalizer, hpf s2 */
+#define ES8311_DAC_REG31            0x31 /* DAC, mute */
+#define ES8311_DAC_REG32            0x32 /* DAC, volume */
+#define ES8311_DAC_REG33            0x33 /* DAC, offset */
+#define ES8311_DAC_REG34            0x34 /* DAC, drc enable, drc winsize */
+#define ES8311_DAC_REG35            0x35 /* DAC, drc maxlevel, minilevel */
+#define ES8311_DAC_REG37            0x37 /* DAC, ramprate */
+#define ES8311_GPIO_REG44           0x44 /* GPIO, dac2adc for test */
+#define ES8311_GP_REG45             0x45 /* GP CONTROL */
+#define ES8311_CHD1_REGFD           0xFD /* CHIP ID1 */
+#define ES8311_CHD2_REGFE           0xFE /* CHIP ID2 */
+#define ES8311_CHVER_REGFF          0xFF /* VERSION */
+#define ES8311_CHD1_REGFD           0xFD /* CHIP ID1 */
+
+#define ES8311_MAX_REGISTER         0xFF
+
+#endif
Index: linux-3.10.108/sound/soc/mtk/Makefile
===================================================================
--- linux-3.10.108.orig/sound/soc/mtk/Makefile
+++ linux-3.10.108/sound/soc/mtk/Makefile
@@ -1,16 +1,26 @@
 KBUILD_CFLAGS += -I$(srctree)
 
+KBUILD_CFLAGS += -DCONFIG_MT7628 -DCONFIG_RALINK_MT7628
+KBUILD_CFLAGS += -DCONFIG_GDMA_EVERYBODY
+KBUILD_CFLAGS += -DCONFIG_SND_MT76XX_SOC
+KBUILD_CFLAGS += -DCONFIG_I2S_IN_MCLK
+KBUILD_CFLAGS += -DCONFIG_I2S_MCLK_12MHZ
+KBUILD_CFLAGS += -DCONFIG_GDMA_EVERYBODY
+KBUILD_CFLAGS += -DSURFBOARDINT_DMA=15
+KBUILD_CFLAGS += -DRALINK_INTCTL_DMA=128
+
 # MTK APSoC Platform Support
+snd-soc-mt76xx-i2s-ctl-objs := i2s_ctrl.o i2s_debug.o
 snd-soc-mt76xx-pcm-objs := mt76xx_pcm.o
 snd-soc-mt76xx-i2s-objs := mt76xx_i2s.o
 
 obj-$(CONFIG_SND_MT76XX_PCM) += snd-soc-mt76xx-pcm.o
-obj-$(CONFIG_SND_MT76XX_I2S) += snd-soc-mt76xx-i2s.o
+obj-$(CONFIG_SND_MT76XX_I2S) += snd-soc-mt76xx-i2s-ctl.o snd-soc-mt76xx-i2s.o
 
 # MTK APSoC Machine Support
 snd-soc-mt76xx-machine-objs := mt76xx_machine.o
 
-obj-$(CONFIG_SND_MT76XX_SOC) += snd-soc-mt76xx-machine.o
+obj-$(CONFIG_SND_MT76XX_SOC) += snd-soc-mt76xx-machine.o ralink_gdma.o 
 
 
 
Index: linux-3.10.108/sound/soc/mtk/i2s_ctrl.c
===================================================================
--- /dev/null
+++ linux-3.10.108/sound/soc/mtk/i2s_ctrl.c
@@ -0,0 +1,3583 @@
+#include <linux/init.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+#include <linux/sched.h>
+#endif
+#include <linux/module.h>
+#include <linux/kernel.h> /* _printk() */
+#include <linux/slab.h> /* kmalloc() */
+#include <linux/fs.h> /* everything... */
+#include <linux/errno.h> /* error codes */
+#include <linux/types.h> /* size_t */
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h> /* O_ACCMODE */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,14)
+#include <asm/system.h> /* cli(), *_flags */
+#endif
+#include <asm/uaccess.h> /* copy_from/to_user */
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/mm_types.h>
+#include <asm/mach-ralink/surfboardint.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include "ralink_gdma.h"
+#if defined(CONFIG_I2S_WITH_AEC)
+#include "../aec/aec_api.h"
+#endif
+
+#ifdef  CONFIG_DEVFS_FS
+#include <linux/devfs_fs_kernel.h>
+static	devfs_handle_t devfs_handle;
+#endif
+
+#include "i2s_ctrl.h"
+
+#if defined(CONFIG_SND_MT76XX_SOC)
+#include <sound/soc/mtk/mt76xx_machine.h>
+#endif
+
+#if defined(CONFIG_I2S_WM8750)
+#include "../codec/i2c_wm8750.h"
+#endif
+#if defined(CONFIG_I2S_WM8751)
+#include "../codec/i2c_wm8751.h"
+#endif
+#if defined(CONFIG_I2S_WM8960)
+#include "i2c_wm8960.h"
+#endif
+
+static int i2sdrv_major =  191;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+#else
+static struct class *i2smodule_class;
+#endif
+
+// #define DEBUG
+
+#ifdef DEBUG
+#define _printk printk
+#else
+static int _printk(char *fmt, ...)
+{
+	return 0;
+}
+#endif
+
+/* external functions declarations */
+#if defined(CONFIG_I2S_WM8960)
+extern void audiohw_set_frequency(int fsel, int codec_pll_en);
+void audiohw_set_apll(int srate);
+#elif defined(CONFIG_I2S_WM8750)||defined(CONFIG_I2S_WM8751)
+extern void audiohw_set_frequency(int fsel);
+#endif
+#if defined(CONFIG_I2S_WM8960)||defined(CONFIG_I2S_WM8750)||defined(CONFIG_I2S_WM8751)
+extern int audiohw_set_lineout_vol(int Aout, int vol_l, int vol_r);
+extern int audiohw_set_master_vol(int vol_l, int vol_r);
+extern int audiohw_set_linein_vol(int vol_l, int vol_r);
+#endif
+
+extern void audiohw_micboost(int boostgain);
+
+extern int GdmaI2sTx(uint32_t Src, uint32_t Dst, uint8_t TxNo, uint16_t TransCount,
+                void (*DoneIntCallback)(uint32_t data),
+                void (*UnMaskIntCallback)(uint32_t data));
+
+extern int GdmaI2sRx(uint32_t Src, uint32_t Dst, uint8_t RxNo, uint16_t TransCount,
+                void (*DoneIntCallback)(uint32_t data),
+                void (*UnMaskIntCallback)(uint32_t data));
+
+extern int GdmaMaskChannel(uint32_t ChNum);
+
+extern int GdmaUnMaskChannel(uint32_t ChNum);
+
+/* internal functions declarations */
+irqreturn_t i2s_irq_isr(int irq, void *irqaction);
+int i2s_debug_cmd(unsigned int cmd, unsigned long arg);
+
+/* forward declarations for _fops */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+static long i2s_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+#else
+static int i2s_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+#endif
+static int i2s_mmap(struct file *file, struct vm_area_struct *vma);
+static int i2s_open(struct inode *inode, struct file *file);
+static int i2s_release(struct inode *inode, struct file *file);
+int i2s_mmap_alloc(unsigned long size,int dir);
+int i2s_mmap_remap(struct vm_area_struct *vma, unsigned long size);
+
+/* global varable definitions */
+i2s_config_type i2s_config;
+i2s_status_type i2s_status; 
+i2s_config_type* pi2s_config = &i2s_config;;
+i2s_status_type* pi2s_status = &i2s_status;;
+
+static inline long
+ugly_hack_sleep_on_timeout(wait_queue_head_t *q, long timeout)
+{
+	unsigned long flags;
+	wait_queue_t wait;
+
+	init_waitqueue_entry(&wait, current);
+
+	__set_current_state(TASK_INTERRUPTIBLE);
+	spin_lock_irqsave(&q->lock, flags);
+	__add_wait_queue(q, &wait);
+	spin_unlock(&q->lock);
+
+	timeout = schedule_timeout(timeout);
+
+	spin_lock_irq(&q->lock);
+	__remove_wait_queue(q, &wait);
+	spin_unlock_irqrestore(&q->lock, flags);
+
+	return timeout;
+}
+
+#define interruptible_sleep_on(x) \
+	ugly_hack_sleep_on_timeout(x, MAX_SCHEDULE_TIMEOUT);
+
+
+#if defined(ARM_ARCH)
+static dma_addr_t i2s_txdma_addr0, i2s_txdma_addr1;
+static dma_addr_t i2s_rxdma_addr0, i2s_rxdma_addr1;
+#define I2S_TX_FIFO_WREG_PHY (I2S_TX_FIFO_WREG & 0x1FFFFFFF)
+#define I2S_RX_FIFO_RREG_PHY (I2S_RX_FIFO_RREG & 0x1FFFFFFF)
+#else
+static dma_addr_t i2s_txdma_addr, i2s_rxdma_addr;
+#endif
+static dma_addr_t i2s_mmap_addr[MAX_I2S_PAGE*2];
+				      /* 8khz 11.025khz 12khz  16khz 22.05khz 24Khz  32khz 44.1khz 48khz 88.2khz 96khz*/
+unsigned long i2s_inclk_15p625Mhz[11] = {60<<8, 43<<8,  40<<8, 30<<8, 21<<8,  19<<8, 14<<8, 10<<8, 9<<8,  7<<8,  4<<8};
+unsigned long i2s_exclk_12p288Mhz[11] = {47<<8, 34<<8,  31<<8, 23<<8, 16<<8,  15<<8, 11<<8,  8<<8, 7<<8,  5<<8,  3<<8};
+unsigned long i2s_exclk_12Mhz[11]     = {46<<8, 33<<8,  30<<8, 22<<8, 16<<8,  15<<8, 11<<8,  8<<8, 7<<8,  5<<8,  3<<8};
+#if defined(CONFIG_I2S_WM8750) || defined(CONFIG_SND_SOC_WM8750)
+					/* 8k  11.025k  12k   16k  22.05k  24k  32k   44.1k   48k  88.2k   96k*/
+unsigned long i2s_codec_12p288Mhz[11]  = {0x0C,  0x00, 0x10, 0x14,  0x38, 0x38, 0x18,  0x20, 0x00,  0x00, 0x1C};
+unsigned long i2s_codec_12Mhz[11]      = {0x0C,  0x32, 0x10, 0x14,  0x37, 0x38, 0x18,  0x22, 0x00,  0x3E, 0x1C};
+unsigned long i2s_codec_24p576Mhz[11]  = {0x4C,  0x00, 0x50, 0x54,  0x00, 0x78, 0x58,  0x00, 0x40,  0x00, 0x5C};
+unsigned long i2s_codec_18p432Mhz[11]  = {0x0e,  0x32, 0x12, 0x16,  0x36, 0x3a, 0x1a,  0x22, 0x02,  0x3e, 0x1e};
+#endif
+#if defined(CONFIG_I2S_WM8751) || defined(CONFIG_SND_SOC_WM8751)
+unsigned long i2s_codec_12p288Mhz[11]  = {0x04,  0x00, 0x10, 0x14,  0x38, 0x38, 0x18,  0x20, 0x00,  0x00, 0x1C};
+unsigned long i2s_codec_12Mhz[11]      = {0x04,  0x32, 0x10, 0x14,  0x37, 0x38, 0x18,  0x22, 0x00,  0x3E, 0x1C};
+#endif
+#if defined(CONFIG_I2S_WM8960) || defined(CONFIG_SND_SOC_WM8960)
+unsigned long i2s_codec_12p288Mhz[11]  = {0x36,  0x24, 0x24, 0x1b,  0x12, 0x12, 0x09,  0x00, 0x00,  0x00, 0x00};
+unsigned long i2s_codec_12Mhz[11]      = {0x36,  0x24, 0x24, 0x1b,  0x12, 0x12, 0x09,  0x00, 0x00,  0x00, 0x00};
+#endif
+#if defined(CONFIG_I2S_WM8750) || defined(CONFIG_SND_SOC_WM8750) || defined(CONFIG_I2S_WM8751) || defined(CONFIG_SND_SOC_WM8751) || defined(CONFIG_I2S_WM8960) || defined(CONFIG_SND_SOC_WM8960)
+EXPORT_SYMBOL(i2s_codec_12p288Mhz);
+EXPORT_SYMBOL(i2s_codec_12Mhz);
+#endif
+
+#if defined(CONFIG_RALINK_RT6855A)
+				   /* 8K  11.025k  12k   16k  22.05k   24k   32k  44.1K   48k  88.2k  96k */
+unsigned long i2s_inclk_int[11]  = {  97,    70,    65,   48,    35,    32,   24,   17,    16,   12,    8};
+unsigned long i2s_inclk_comp[11] = { 336,   441,    53,  424,   220,   282,  212,  366,   141,  185,   70};
+#elif defined (CONFIG_RALINK_MT7621)
+#ifdef MT7621_ASIC_BOARD
+#if defined (CONFIG_I2S_MCLK_12P288MHZ)
+unsigned long i2s_inclk_int[11]  = { 576,   384,    0,   288,   192,   192,  144,   96,    96,   48,   48};
+unsigned long i2s_inclk_comp[11] = {   0,     0,    0,     0,     0,     0,    0,    0,     0,    0,    0};
+#elif defined(CONFIG_I2S_MCLK_12MHZ)
+unsigned long i2s_inclk_int[11] =  {1171,   850,    0,   585,   425,   390,  292,  212,   195,   106,   97};
+unsigned long i2s_inclk_comp[11] = { 448,   174,    0,   480,    87,   320,  496,  299,   160,   149,  336};
+#endif
+#else //MT7621_FPGA_BOARD
+unsigned long i2s_inclk_int[11] =  { 529,   384,    0,   264,   192,   176,  132,   96,    88,    48,   44};
+unsigned long i2s_inclk_comp[11] = { 102,     0,    0,   307,     0,   204,  153,    0,   102,     0,   51};
+#endif
+#elif defined (CONFIG_RALINK_MT7628)
+#ifdef MT7628_ASIC_BOARD
+                                      /* 8K  11.025k 12k  16k 22.05k 24k  32k 44.1K  48k  88.2k 96k  176k 192k */
+unsigned long i2s_inclk_int_16bit[13] = {937,  680,   0,  468,  340, 312, 234, 170,  156,   85, 78,   42,  39};
+unsigned long i2s_inclk_comp_16bit[13]= {256,  139,   0,  384,   69, 256, 192,  34,  128,   17, 64,  267,  32};
+unsigned long i2s_inclk_int_24bit[13] = {625,  404,   0,  312,  226, 208, 156, 113,  104,   56, 52,   28,  26};
+unsigned long i2s_inclk_comp_24bit[13]= {  0,  404,   0,  256,  387, 170, 128, 193,   85,  352, 42,  176,  21};
+#else
+				      /* 8K  11.025k 12k  16k 22.05k 24k  32k 44.1K  48k  88.2k 96k  176k 192k */
+unsigned long i2s_inclk_int_16bit[13] = {468,  340,   0,  234,  170, 156, 117,  85,   78,   42, 39,   21,  19};
+unsigned long i2s_inclk_comp_16bit[13]= {384,   69,   0,  192,   34, 128,  96,  17,   64,  264, 32,  133, 272};
+unsigned long i2s_inclk_int_24bit[13] = {312,  202,   0,  156,  113, 104,  78,  56,   52,   28, 26,   14,  13};
+unsigned long i2s_inclk_comp_24bit[13]= {256,  202,   0,  128,  193,  85,  64, 352,   42,  176,  21,  88,  10};
+#endif
+#elif defined (CONFIG_ARCH_MT7623)
+#if defined MT7623_ASIC_BOARD
+				      /* 8K  11.025k 12k  16k 22.05k 24k  32k 44.1K  48k  88.2k 96k  176k 192k */
+unsigned long i2s_inclk_int_16bit[13] = {576,  384,   0,  288,  192, 192, 144,  96,  96,    48, 48,   24,  24};
+unsigned long i2s_inclk_comp_16bit[13]= { 0,    0,    0,    0,   0,    0,   0,   0,   0,     0,  0,    0,   0};
+unsigned long i2s_inclk_int_24bit[13] = {384,  256,   0,  192,  128, 128,  96,  64,  64,    32, 32,   16,  16};
+unsigned long i2s_inclk_comp_24bit[13]= { 0,    0,    0,    0,   0,    0,   0,   0,   0,     0,  0,    0,   0};
+#else
+				      /* 8K  11.025k 12k  16k 22.05k 24k  32k 44.1K  48k  88.2k 96k  176k 192k */
+unsigned long i2s_inclk_int_16bit[13] = {72,   48,    0,   36,  24,   24,  18,  12,   12,    6,  6,    3,   3};
+unsigned long i2s_inclk_comp_16bit[13]= { 0,    0,    0,    0,   0,    0,   0,   0,    0,    0,  0,    0,   0};
+unsigned long i2s_inclk_int_24bit[13] = {48,   32,    0,   24,  16,   16,  12,   8,    8,    4,  4,    2,   2};
+unsigned long i2s_inclk_comp_24bit[13]= { 0,    0,    0,    0,   0,    0,   0,   0,    0,    0,  0,    0,   0};
+#endif
+#else
+				  /* 8K  11.025k 12k  16k  22.05k  24k  32k  44.1K  48k  88.2k  96k */
+unsigned long i2s_inclk_int[11]  = { 78,    56,   52,  39,   28,    26,  19,   14,   13,   9,    6};
+unsigned long i2s_inclk_comp[11] = { 64,   352,   42,  32,  176,    21, 272,   88,   10, 455,  261};
+#endif
+
+#if defined(CONFIG_I2S_WITH_AEC)
+aecFuncTbl_t *aecFuncP;
+#endif
+/* USB mode 22.05Khz register value in datasheet is 0x36 but will cause slow clock, 0x37 is correct value */
+/* USB mode 44.1Khz register value in datasheet is 0x22 but will cause slow clock, 0x23 is correct value */
+
+struct tasklet_struct i2s_tx_tasklet;
+struct tasklet_struct i2s_rx_tasklet;
+EXPORT_SYMBOL(i2s_tx_tasklet);
+EXPORT_SYMBOL(i2s_rx_tasklet);
+
+char test_buf[I2S_PAGE_SIZE];
+char test_buf_1[I2S_PAGE_SIZE];
+char test_buf_2[I2S_PAGE_SIZE];
+
+static const struct file_operations i2s_fops = {
+	owner		: THIS_MODULE,
+	mmap		: i2s_mmap,
+	open		: i2s_open,
+	release		: i2s_release,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+	unlocked_ioctl:     i2s_ioctl,
+#else	
+	ioctl		: i2s_ioctl,
+#endif	
+};
+
+int __init i2s_mod_init(void)
+{
+	int result;
+
+	_printk("******* i2s module init **********\n");
+	/* register device with kernel */
+#ifdef  CONFIG_DEVFS_FS
+    	if(devfs_register_chrdev(i2sdrv_major, I2SDRV_DEVNAME , &i2s_fops)) {
+		_printk(KERN_WARNING " i2s: can't create device node - %s\n", I2SDRV_DEVNAME);
+		return -EIO;
+    	}
+
+    	devfs_handle = devfs_register(NULL, I2SDRV_DEVNAME, DEVFS_FL_DEFAULT, i2sdrv_major, 0, 
+	    S_IFCHR | S_IRUGO | S_IWUGO, &i2s_fops, NULL);
+#else
+    	result = register_chrdev(i2sdrv_major, I2SDRV_DEVNAME, &i2s_fops);
+    	if (result < 0) {
+		_printk(KERN_WARNING "i2s: can't get major %d\n",i2sdrv_major);
+        	return result;
+    	}
+
+    	if (i2sdrv_major == 0) {
+		i2sdrv_major = result; /* dynamic */
+    	}
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+#else	
+	i2smodule_class=class_create(THIS_MODULE, I2SDRV_DEVNAME);
+	if (IS_ERR(i2smodule_class)) 
+		return -EFAULT;
+	device_create(i2smodule_class, NULL, MKDEV(i2sdrv_major, 0), I2SDRV_DEVNAME);
+#endif	
+
+#if defined(CONFIG_I2S_WITH_AEC)
+	_printk("AEC FuncP init \n");
+	/*Add by mtk04880*/
+	aecFuncP = kmalloc(sizeof(aecFuncTbl_t), GFP_KERNEL);
+	/*If aecFuncP cannot request memory,it will be ignored in I2S module. Since AEC & I2S are independent
+	 * when AEC module is inserted,It will return err message (but I2S will keep running without AEC support)
+	 * */
+	if(aecFuncP){
+		memset(aecFuncP,0,sizeof(aecFuncTbl_t));
+	}
+#endif
+
+	return 0;
+}
+
+void i2s_mod_exit(void)
+{
+	_printk("************ i2s module exit *************\n");	
+#ifdef  CONFIG_DEVFS_FS
+    	devfs_unregister_chrdev(i2sdrv_major, I2SDRV_DEVNAME);
+    	devfs_unregister(devfs_handle);
+#else
+    	unregister_chrdev(i2sdrv_major, I2SDRV_DEVNAME);
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+#else
+	device_destroy(i2smodule_class,MKDEV(i2sdrv_major, 0));
+	class_destroy(i2smodule_class); 
+#endif	
+	return ;
+}
+
+
+int i2s_open(struct inode *inode, struct file *filp)
+{
+#if defined(I2S_HW_INTERRUPT_EN)&&(I2S_SW_IRQ_EN)
+	int Ret;
+#endif
+	int minor = iminor(inode);
+
+	if (minor >= I2S_MAX_DEV)
+		return -ENODEV;
+	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_INC_USE_COUNT;
+#else
+	try_module_get(THIS_MODULE);
+#endif
+
+	if (filp->f_flags & O_NONBLOCK) {
+		MSG("filep->f_flags O_NONBLOCK set\n");
+		return -EAGAIN;
+	}
+
+	/* set i2s_config */
+	filp->private_data = pi2s_config;
+	memset(pi2s_config, 0, sizeof(i2s_config_type));
+#ifdef I2S_STATISTIC
+	memset(pi2s_status, 0, sizeof(i2s_status_type));	
+#endif
+	i2s_param_init(pi2s_config);
+
+#if defined(I2S_HW_INTERRUPT_EN)&&(I2S_SW_IRQ_EN)	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+	Ret = request_irq(SURFBOARDINT_I2S, i2s_irq_isr, IRQF_DISABLED, "Ralink_I2S", NULL);
+#else
+	Ret = request_irq(SURFBOARDINT_I2S, i2s_irq_isr, SA_INTERRUPT, "Ralink_I2S", NULL);
+#endif
+	
+	if(Ret){
+		MSG("IRQ %d is not free.\n", SURFBOARDINT_I2S);
+		i2s_release(inode, filp);
+		return -1;
+	}
+#endif	
+ 
+    	init_waitqueue_head(&(pi2s_config->i2s_tx_qh));
+    	init_waitqueue_head(&(pi2s_config->i2s_rx_qh));
+	spin_lock_init(&pi2s_config->lock);
+
+	return 0;
+}
+
+
+static int i2s_release(struct inode *inode, struct file *filp)
+{
+	i2s_config_type* ptri2s_config;
+	
+	/* decrement usage count */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_DEC_USE_COUNT;
+#else
+	module_put(THIS_MODULE);
+#endif
+
+#if defined(I2S_HW_INTERRUPT_EN)&&(I2S_SW_IRQ_EN)
+	free_irq(SURFBOARDINT_I2S, NULL);
+#endif
+	
+	ptri2s_config = filp->private_data;
+	if(ptri2s_config==NULL)
+		goto EXIT;
+
+	if(pi2s_config->is_tx_mmap)
+		i2s_mem_unmap(ptri2s_config,STREAM_PLAYBACK);
+	else
+		i2s_txbuf_free(ptri2s_config);
+
+	if(pi2s_config->is_rx_mmap)
+		i2s_mem_unmap(ptri2s_config,STREAM_CAPTURE);
+	else
+		i2s_rxbuf_free(ptri2s_config);
+	
+	/* free buffer */
+	i2s_txPagebuf_free(ptri2s_config);
+	i2s_rxPagebuf_free(ptri2s_config);	
+EXIT:			
+	MSG("i2s_release succeeds\n");
+	return 0;
+}
+
+int i2s_mmap_alloc(unsigned long size,int dir)
+{
+	int i;
+	u32 page_size;
+       	int first_index;
+
+	page_size = I2S_PAGE_SIZE;
+	if(STREAM_PLAYBACK == dir){
+		pi2s_config->mmap_index = 0;
+	}
+	else{
+		pi2s_config->mmap_index = MAX_I2S_PAGE;
+	}
+	
+	if ((pi2s_config->mmap_index == 0) || (pi2s_config->mmap_index == MAX_I2S_PAGE))
+	{
+		MSG("mmap_index=%d\n", pi2s_config->mmap_index);
+
+		first_index = pi2s_config->mmap_index;
+		pi2s_config->pMMAPBufPtr[pi2s_config->mmap_index] = kmalloc(size, GFP_DMA);
+		i2s_mmap_addr[pi2s_config->mmap_index] = (dma_addr_t)dma_map_single(NULL, pi2s_config->pMMAPBufPtr[pi2s_config->mmap_index], size, DMA_BIDIRECTIONAL);
+	
+		if( pi2s_config->pMMAPBufPtr[pi2s_config->mmap_index] == NULL ) 
+		{
+			MSG("i2s_mmap failed\n");
+			return -1;
+		}
+	}
+	else
+	{
+		_printk("illegal index:%d\n", pi2s_config->mmap_index);
+		return -1;	
+	}
+	
+	MSG("MMAP[%d]=0x%08X, i2s_mmap_addr[%d]=0x%08x\n",
+		pi2s_config->mmap_index, (u32)pi2s_config->pMMAPBufPtr[pi2s_config->mmap_index], 
+                pi2s_config->mmap_index, i2s_mmap_addr[pi2s_config->mmap_index]);
+	
+	memset(pi2s_config->pMMAPBufPtr[pi2s_config->mmap_index], 0, size);
+	pi2s_config->mmap_index++;
+
+	for (i=1; i<MAX_I2S_PAGE; i++)
+	{
+		i2s_mmap_addr[pi2s_config->mmap_index] = i2s_mmap_addr[first_index] + i*page_size;
+		pi2s_config->pMMAPBufPtr[pi2s_config->mmap_index] = pi2s_config->pMMAPBufPtr[first_index] + i*page_size;
+
+		MSG("MMAP[%d]=0x%08X, i2s_mmap_addr[%d]=0x%08x\n",pi2s_config->mmap_index, (u32)pi2s_config->pMMAPBufPtr[pi2s_config->mmap_index], pi2s_config->mmap_index, i2s_mmap_addr[pi2s_config->mmap_index]);
+	
+		/* Notice: The last mmap_index's value should be MAX_I2S_PAGE or MAX_I2S_PAGE*2 */
+		pi2s_config->mmap_index++;
+	}
+
+	return 0;
+}
+
+int i2s_mmap_remap(struct vm_area_struct *vma, unsigned long size)
+{
+	int nRet;
+	if((pi2s_config->pMMAPBufPtr[0]!=NULL) && (pi2s_config->mmap_index == MAX_I2S_PAGE))
+	{
+		MSG("i2s_mmap_remap:0\n");
+		//move left 12bit, why?
+		nRet = remap_pfn_range(vma, vma->vm_start, virt_to_phys((void *)pi2s_config->pMMAPBufPtr[0]) >> PAGE_SHIFT,  size, vma->vm_page_prot);
+
+		if( nRet != 0 )
+		{
+			_printk("i2s_mmap->remap_pfn_range failed\n");
+			return -EIO;
+		}
+	}
+
+	if((pi2s_config->pMMAPBufPtr[MAX_I2S_PAGE]!=NULL) && (pi2s_config->mmap_index == MAX_I2S_PAGE*2))
+	{
+		MSG("i2s_mmap_remap:%d\n", MAX_I2S_PAGE);
+
+		nRet = remap_pfn_range(vma, vma->vm_start, virt_to_phys((void *)pi2s_config->pMMAPBufPtr[MAX_I2S_PAGE]) >> PAGE_SHIFT,  size, vma->vm_page_prot);
+	
+		if( nRet != 0 )
+		{
+			_printk("i2s_mmap->remap_pfn_range failed\n");
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+static int i2s_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	unsigned long size = vma->vm_end-vma->vm_start;
+	_printk("page_size=%d, ksize=%lu\n", I2S_PAGE_SIZE, size);
+
+	if((pi2s_config->pMMAPBufPtr[0]==NULL)&&(pi2s_config->mmap_index!=0))
+		{
+			MSG(">>>>>>pi2s_config->mmap_index = 0\n");
+			pi2s_config->mmap_index = 0;
+		}
+	_printk("%s: vm_start=%08X,vm_end=%08X\n", __func__, (u32)vma->vm_start, (u32)vma->vm_end);
+		
+	/* Do memory allocate and dma sync */
+	i2s_mmap_alloc(size,STREAM_PLAYBACK);
+
+	i2s_mmap_remap(vma, size);
+
+
+	return 0;
+}
+
+int i2s_mem_unmap(i2s_config_type* ptri2s_config,int dir)
+{
+	u32 page_size;
+
+	page_size = I2S_PAGE_SIZE;
+	if(STREAM_PLAYBACK == dir){
+		if(ptri2s_config->pMMAPBufPtr[0]){
+			printk("ummap MMAP[0]=0x%08X\n", (u32)ptri2s_config->pMMAPBufPtr[0]);
+			dma_unmap_single(NULL, i2s_mmap_addr[0], MAX_I2S_PAGE*page_size, DMA_BIDIRECTIONAL);
+			kfree(ptri2s_config->pMMAPBufPtr[0]);
+			ptri2s_config->pMMAPBufPtr[0] = NULL;
+		}
+	}
+	else{
+		if(ptri2s_config->pMMAPBufPtr[MAX_I2S_PAGE]){
+			printk("ummap MMAP[%d]=0x%08X\n", MAX_I2S_PAGE, (u32)ptri2s_config->pMMAPBufPtr[MAX_I2S_PAGE]);
+			dma_unmap_single(NULL, i2s_mmap_addr[MAX_I2S_PAGE], MAX_I2S_PAGE*page_size, DMA_BIDIRECTIONAL);
+			kfree(ptri2s_config->pMMAPBufPtr[MAX_I2S_PAGE]);
+			ptri2s_config->pMMAPBufPtr[MAX_I2S_PAGE] = NULL;
+		}
+	}
+#if 0
+	if(ptri2s_config->pMMAPBufPtr[0]&& (ptri2s_config->mmap_index != 0))
+	{	
+		printk("ummap MMAP[0]=0x%08X\n", (u32)ptri2s_config->pMMAPBufPtr[0]);
+		dma_unmap_single(NULL, i2s_mmap_addr[0], MAX_I2S_PAGE*page_size, DMA_BIDIRECTIONAL);
+		kfree(ptri2s_config->pMMAPBufPtr[0]);
+	}
+
+	if(ptri2s_config->pMMAPBufPtr[MAX_I2S_PAGE]&& (ptri2s_config->mmap_index != 0))
+	{
+		printk("ummap MMAP[%d]=0x%08X\n", MAX_I2S_PAGE, (u32)ptri2s_config->pMMAPBufPtr[MAX_I2S_PAGE]);
+		dma_unmap_single(NULL, i2s_mmap_addr[MAX_I2S_PAGE], MAX_I2S_PAGE*page_size, DMA_BIDIRECTIONAL);
+		kfree(ptri2s_config->pMMAPBufPtr[MAX_I2S_PAGE]);
+	}
+
+	ptri2s_config->mmap_index = 0;
+#endif	
+	return 0;
+}
+
+int i2s_param_init(i2s_config_type* ptri2s_config)
+{
+	ptri2s_config->dmach = GDMA_I2S_TX0;
+	ptri2s_config->tx_ff_thres = CONFIG_I2S_TFF_THRES;
+	ptri2s_config->tx_ch_swap = CONFIG_I2S_CH_SWAP;
+	ptri2s_config->rx_ff_thres = CONFIG_I2S_TFF_THRES;
+	ptri2s_config->rx_ch_swap = CONFIG_I2S_CH_SWAP;
+	ptri2s_config->slave_en = CONFIG_I2S_SLAVE_EN; 
+	ptri2s_config->codec_pll_en = CONFIG_I2S_CODEC_PLL_EN;
+
+	ptri2s_config->bRxDMAEnable = 0;
+	ptri2s_config->bTxDMAEnable = 0;
+	//ptri2s_config->bALSAEnable = 0;
+	ptri2s_config->srate = 44100;
+	ptri2s_config->txvol = 0;
+	ptri2s_config->rxvol = 0;
+	ptri2s_config->lbk = 0;
+	ptri2s_config->extlbk = 0;
+	ptri2s_config->txrx_coexist = 0;
+	ptri2s_config->wordlen_24b = 0;
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+	ptri2s_config->sys_endian = 0;
+	ptri2s_config->fmt = 0;
+#endif
+	ptri2s_config->micboost = 0;
+	ptri2s_config->micin = 0;
+
+	ptri2s_config->is_rx_mmap = 0;
+	ptri2s_config->is_tx_mmap = 0;
+
+	return 0;
+}
+
+int i2s_txbuf_alloc(i2s_config_type* ptri2s_config)
+{
+	int i;
+
+	for( i = 0 ; i < MAX_I2S_PAGE ; i ++ )
+        {
+			if(ptri2s_config->is_tx_mmap)
+				ptri2s_config->pMMAPTxBufPtr[i] = ptri2s_config->pMMAPBufPtr[i];
+			else{
+                if(ptri2s_config->pMMAPTxBufPtr[i]==NULL)
+                	ptri2s_config->pMMAPTxBufPtr[i] = kmalloc(I2S_PAGE_SIZE, GFP_KERNEL);
+			}
+		memset(ptri2s_config->pMMAPTxBufPtr[i], 0, I2S_PAGE_SIZE);
+	}
+
+	return 0;
+}
+
+int i2s_rxbuf_alloc(i2s_config_type* ptri2s_config)
+{
+	int i;
+
+	for( i = 0 ; i < MAX_I2S_PAGE ; i ++ )
+        {
+			if(ptri2s_config->is_rx_mmap)
+				ptri2s_config->pMMAPRxBufPtr[i] = ptri2s_config->pMMAPBufPtr[i+MAX_I2S_PAGE];
+			else{
+				if(ptri2s_config->pMMAPRxBufPtr[i]==NULL)
+					ptri2s_config->pMMAPRxBufPtr[i] = kmalloc(I2S_PAGE_SIZE, GFP_KERNEL);
+			}
+		memset(ptri2s_config->pMMAPRxBufPtr[i], 0, I2S_PAGE_SIZE);
+        }
+
+	return 0;
+}
+
+int i2s_txPagebuf_alloc(i2s_config_type* ptri2s_config)
+{
+#if defined(ARM_ARCH)
+	ptri2s_config->pPage0TxBuf8ptr = (u8*)pci_alloc_consistent(NULL, I2S_PAGE_SIZE , &i2s_txdma_addr0);
+	ptri2s_config->pPage1TxBuf8ptr = (u8*)pci_alloc_consistent(NULL, I2S_PAGE_SIZE , &i2s_txdma_addr1);
+	if(ptri2s_config->pPage0TxBuf8ptr==NULL)
+        {
+		MSG("Allocate Tx Page0 Buffer Failed\n");
+                return -1;
+        }
+	if(ptri2s_config->pPage1TxBuf8ptr==NULL)
+        {
+		MSG("Allocate Tx Page1 Buffer Failed\n");
+                return -1;
+        }
+#else
+	ptri2s_config->pPage0TxBuf8ptr = (u8*)pci_alloc_consistent(NULL, I2S_PAGE_SIZE*2 , &i2s_txdma_addr);
+        if(ptri2s_config->pPage0TxBuf8ptr==NULL)
+        {
+		MSG("Allocate Tx Page Buffer Failed\n");
+                return -1;
+        }
+        ptri2s_config->pPage1TxBuf8ptr = ptri2s_config->pPage0TxBuf8ptr + I2S_PAGE_SIZE;
+#endif
+	return 0;
+}
+
+int i2s_rxPagebuf_alloc(i2s_config_type* ptri2s_config)
+{
+#if defined(ARM_ARCH)
+	ptri2s_config->pPage0RxBuf8ptr = (u8*)pci_alloc_consistent(NULL, I2S_PAGE_SIZE, &i2s_rxdma_addr0);
+	ptri2s_config->pPage1RxBuf8ptr = (u8*)pci_alloc_consistent(NULL, I2S_PAGE_SIZE, &i2s_rxdma_addr1);
+	if(ptri2s_config->pPage0RxBuf8ptr==NULL)
+	{
+		MSG("Allocate Rx Page Buffer Failed\n");
+		return -1;
+	}
+	if(ptri2s_config->pPage1RxBuf8ptr==NULL)
+	{
+		MSG("Allocate Rx Page Buffer Failed\n");
+		return -1;
+	}
+#else
+	ptri2s_config->pPage0RxBuf8ptr = (u8*)pci_alloc_consistent(NULL, I2S_PAGE_SIZE*2 , &i2s_rxdma_addr);
+	if(ptri2s_config->pPage0RxBuf8ptr==NULL)
+	{
+		MSG("Allocate Rx Page Buffer Failed\n");
+		return -1;
+	}
+	ptri2s_config->pPage1RxBuf8ptr = ptri2s_config->pPage0RxBuf8ptr + I2S_PAGE_SIZE;
+#endif
+	return 0;
+}
+
+int i2s_txbuf_free(i2s_config_type* ptri2s_config)
+{
+	int i;
+
+	for(i = 0 ; i < MAX_I2S_PAGE ; i ++) 
+	{
+		if(ptri2s_config->pMMAPTxBufPtr[i] != NULL)
+		{
+			if(ptri2s_config->is_tx_mmap)
+				ptri2s_config->pMMAPTxBufPtr[i] = NULL;
+			else{
+				kfree(ptri2s_config->pMMAPTxBufPtr[i]);
+				ptri2s_config->pMMAPTxBufPtr[i] = NULL;
+			}
+		}
+	}
+	return 0;
+}
+
+int i2s_rxbuf_free(i2s_config_type* ptri2s_config)
+{
+	int i;
+
+	for(i = 0 ; i < MAX_I2S_PAGE ; i ++) 
+	{
+		if(ptri2s_config->pMMAPRxBufPtr[i] != NULL)
+		{
+			if(ptri2s_config->is_rx_mmap)
+				ptri2s_config->pMMAPRxBufPtr[i] = NULL;
+			else{
+				kfree(ptri2s_config->pMMAPRxBufPtr[i]);
+				ptri2s_config->pMMAPRxBufPtr[i] = NULL;
+			}
+		}
+	}
+	
+	return 0;
+}
+
+int i2s_txPagebuf_free(i2s_config_type* ptri2s_config)
+{
+#if defined(ARM_ARCH)
+	if (ptri2s_config->pPage0TxBuf8ptr)
+	{
+		pci_free_consistent(NULL, I2S_PAGE_SIZE, ptri2s_config->pPage0TxBuf8ptr, i2s_txdma_addr0);
+		ptri2s_config->pPage0TxBuf8ptr = NULL;
+	}
+
+	if (ptri2s_config->pPage1TxBuf8ptr)
+	{
+		pci_free_consistent(NULL, I2S_PAGE_SIZE, ptri2s_config->pPage1TxBuf8ptr, i2s_txdma_addr1);
+		ptri2s_config->pPage1TxBuf8ptr = NULL;
+	}
+	_printk("Free tx page buffer\n");
+#else
+	if (ptri2s_config->pPage0TxBuf8ptr)
+	{
+		pci_free_consistent(NULL, I2S_PAGE_SIZE*2, ptri2s_config->pPage0TxBuf8ptr, i2s_txdma_addr);
+		ptri2s_config->pPage0TxBuf8ptr = NULL;
+	}
+#endif
+	return 0;
+
+}
+
+int i2s_rxPagebuf_free(i2s_config_type* ptri2s_config)
+{
+#if defined(ARM_ARCH)
+	if (ptri2s_config->pPage0RxBuf8ptr)
+	{
+		pci_free_consistent(NULL, I2S_PAGE_SIZE, ptri2s_config->pPage0RxBuf8ptr, i2s_rxdma_addr0);
+		ptri2s_config->pPage0RxBuf8ptr = NULL;
+	}
+	if (ptri2s_config->pPage1RxBuf8ptr)
+	{
+		pci_free_consistent(NULL, I2S_PAGE_SIZE, ptri2s_config->pPage1RxBuf8ptr, i2s_rxdma_addr1);
+		ptri2s_config->pPage1RxBuf8ptr = NULL;
+	}
+	_printk("Free rx page buffer\n");
+#else
+	if (ptri2s_config->pPage0RxBuf8ptr)
+	{
+		pci_free_consistent(NULL, I2S_PAGE_SIZE*2, ptri2s_config->pPage0RxBuf8ptr, i2s_rxdma_addr);
+		ptri2s_config->pPage0RxBuf8ptr = NULL;
+	}
+#endif
+	return 0;
+}
+
+int i2s_reset_tx_param(i2s_config_type* ptri2s_config)
+{
+	ptri2s_config->tx_isr_cnt = 0;
+	ptri2s_config->tx_w_idx = 0;
+	ptri2s_config->tx_r_idx = 0;	
+	ptri2s_config->enLable = 0;
+	ptri2s_config->tx_pause_en = 0;
+	ptri2s_config->end_cnt = 0;
+	ptri2s_config->tx_stop_cnt = 0;
+
+#ifdef I2S_STATISTIC
+	pi2s_status->txbuffer_unrun = 0;
+	pi2s_status->txbuffer_ovrun = 0;
+	pi2s_status->txdmafault = 0;
+	pi2s_status->txovrun = 0;
+	pi2s_status->txunrun = 0;
+	pi2s_status->txthres = 0;
+	pi2s_status->txbuffer_len = 0;
+#endif
+
+	return 0;
+}
+
+int i2s_reset_rx_param(i2s_config_type* ptri2s_config)
+{
+	ptri2s_config->rx_isr_cnt = 0;
+	ptri2s_config->rx_w_idx = 0;
+	ptri2s_config->rx_r_idx = 0;	
+	ptri2s_config->enLable = 0;
+	ptri2s_config->rx_pause_en = 0;
+	ptri2s_config->rx_stop_cnt = 0;
+
+#ifdef I2S_STATISTIC
+	pi2s_status->rxbuffer_unrun = 0;
+	pi2s_status->rxbuffer_ovrun = 0;
+	pi2s_status->rxdmafault = 0;
+	pi2s_status->rxovrun = 0;
+	pi2s_status->rxunrun = 0;
+	pi2s_status->rxthres = 0;
+	pi2s_status->rxbuffer_len = 0;
+#endif
+
+	return 0;
+}	
+#ifdef MT7621_ASIC_BOARD
+int i2s_pll_config_mt7621(unsigned long index)
+{
+        unsigned long data;
+	unsigned long regValue;
+	bool xtal_20M_en = 0;
+//	bool xtal_25M_en = 0;
+	bool xtal_40M_en = 0;
+
+	regValue = i2s_inw(RALINK_SYSCTL_BASE + 0x10);
+       	regValue = (regValue >> 6) & 0x7;
+	if (regValue < 3)
+	{
+		xtal_20M_en = 1;
+		MSG("Xtal is 20MHz. \n");
+	}
+	else if (regValue < 6)
+	{
+		xtal_40M_en = 1;
+		MSG("Xtal is 40M.\n");
+	}
+	else
+	{
+		//xtal_25M_en = 1;
+		MSG("Xtal is 25M.\n");
+	}
+
+#if defined (CONFIG_I2S_MCLK_12P288MHZ)
+	_printk("MT7621 provide 12.288M/11.298MHz REFCLK\n");	
+	/* Firstly, reset all required register to default value */
+	i2s_outw(RALINK_ANA_CTRL_BASE, 0x00008000);
+	i2s_outw(RALINK_ANA_CTRL_BASE+0x0014, 0x01001d61);//0x01401d61);
+	i2s_outw(RALINK_ANA_CTRL_BASE+0x0018, 0x38233d0e);
+	i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, 0x80100004);//0x80120004);
+	i2s_outw(RALINK_ANA_CTRL_BASE+0x0020, 0x1c7dbf48);
+
+        /* toggle RG_XPTL_CHG */
+        i2s_outw(RALINK_ANA_CTRL_BASE, 0x00008800);
+        i2s_outw(RALINK_ANA_CTRL_BASE, 0x00008c00);
+
+        data = i2s_inw(RALINK_ANA_CTRL_BASE+0x0014);
+        data &= ~(0x0000ffc0);
+	if ((xtal_40M_en) || (xtal_20M_en))
+	{
+        	data |= REGBIT(0x1d, 8); /* for 40M or 20M */
+	}
+	else 
+	{
+        	data |= REGBIT(0x17, 8); /* for 25M */
+	}
+	
+	if (xtal_40M_en)
+	{
+        	data |= REGBIT(0x1, 6);  /* for 40M */
+	}
+	i2s_outw(RALINK_ANA_CTRL_BASE+0x0014, data);
+
+
+        data = i2s_inw(RALINK_ANA_CTRL_BASE+0x0018);
+        data &= ~(0xf0773f00);
+        data |= REGBIT(0x3, 28);
+        data |= REGBIT(0x2, 20);
+	if ((xtal_40M_en) || (xtal_20M_en))
+	{
+        	data |= REGBIT(0x3, 16); /* for 40M or 20M */
+	}
+	else
+	{
+        	data |= REGBIT(0x2, 16); /* for 25M */
+	}
+        data |= REGBIT(0x3, 12);
+	if ((xtal_40M_en) || (xtal_20M_en))
+	{
+        	data |= REGBIT(0xd, 8);	/* for 40M or 20M */
+	}
+	else
+	{
+        	data |= REGBIT(0x7, 8);	/* for 25M */
+	}
+        i2s_outw(RALINK_ANA_CTRL_BASE+0x0018, data);
+
+        if((index==1)|(index==4)|(index==7)|(index==9))// 270 MHz for 22.05K, 44.1K, 88.2K, 176.4K
+        {
+		if ((xtal_40M_en) || (xtal_20M_en))
+		{
+         	       	i2s_outw(RALINK_ANA_CTRL_BASE+0x0020, 0x1a18548a); /* for 40M or 20M */
+		}
+		else
+		{
+                	i2s_outw(RALINK_ANA_CTRL_BASE+0x0020, 0x14ad106e); /* for 25M */
+		}
+        }
+        else if ((index==0)|(index==3)|(index==5)|(index==6)|(index==8)|(index==10))// 294 MHZ for 24K, 48K, 96K, 192K
+        {
+		if ((xtal_40M_en) || (xtal_20M_en))
+		{
+                	i2s_outw(RALINK_ANA_CTRL_BASE+0x0020, 0x1c7dbf48); /* for 40M or 20M */
+		}
+		else
+		{
+                	i2s_outw(RALINK_ANA_CTRL_BASE+0x0020, 0x1697cc39); /* for 25M */
+		}
+        }
+	else if (index==2)
+	{
+		_printk("Not support 12KHz sampling rate!\n");
+		return -1;
+	}
+        else
+        {
+                _printk("Wrong sampling rate!\n");
+                return -1;
+        }
+
+        //*Common setting - Set PLLGP_CTRL_4 *//
+	/* 1. Bit 31 */
+        data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        data &= ~(REGBIT(0x1, 31));
+        i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+	ndelay(10);
+
+        /* 2. Bit 0 */
+        data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        data |= REGBIT(0x1, 0);
+        i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+	udelay(200);
+
+        /* 3. Bit 3 */
+        data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        data |= REGBIT(0x1, 3);
+        i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+	udelay(1);
+
+        /* 4. Bit 8 */
+        data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        data |= REGBIT(0x1, 8);
+        i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+	ndelay(40);
+
+        /* 5. Bit 6 */
+        data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        data |= REGBIT(0x1, 6);
+        i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+	ndelay(40);
+
+        /* 6. Bit 5 & Bit 7*/
+        data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        data |= REGBIT(0x1, 5);
+	data |= REGBIT(0x1, 7);
+        i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+	udelay(1);
+
+        /* 7. Bit 17 */
+        data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        data |= REGBIT(0x1, 17);
+        i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+
+#elif defined(CONFIG_I2S_MCLK_12MHZ)
+	_printk("MT7621 provide 12MHz REFCLK\n");
+	/* Firstly, reset all required register to default value */
+	i2s_outw(RALINK_ANA_CTRL_BASE+0x0014, 0x01401d61);//0x01401d61);
+	i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, 0x80120004);//0x80100004);
+	i2s_outw(RALINK_ANA_CTRL_BASE+0x0018, 0x38233d0e);
+
+	if (xtal_40M_en)
+	{
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        	data &= ~REGBIT(0x1, 17);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x0014);
+		data &= ~REGBIT(0x3, 4);
+        	data |= REGBIT(0x1, 4);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x0014, data);
+
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        	data &= ~REGBIT(0x1, 31);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+	}
+	else if (xtal_20M_en)
+	{
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        	data &= ~REGBIT(0x1, 17);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x0014);
+		data &= ~REGBIT(0x3, 6);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x0014, data);
+
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x0014);
+		data &= ~REGBIT(0x3, 4);
+        	data |= REGBIT(0x1, 4);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x0014, data);
+
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        	data &= ~REGBIT(0x1, 31);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+	}
+	else
+	{
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        	data &= ~REGBIT(0x1, 17);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x0014);
+		data &= ~REGBIT(0x7f, 8);
+        	data |= REGBIT(0x17, 8);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x0014, data);
+
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x0014);
+		data &= ~REGBIT(0x3, 6);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x0014, data);
+
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x0018);
+		data &= ~REGBIT(0x7, 16);
+        	data |= REGBIT(0x2, 16);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x0018, data);
+
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x0018);
+		data &= ~REGBIT(0xf, 8);
+        	data |= REGBIT(0x7, 8);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x0018, data);
+
+
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x0014);
+		data &= ~REGBIT(0x3, 4);
+        	data |= REGBIT(0x1, 4);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x0014, data);
+
+		data = i2s_inw(RALINK_ANA_CTRL_BASE+0x001c);
+        	data &= ~REGBIT(0x1, 31);
+        	i2s_outw(RALINK_ANA_CTRL_BASE+0x001c, data);
+
+	}
+#endif
+        return 0;
+}
+#if defined(CONFIG_I2S_IN_MCLK)
+int i2s_pll_refclk_set(void)
+{
+	unsigned long data;
+
+	/* Set APLL register for REFCLK */
+        data = i2s_inw(RALINK_SYSCTL_BASE+0x90);
+        data &= ~(0x0000f000);
+        data |= REGBIT(0x1, 12);
+        i2s_outw(RALINK_SYSCTL_BASE+0x0090, data);
+
+        data = i2s_inw(RALINK_SYSCTL_BASE+0x0090);
+        data &= ~(0x00000300);
+        i2s_outw(RALINK_SYSCTL_BASE+0x0090, data);
+        MSG("Set 0x90 register\n");
+
+	return 0;
+}
+#endif
+#endif	
+
+#ifdef MT7623_ASIC_BOARD
+int i2s_pll_config_mt7623(unsigned long index)
+{
+	unsigned long data;
+
+	/* xPLL PWR ON */
+	data = i2s_inw(AUD2PLL_PWR_CON0);
+	data |= 0x1;
+	i2s_outw(AUD2PLL_PWR_CON0, data);
+	udelay(5);
+
+	/* xPLL ISO Disable */
+	data = i2s_inw(AUD2PLL_PWR_CON0);
+	data &= ~(0x2);
+	i2s_outw(AUD2PLL_PWR_CON0, data);
+
+	/* xPLL Frequency Set */
+	data = i2s_inw(AUD2PLL_CON0);
+	data |= 0x1;
+	i2s_outw(AUD2PLL_CON0, data);
+
+	/* AUD1PLL Frequency Set(change from 98.304MHz to 294.912MHz) */
+	i2s_outw(AUD1PLL_CON0, 0x121);
+	i2s_outw(AUD1PLL_CON1, 0xad5efee6);
+	udelay(40);
+
+	/* Audio clock setting */
+	if((index==1)|(index==4)|(index==7)|(index==9)|(index==11))// for 22.05K, 44.1K, 88.2K, 176.4K
+	{
+		_printk("\n*****%s:index=%d(270MHz)*****\n", __func__, (int)index);
+		data = i2s_inw(0xFB00002c);
+		//data &= ~REGBIT(0x8, 1);
+		data &= ~(0x80);
+		i2s_outw(0xFB00002C, data); /* AUD1PLL 270.9204MHz */
+	}	
+	else if ((index==0)|(index==3)|(index==5)|(index==6)|(index==8)|(index==10)|(index==12)) //for 24K, 48K, 96K, 192K
+	{
+		_printk("\n*****%s:index=%d(294MHz)*****\n", __func__, (int)index);
+		data = i2s_inw(0xFB00002c);
+		//data |= REGBIT(0x8, 1);
+        	data |= (0x80);
+		i2s_outw(0xFB00002c, data); /* AUD1PLL 294.912MHz */
+	}
+	else if (index==2)
+	{
+		_printk("Not support 12KHz sampling rate!\n");
+		return -1;
+	}
+        else
+        {
+                _printk("Wrong sampling rate!\n");
+                return -1;
+        }
+	return 0;
+}
+#endif
+
+#if defined(MT7628_ASIC_BOARD) || defined(CONFIG_ARCH_MT7623)
+int i2s_driving_strength_adjust(void)
+{
+#if defined(MT7628_ASIC_BOARD)
+        unsigned long data;
+
+        MSG("Adjust MT7628 current's driving strngth\n");
+        /* Adjust REFCLK0's driving strength of current which can avoid
+         * the glitch of REFCKL0
+         * E4 = 0xb0001354[5]; E8 = 0xb0001364[5]
+         * (E4,E8)=(0,0)-> 4 mA;
+         *        =(1,0)-> 8 mA;
+         *        =(0,1)-> 12 mA;
+         *        =(1,1)-> 16 mA*/
+
+        /* Set to 12mA */
+        data = i2s_inw(0xb0001354);
+        data &= ~(0x1<<5);
+        i2s_outw(0xb0001354, data);
+
+        data = i2s_inw(0xb0001364);
+        data |= (0x1<<5);
+        i2s_outw(0xb0001364, data);
+#endif
+#if defined(CONFIG_ARCH_MT7623)
+	MSG("Adjust MT7623 current's driving strngth\n");
+
+	i2s_outw(0xF0005F80, 0x7777);
+#endif
+
+        return 0;
+}
+#endif
+
+#if defined(CONFIG_I2S_IN_MCLK)
+#if defined(CONFIG_I2S_MCLK_12MHZ)
+int i2s_refclk_12m_enable(void)
+{
+	unsigned long data;
+	
+	MSG("Enable SoC MCLK 12Mhz\n");
+
+#if defined(CONFIG_RALINK_RT6855A)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x860);
+	data |= (0x1<<17);
+	data &= ~(0x7<<18);
+	data |= (0x1<<18);
+	i2s_outw(RALINK_SYSCTL_BASE+0x860, data);
+#elif defined(CONFIG_RALINK_RT3350)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+	data |= (0x1<<8);
+	i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);
+#elif defined(CONFIG_RALINK_RT3883)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+	data &= ~(0x03<<13);
+	data |= (0x1<<13);	
+	i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);
+#elif defined(CONFIG_RALINK_RT3352)||defined(CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) 
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+	data &= ~(0x0F<<8);
+	data |= (0x3<<8);	
+	i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);
+#elif defined(CONFIG_RALINK_MT7620)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+	data &= ~(0x07<<9);
+    	data |= (1<<9);
+	i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);
+#elif defined(CONFIG_RALINK_MT7621)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+	data &= ~(0x1f<<18);
+	data |= REGBIT(0x19, 18);
+	data &= ~(0x1f<<12);
+	data |= REGBIT(0x1, 12);
+	data &= ~(0x7<<9);
+	data |= REGBIT(0x5, 9);
+	i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);
+#elif defined(CONFIG_RALINK_MT7628)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+	MSG("turn on REFCLK output for MCLK1\n");
+	data &= ~(0x7<<9);
+	data |= (0x1<<9);  /* output for MCLK */
+	i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);
+#else	
+	#error "This SoC does not provide 12MHz clock to audio codec\n");	
+#endif
+	i2s_refclk_gpio_out_config();
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_I2S_MCLK_12P288MHZ)
+int i2s_refclk_12p288m_enable(void)
+{
+	unsigned long data;
+	MSG("Enable SoC MCLK 12.288Mhz\n");
+
+#if defined(CONFIG_RALINK_RT3352)||defined(CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+	data &= ~(0x01F<<18);
+	data |= 31<<18;
+	data &= ~(0x01F<<12);
+	data |= 1<<12;
+	data |= (0xF<<8);
+	i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);
+#elif defined(CONFIG_RALINK_MT7621)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+	data &= ~(0x1f<<18);
+	data |= REGBIT(0xc, 18);
+	data &= ~(0x1f<<12);
+	data |= REGBIT(0x1, 12);
+	data &= ~(0x7<<9);
+	data |= REGBIT(0x5, 9);
+	i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);
+	_printk("MT7621 provide REFCLK 12.288MHz/11.289MHz\n");
+#elif defined(CONFIG_ARCH_MT7623)
+	/* MT7623 does not need to set divider for REFCLK */
+	/* GPIO126 - I2S0_MCLK */
+	data = i2s_inw(0xF00058F0);
+	data &= ~(0x7<<3);
+	data |= (0x6<<3);
+	i2s_outw(0xF00058F0, data);	
+	/* GPIO_DIR8: OUT */
+	data = i2s_inw(0xF0005070);
+	data |= (0x1<<14);
+	i2s_outw(0xF0005070, data);
+#else
+	#error "This SoC does not provide 12.288Mhz clock to audio codec\n");	
+#endif
+	
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_I2S_MCLK_18P432MHZ)
+int i2s_refclk_18p432m_enable(unsigned long index)
+{
+	unsigned long data;
+	MSG("Enable SoC MCLK 18.432MHz/16.934MHz");
+
+	if((index==1)|(index==4)|(index==7)|(index==9))// 16.934MHz for 22.05K, 44.1K, 88.2K, 176.4K
+        {
+		data = i2s_inw(ETHDMASYS_SYSCTL_BASE+0x2c);
+		data &= ~(0x1<<7);
+		i2s_outw(ETHDMASYS_SYSCTL_BASE+0x2c, data);
+	}
+	else if((index==0)|(index==3)|(index==5)|(index==6)|(index==8)|(index==10))// 18.432MHZ for 24K, 48K, 96K, 192K
+        {
+		data = i2s_inw(ETHDMASYS_SYSCTL_BASE+0x2c);
+		data |= (0x1<<7);
+		i2s_outw(ETHDMASYS_SYSCTL_BASE+0x2c, data);
+	}
+
+	data = i2s_inw(ETHDMASYS_SYSCTL_BASE+0x30);
+	data |= (0x1<<17);
+	i2s_outw(ETHDMASYS_SYSCTL_BASE+0x30, data);
+
+	return 0;
+}
+#endif
+#endif
+
+int i2s_refclk_disable(void)
+{
+	unsigned long data;
+
+#if defined(CONFIG_RALINK_RT6855A)
+    	data = i2s_inw(RALINK_SYSCTL_BASE+0x860);
+	data &= ~(1<<17);
+	i2s_outw(RALINK_SYSCTL_BASE+0x860, data);
+#elif defined(CONFIG_RALINK_RT3350)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+	data &= ~(0x1<<8);
+	i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);
+#elif defined(CONFIG_RALINK_RT3883)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+	 data &= ~(0x0F<<13);	
+	i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);	
+#elif defined(CONFIG_RALINK_RT3352)||defined(CONFIG_RALINK_RT5350)||defined (CONFIG_RALINK_RT6855)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+	data &= ~(0x0F<<8);
+	i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);
+#elif defined (CONFIG_RALINK_MT7620)||defined (CONFIG_RALINK_MT7621)||defined (CONFIG_RALINK_MT7628) 
+	_printk("turn off REFCLK output from internal CLK\n");
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+	data &= ~(0x07<<9);
+	i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);
+#elif defined (CONFIG_ARCH_MT7623) /*FIXME:2*/
+#ifdef MT7623_ASIC_BOARD
+	_printk("turn off REFCLK output from internal CLK\n");
+	/* GPIO126 - I2S0_MCLK */
+        data = i2s_inw(0xF00058F0);
+        data &= ~(0x7<<3);
+	//data |= (0x2<<3);
+        i2s_outw(0xF00058F0, data);
+	/* GPIO126 => GPIO_DIR8: IN */
+	data = i2s_inw(0xF0005070);
+	data &= ~(0x1<<14);
+	i2s_outw(0xF0005070, data);
+#else
+	_printk("turn off REFCLK output from internal CLK\n");
+	data = i2s_inw(ETHDMASYS_SYSCTL_BASE+0x30);
+	data &= ~(0x1<<17);
+	i2s_outw(ETHDMASYS_SYSCTL_BASE+0x30, data);
+#endif
+#endif
+	return 0;
+}
+
+int i2s_refclk_gpio_out_config(void)
+{
+#ifndef CONFIG_ARCH_MT7623
+	unsigned long data; /* FIXME */
+#endif
+	
+	/* Set REFCLK GPIO pin as REFCLK mode*/
+#if defined(CONFIG_RALINK_MT7620)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x60);
+    	data &= ~(0x03<<21);  /* WDT */
+    	data |= (1<<21);
+	//data &= ~(0x03<<16);  /* PERST */
+	//data |= (1<<16);
+    	i2s_outw(RALINK_SYSCTL_BASE+0x60, data);
+#endif
+#if defined(CONFIG_RALINK_MT7621)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x60);
+	//data &= ~(0x3<<10); /* PERST */
+	//data |= (0x2<<10);
+	data &= ~(0x3<<8); /* WDT */
+	data |= (0x2<<8);
+	i2s_outw(RALINK_SYSCTL_BASE+0x60, data);
+	MSG("Set 0x60 register\n");
+#endif
+#if defined(CONFIG_RALINK_MT7628)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x60);
+	data &= ~(0x1<<18);
+	i2s_outw(RALINK_SYSCTL_BASE+0x60, data);
+#endif
+
+	return 0;
+} 
+
+int i2s_refclk_gpio_in_config(void)
+{
+#ifndef CONFIG_ARCH_MT7623
+	unsigned long data; /* FIXME */
+#endif
+
+#if defined (CONFIG_RALINK_MT7620)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x60);
+    	data &= ~(0x03<<21);  /* WDT */
+    	data |= (1<<21);
+	//data &= ~(0x03<<16);  /* PERST */
+	//data |= (1<<16);
+    	i2s_outw(RALINK_SYSCTL_BASE+0x60, data);
+
+	data = i2s_inw(RALINK_PIO_BASE);
+	data &= ~(0x1<<17); /* GPIO share ping 17 for WDT */
+	i2s_outw(RALINK_PIO_BASE, data);
+
+	//data = i2s_inw(RALINK_PIO_BASE+0x04);
+	//data &= ~(0x1<<4); /* GPIO share ping 36 for PERST */
+	//i2s_outw(RALINK_PIO_BASE+0x04, data);
+#endif
+#if defined (CONFIG_RALINK_MT7621)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x60);
+	//data &= ~(0x3<<10); /* PERST */
+	//data |= (0x1<<10);
+	data &= ~(0x3<<8); /* WDT */
+	data |= (0x1<<8);
+	i2s_outw(RALINK_SYSCTL_BASE+0x60, data);
+	
+	data = i2s_inw(RALINK_PIO_BASE);
+	//data &= ~(0x1<<19); /* GPIO share ping 19 for RERST */
+	data &= ~(0x1<<18); /* GPIO share ping 18 for WDT */
+	i2s_outw(RALINK_PIO_BASE, data);
+#endif
+#if defined (CONFIG_RALINK_MT7628)
+	/* To use external OSC, set REFCLK_GPIO ping as GPIO mode and set it as input direction */
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x60);
+	data |= (0x1<<18);
+	i2s_outw(RALINK_SYSCTL_BASE+0x60, data);
+
+	data = i2s_inw(RALINK_PIO_BASE+0x04);
+	data &= ~(0x1<<5); /* GPIO share ping 37*/
+	i2s_outw(RALINK_PIO_BASE+0x04, data);
+#endif
+
+	return 0;
+}
+
+int i2s_slave_clock_gpio_in_mt7623(void)
+{
+	unsigned long data;
+
+	/* GPIO74(I2S0_BCLK)=>GPIO_DIR5: IN */
+	data = i2s_inw(0xF0005040);
+	data &= ~(0x1<<10);
+	i2s_outw(0xF0005040, data);
+
+	/* GPIO73(I2S0_LRCK)=>GPIO_DIR5: IN */
+	data = i2s_inw(0xF0005040);
+	data &= ~(0x1<<9);
+	i2s_outw(0xF0005040, data);
+
+	_printk("i2s_slave_clock_gpio_in_mt7623\n");
+
+	return 0;
+}
+
+int i2s_master_clock_gpio_out_mt7623(void)
+{
+	unsigned long data;
+
+	/* GPIO74(I2S0_BCLK)=>GPIO_DIR5: OUT */
+	data = i2s_inw(0xF0005040);
+	data |= (0x1<<10);
+	i2s_outw(0xF0005040, data);
+
+	/* GPIO73(I2S0_LRCK)=>GPIO_DIR5: OUT */
+	data = i2s_inw(0xF0005040);
+	data |= (0x1<<9);
+	i2s_outw(0xF0005040, data);
+	
+	_printk("i2s_master_clock_gpio_out_mt7623\n");
+
+	return 0;
+}
+
+int i2s_share_pin_mt7623(i2s_config_type* ptri2s_config)
+{
+	unsigned long data;
+	
+	_printk("\nConfig MT7623 I2S pinmux\n");
+	/* GPIO74 - I2S0_BCLK */
+	data = i2s_inw(0xF0005840);
+	data &= ~(0x7<<12);
+	data |= (0x6<<12);
+	i2s_outw(0xF0005840, data);
+
+	/* GPIO73 - I2S0_LRCK */
+	data = i2s_inw(0xF0005840);
+	data &= ~(0x7<<9);
+	data |= (0x6<<9);
+	i2s_outw(0xF0005840, data);
+
+	if(ptri2s_config->slave_en==0)
+		i2s_master_clock_gpio_out_mt7623();
+	else
+		i2s_slave_clock_gpio_in_mt7623();
+
+	/* GPIO49 - I2S0_DATA */
+	data = i2s_inw(0xF00057F0);
+	data &= ~(0x7<<12);
+	data |= (0x6<<12);
+	i2s_outw(0xF00057F0, data);
+	/* GPIO_DIR4: OUT */
+	data = i2s_inw(0xF0005030);
+	data |= (0x1<<1);
+	i2s_outw(0xF0005030, data);
+
+	/* GPIO72 - I2S0_DATA_IN */
+	data = i2s_inw(0xF0005840);
+	data &= ~(0x7<<6);
+	data |= (0x6<<6);
+	i2s_outw(0xF0005840, data);
+	/* GPIO_DIR5: IN */
+	data = i2s_inw(0xF0005040);
+	data &= ~(0x1<<8);
+	i2s_outw(0xF0005040, data);
+
+	return 0;
+}
+
+int i2s_share_pin_config(i2s_config_type* ptri2s_config)
+{
+#ifndef CONFIG_ARCH_MT7623
+	unsigned long data; /*FIXME*/
+#endif
+	
+	/* set share pins to i2s/gpio mode and i2c mode */
+#if defined(CONFIG_RALINK_RT6855A)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x860);
+	data |= 0x00008080;
+	i2s_outw(RALINK_SYSCTL_BASE+0x860, data);
+#elif defined(CONFIG_RALINK_MT7621)	
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x60); 
+	data &= 0xFFFFFFE3;
+	data |= 0x00000010;
+	i2s_outw(RALINK_SYSCTL_BASE+0x60, data);
+#elif defined(CONFIG_RALINK_MT7628)	
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x60); 
+	data &= ~(0x3<<6);    /* I2S_MODE */ 
+	data &= ~(0x3<<20);   /* I2C_MODE */
+	i2s_outw(RALINK_SYSCTL_BASE+0x60, data);
+#elif defined(CONFIG_ARCH_MT7623)
+	i2s_share_pin_mt7623(ptri2s_config);
+#else	
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x60); 
+	data &= 0xFFFFFFE2;
+	data |= 0x00000018;
+	i2s_outw(RALINK_SYSCTL_BASE+0x60, data);
+#endif
+	return 0;
+}
+
+int i2s_ws_config(i2s_config_type* ptri2s_config, unsigned long index)
+{
+	unsigned long data;
+	unsigned long* pTable;
+
+#if defined(CONFIG_I2S_IN_CLK)
+	/* REFCLK is 15.625Mhz or 40Mhz(fractional division) */
+#if defined(CONFIG_I2S_FRAC_DIV)
+	MSG("Internal REFCLK with fractional division\n");
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+	if (ptri2s_config->wordlen_24b == 1)
+	{
+		MSG("24 bit int table\n");
+		pTable = i2s_inclk_int_24bit;
+	}
+	else
+	{
+		MSG("16 bit int table\n");
+		pTable = i2s_inclk_int_16bit;
+	}
+#else
+	pTable = i2s_inclk_int;
+#endif /* CONFIG_RALINK_MT7628 */
+	
+	data = (unsigned long)(pTable[index]);
+	i2s_outw(I2S_DIVINT_CFG, data);
+
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+	if (ptri2s_config->wordlen_24b == 1)
+	{
+		MSG("24 bit comp table\n");
+		pTable = i2s_inclk_comp_24bit;
+	}
+	else
+	{
+		MSG("16 bit comp table\n");
+		pTable = i2s_inclk_comp_16bit;
+	}
+#else
+	pTable = i2s_inclk_comp;
+#endif	/* CONFIG_RALINK_MT7628 */
+
+	data = (unsigned long)(pTable[index]);
+	data |= REGBIT(1, I2S_CLKDIV_EN); 
+	i2s_outw(I2S_DIVCOMP_CFG, data);
+#else
+	MSG("Internal REFCLK 15.625Mhz \n");
+	pTable = i2s_inclk_15p625Mhz;
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x30); 
+	data &= 0xFFFF00FF;
+	data |= (unsigned long)(pTable[index]);
+	data |= 0x00008000;
+	i2s_outw(RALINK_SYSCTL_BASE+0x30, data);  
+#endif /* CONFIG_I2S_FRAC_DIV */
+#else
+#if defined(CONFIG_I2S_MCLK_12MHZ)
+	/* REFCLK = MCLK = 12Mhz */
+	MSG("External REFCLK 12Mhz \n");
+	pTable = i2s_exclk_12Mhz;
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x30);
+	data &= 0xFFFF00FF;
+	data |= (unsigned long)(pTable[index]); 
+	data |= 0x0000C000;
+	i2s_outw(RALINK_SYSCTL_BASE+0x30, data);  	
+#else
+	/* REFCLK = MCLK = 12.288Mhz */
+	pTable = i2s_exclk_12p288Mhz;
+	MSG("External REFCLK 12.288Mhz \n");
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x30);
+	data &= 0xFFFF00FF;
+	data |= (unsigned long)(pTable[index]); 
+	data |= 0x0000C000;
+	i2s_outw(RALINK_SYSCTL_BASE+0x30, data); 					 
+#endif /* CONFIG_I2S_MCLK_12MHZ */		
+#endif /* Not CONFIG_I2S_IN_CLK */
+	
+#if defined(CONFIG_I2S_WS_EDGE)
+	data = i2s_inw(I2S_I2SCFG);
+	data |= REGBIT(0x1, I2S_WS_INV);
+	i2s_outw(I2S_I2SCFG, data);
+#endif
+
+	return 0;
+}
+
+int i2s_mode_config(u32 slave_en)
+{
+	unsigned long data;
+	
+	if(slave_en==0)
+	{
+		/* Master mode*/
+		_printk("This SoC is in Master mode\n");
+#if defined(CONFIG_RALINK_RT3052)
+		data = i2s_inw(I2S_I2SCFG);
+		data &= ~REGBIT(0x1, I2S_SLAVE_EN);
+		data &= ~REGBIT(0x1, I2S_CLK_OUT_DIS);
+		i2s_outw(I2S_I2SCFG, data);
+#elif defined(CONFIG_RALINK_RT3883)||defined(CONFIG_RALINK_RT3352)||\
+	defined(CONFIG_RALINK_RT5350)||defined(CONFIG_RALINK_RT6855)||\
+	defined(CONFIG_RALINK_MT7620)||defined(CONFIG_RALINK_RT6855A)||\
+	defined(CONFIG_RALINK_MT7621)||defined(CONFIG_RALINK_MT7628)||\
+	defined(CONFIG_ARCH_MT7623)
+		data = i2s_inw(I2S_I2SCFG);
+		data &= ~REGBIT(0x1, I2S_SLAVE_MODE);
+		i2s_outw(I2S_I2SCFG, data);
+#else
+	#error "a strange clock mode"	
+#endif	
+	}
+	else
+	{
+		/* Slave mode */
+		_printk("This SoC is in Slave mode\n");
+#if defined(CONFIG_RALINK_RT3052)
+		data = i2s_inw(I2S_I2SCFG);
+		data |= REGBIT(0x1, I2S_SLAVE_EN);
+		data |= REGBIT(0x1, I2S_CLK_OUT_DIS);
+		i2s_outw(I2S_I2SCFG, data);
+#elif defined(CONFIG_RALINK_RT3883)||defined(CONFIG_RALINK_RT3352)||\
+	defined(CONFIG_RALINK_RT5350)||defined(CONFIG_RALINK_RT6855)||\
+	defined(CONFIG_RALINK_MT7620)||defined(CONFIG_RALINK_RT6855A)||\
+	defined(CONFIG_RALINK_MT7621)||defined(CONFIG_RALINK_MT7628)||\
+	defined(CONFIG_ARCH_MT7623)
+		data = i2s_inw(I2S_I2SCFG);
+		data |= REGBIT(0x1, I2S_SLAVE_MODE);
+		i2s_outw(I2S_I2SCFG, data);
+#else
+		#error "a strange clock mode "	
+#endif
+	}
+
+	return 0;
+}
+
+int i2s_codec_frequency_config(i2s_config_type* ptri2s_config, unsigned long index)
+{
+#if defined(CONFIG_I2S_WM8960)||defined(CONFIG_I2S_WM8750)||defined(CONFIG_I2S_WM8751)
+	unsigned long data;
+	unsigned long* pTable;
+#endif
+
+#if defined(CONFIG_I2S_MCLK_12MHZ)
+#if defined(CONFIG_I2S_WM8960)||defined(CONFIG_I2S_WM8750)||defined(CONFIG_I2S_WM8751)
+	pTable = i2s_codec_12Mhz;
+	data = pTable[index];
+#endif
+#if defined(CONFIG_I2S_WM8960)
+	audiohw_set_frequency(data, ptri2s_config->codec_pll_en);
+#elif defined(CONFIG_I2S_WM8750)||defined(CONFIG_I2S_WM8751)
+	audiohw_set_frequency(data|0x01);
+#endif	
+#else
+#if defined(CONFIG_I2S_WM8960)||defined(CONFIG_I2S_WM8750)||defined(CONFIG_I2S_WM8751)
+#if defined(MT7623_FPGA_BOARD) && defined(CONFIG_I2S_WM8750)
+	pTable = i2s_codec_18p432Mhz;
+#else
+	pTable = i2s_codec_12p288Mhz;
+#endif
+	data = pTable[index];
+#endif
+#if defined(CONFIG_I2S_WM8960)
+	audiohw_set_frequency(data, ptri2s_config->codec_pll_en);
+#elif defined(CONFIG_I2S_WM8750)||defined(CONFIG_I2S_WM8751)
+	audiohw_set_frequency(data);
+#endif
+#endif
+	return 0;
+}
+
+/*
+ *  Ralink Audio System Clock Enable
+ *	
+ *  I2S_WS : signal direction opposite to/same as I2S_CLK 
+ *
+ *  I2S_CLK : Integer division or fractional division
+ *			  REFCLK from Internal or External (external REFCLK not support for fractional division)
+ *			  Suppose external REFCLK always be the same as external MCLK
+ * 		
+ *  MCLK : External OSC or internal generation
+ *
+ */
+int i2s_clock_enable(i2s_config_type* ptri2s_config)
+{
+	unsigned long index;
+	/* audio sampling rate decision */
+	switch(ptri2s_config->srate)
+	{
+		case 8000:
+			index = 0;
+			break;
+		case 11025:
+			index = 1;
+			break;
+		case 12000:
+			index = 2;
+			break;			
+		case 16000:
+			index = 3;
+			break;
+		case 22050:
+			index = 4;
+			break;
+        	case 24000:
+			index = 5;
+			break;	
+		case 32000:
+			index = 6;
+			break;			
+		case 44100:
+			index = 7;
+			break;
+		case 48000:
+			index = 8;
+			break;
+		case 88200:
+			index = 9;
+			break;	
+		case 96000:
+			index = 10;
+			break;
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+		case 176000:
+			index = 11;
+			break;
+		case 192000:
+			index = 12;
+			break;
+#endif
+		default:
+			index = 7;
+	}
+#ifdef MT7621_ASIC_BOARD
+        /* Set pll config  */
+        i2s_pll_config_mt7621(index);
+#endif
+#ifdef MT7623_ASIC_BOARD
+        /* Set pll config  */
+        i2s_pll_config_mt7623(index);
+#endif
+
+	/* enable internal MCLK */
+#if defined(CONFIG_I2S_IN_MCLK)
+#if defined(CONFIG_RALINK_MT7621)
+	i2s_pll_refclk_set();
+#endif
+#if defined(CONFIG_I2S_MCLK_12MHZ)
+#if defined(MT7628_ASIC_BOARD) || defined(CONFIG_ARCH_MT7623)
+        i2s_driving_strength_adjust();
+#endif
+	i2s_refclk_12m_enable();
+#endif /* MCLK_12MHZ */
+#if defined(CONFIG_I2S_MCLK_12P288MHZ)
+	i2s_refclk_12p288m_enable();
+#endif /* MCLK_12P288MHZ */
+#if defined(CONFIG_I2S_MCLK_18P432MHZ)
+	i2s_refclk_18p432m_enable(index);
+#endif
+	i2s_refclk_gpio_out_config();
+
+#else	
+	MSG("Disable SoC MCLK, use external OSC\n");
+	i2s_refclk_disable();
+	i2s_refclk_gpio_in_config();
+#endif /* CONFIG_I2S_IN_MCLK */	
+
+	i2s_share_pin_config(ptri2s_config);	
+	
+	if(ptri2s_config->slave_en==0)
+	{
+		/* Setup I2S_WS and I2S_CLK */
+		i2s_ws_config(ptri2s_config, index);	
+	}
+
+	i2s_mode_config(ptri2s_config->slave_en);
+
+	if(!ptri2s_config->bALSAEnable)
+	{
+#if defined(CONFIG_I2S_WM8750) || defined(CONFIG_I2S_WM8751)|| defined(CONFIG_I2S_WM8960)
+	i2s_codec_enable(ptri2s_config);
+#endif
+	i2s_codec_frequency_config(ptri2s_config,index);
+	}
+
+	return 0;
+}	
+
+int i2s_clock_disable(i2s_config_type* ptri2s_config)
+{
+	if(!ptri2s_config->bALSAEnable)
+	{
+#if defined(CONFIG_I2S_WM8960) || defined(CONFIG_I2S_WM8750) || defined(CONFIG_I2S_WM8751)
+	i2s_codec_disable(ptri2s_config);
+#endif
+	}
+
+	/* disable internal MCLK */
+#if defined(CONFIG_I2S_IN_MCLK)	
+	//i2s_refclk_disable();
+	//i2s_refclk_gpio_in_config();
+#endif
+	return 0;
+}	
+
+
+int i2s_codec_enable(i2s_config_type* ptri2s_config)
+{
+	
+	int AIn = 0, AOut = 0;
+#if 1
+#if defined(CONFIG_I2S_WM8960) || defined(CONFIG_I2S_WM8750) || defined(CONFIG_I2S_WM8751)
+	/* Codec initialization */
+	audiohw_preinit();
+#endif
+#endif
+
+#if defined(CONFIG_I2S_WM8960)
+	if(ptri2s_config->codec_pll_en)
+	{
+		MSG("Codec PLL EN = %d\n", pi2s_config->codec_pll_en);
+		audiohw_set_apll(ptri2s_config->srate);
+	}
+#endif
+
+#if defined(CONFIG_I2S_TXRX)	
+	if((ptri2s_config->bTxDMAEnable) || (ptri2s_config->txrx_coexist))
+		AOut = 1;
+	if((ptri2s_config->bRxDMAEnable) || (ptri2s_config->txrx_coexist))
+		AIn = 1;
+#if defined(CONFIG_I2S_WM8960)
+	audiohw_postinit(!(ptri2s_config->slave_en), AIn, AOut, ptri2s_config->codec_pll_en, ptri2s_config->wordlen_24b);
+	audiohw_micboost(ptri2s_config->micboost);	
+	audiohw_micin(ptri2s_config->micin);
+#elif defined(CONFIG_I2S_WM8750)
+	audiohw_postinit(!(ptri2s_config->slave_en), AIn, AOut, ptri2s_config->wordlen_24b);
+#endif
+	MSG("AOut=%d, AIn=%d\n", AOut, AIn);
+#else
+#if defined(CONFIG_I2S_WM8750)
+	audiohw_postinit(!(ptri2s_config->slave_en), 0, 1);
+#elif defined(CONFIG_I2S_WM8960)	
+	audiohw_postinit(!(ptri2s_config->slave_en), 1, 1, ptri2s_config->codec_pll_en);
+#elif defined(CONFIG_I2S_WM8751)	
+	if(ptri2s_config->slave_en==0)
+		audiohw_postinit(1,1);
+	else
+		audiohw_postinit(0,1);
+#endif		
+#endif
+	return 0;	
+}
+
+int i2s_codec_disable(i2s_config_type* ptri2s_config)
+{
+#if defined(CONFIG_I2S_WM8960) || defined(CONFIG_I2S_WM8750) || defined(CONFIG_I2S_WM8751)
+	audiohw_close();
+#endif
+	return 0;
+}	
+
+int i2s_reset_config(i2s_config_type* ptri2s_config)
+{
+	unsigned long data;
+
+	/* RESET bit: write 1 clear */
+#if defined(CONFIG_RALINK_RT6855A)
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x834);
+	data |= (1<<17);
+	i2s_outw(RALINK_SYSCTL_BASE+0x834, data);
+
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x834);
+	data &= ~(1<<17);
+	i2s_outw(RALINK_SYSCTL_BASE+0x834, data);
+#elif defined(CONFIG_ARCH_MT7623)
+	data = i2s_inw(0xFB000000+0x34);
+	data |= (1<<17);
+	i2s_outw(0xFB000000+0x34, data);
+
+	data = i2s_inw(0xFB000000+0x34);
+	data &= ~(1<<17);
+	i2s_outw(0xFB000000+0x34, data);
+#else
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x34);
+	data |= (1<<17);
+	i2s_outw(RALINK_SYSCTL_BASE+0x34, data);
+
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x34);
+	data &= ~(1<<17);
+	i2s_outw(RALINK_SYSCTL_BASE+0x34, data);
+
+#if 0  /* Reset GDMA */
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x34);
+	data |= (1<<14);
+	i2s_outw(RALINK_SYSCTL_BASE+0x34, data);
+
+	data = i2s_inw(RALINK_SYSCTL_BASE+0x34);
+	data &= ~(1<<14);
+	i2s_outw(RALINK_SYSCTL_BASE+0x34, data);
+#endif
+#endif
+	_printk("I2S reset complete!!\n");	
+	return 0;
+}
+
+int i2s_tx_config(i2s_config_type* ptri2s_config)
+{
+	unsigned long data;
+	/* set I2S_I2SCFG */
+	data = i2s_inw(I2S_I2SCFG);
+	data &= 0xFFFFFF81;
+	data |= REGBIT(ptri2s_config->tx_ff_thres, I2S_TX_FF_THRES);
+	data |= REGBIT(ptri2s_config->tx_ch_swap, I2S_TX_CH_SWAP);
+#if defined(CONFIG_RALINK_RT6855A)	
+	data |= REGBIT(1, I2S_BYTE_SWAP);
+#endif
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+	MSG("TX:wordLen=%d, sysEndian=%d\n", ptri2s_config->wordlen_24b, ptri2s_config->sys_endian);
+	data |= REGBIT(ptri2s_config->wordlen_24b, I2S_DATA_24BIT);
+	data |= REGBIT(ptri2s_config->sys_endian, I2S_SYS_ENDIAN);
+	data |= REGBIT(ptri2s_config->little_edn, I2S_LITTLE_ENDIAN);
+#endif	
+	data &= ~REGBIT(1, I2S_TX_CH0_OFF);
+	data &= ~REGBIT(1, I2S_TX_CH1_OFF);
+	i2s_outw(I2S_I2SCFG, data);
+
+	/* set I2S_I2SCFG1 */
+	MSG("internal loopback: %d\n", ptri2s_config->lbk);
+	data = i2s_inw(I2S_I2SCFG1);
+	data |= REGBIT(ptri2s_config->lbk, I2S_LBK_EN);
+	data |= REGBIT(ptri2s_config->extlbk, I2S_EXT_LBK_EN);
+	data &= 0xFFFFFFFC;
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+	data |= REGBIT(ptri2s_config->fmt, I2S_DATA_FMT);
+#endif
+	i2s_outw(I2S_I2SCFG1, data);
+	
+	return 0;
+}	
+
+int i2s_rx_config(i2s_config_type* ptri2s_config)
+{
+	unsigned long data;
+	/* set I2S_I2SCFG */
+	data = i2s_inw(I2S_I2SCFG);
+	data &= 0xFFFF81FF;
+	data |= REGBIT(ptri2s_config->rx_ff_thres, I2S_RX_FF_THRES);
+	data |= REGBIT(ptri2s_config->rx_ch_swap, I2S_RX_CH_SWAP);
+	data &= ~REGBIT(1, I2S_RX_CH0_OFF);
+	data &= ~REGBIT(1, I2S_RX_CH1_OFF);
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+	MSG("RX:wordLen=%d, sysEndian=%d\n", ptri2s_config->wordlen_24b, ptri2s_config->sys_endian);
+	data |= REGBIT(ptri2s_config->wordlen_24b, I2S_DATA_24BIT);
+	data |= REGBIT(ptri2s_config->sys_endian, I2S_SYS_ENDIAN);
+	data |= REGBIT(ptri2s_config->little_edn, I2S_LITTLE_ENDIAN);
+#endif	
+	i2s_outw(I2S_I2SCFG, data);
+
+	/* set I2S_I2SCFG1 */
+	data = i2s_inw(I2S_I2SCFG1);
+	data |= REGBIT(ptri2s_config->lbk, I2S_LBK_EN);
+	data |= REGBIT(ptri2s_config->extlbk, I2S_EXT_LBK_EN);
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+	data &= 0xFFFFFFFC;
+	data |= REGBIT(ptri2s_config->fmt, I2S_DATA_FMT);
+#endif
+	i2s_outw(I2S_I2SCFG1, data);
+	
+	return 0;	
+}
+
+/* Turn On Tx DMA and INT */
+int i2s_tx_enable(i2s_config_type* ptri2s_config)
+{
+	unsigned long data;
+
+#if defined(I2S_HW_INTERRUPT_EN)	
+	data = i2s_inw(I2S_INT_EN);
+	data |= REGBIT(0x1, I2S_TX_INT3_EN);  /* FIFO DMA fault */
+	data |= REGBIT(0x1, I2S_TX_INT2_EN);  /* FIFO overrun */
+	data |= REGBIT(0x1, I2S_TX_INT1_EN);  /* FIFO underrun */
+	data |= REGBIT(0x1, I2S_TX_INT0_EN);  /* FIFO below threshold */
+	i2s_outw(I2S_INT_EN, data);
+#endif	
+
+	data = i2s_inw(I2S_I2SCFG);
+#if defined(CONFIG_I2S_TXRX)	
+	data |= REGBIT(0x1, I2S_TX_EN);
+#endif	
+	data |= REGBIT(0x1, I2S_DMA_EN);
+	i2s_outw(I2S_I2SCFG, data);
+	
+	data = i2s_inw(I2S_I2SCFG);
+	data |= REGBIT(0x1, I2S_EN);
+	i2s_outw(I2S_I2SCFG, data);
+	pi2s_config->bTxDMAEnable = 1;
+	MSG("i2s_tx_enable done\n");
+	return I2S_OK;
+}
+
+/* Turn On Rx DMA and INT */
+int i2s_rx_enable(i2s_config_type* ptri2s_config)
+{
+	unsigned long data;
+
+#if defined(I2S_HW_INTERRUPT_EN)	
+	data = i2s_inw(I2S_INT_EN);
+	data |= REGBIT(0x1, I2S_RX_INT3_EN);  /* FIFO DMA fault */
+	data |= REGBIT(0x1, I2S_RX_INT2_EN);  /* FIFO overrun */
+	data |= REGBIT(0x1, I2S_RX_INT1_EN);  /* FIFO underrun */
+	data |= REGBIT(0x1, I2S_RX_INT0_EN);  /* FIFO below threshold */
+	i2s_outw(I2S_INT_EN, data);
+#endif
+	
+	data = i2s_inw(I2S_I2SCFG);
+#if defined(CONFIG_I2S_TXRX)	
+	data |= REGBIT(0x1, I2S_RX_EN);
+#endif	
+	data |= REGBIT(0x1, I2S_DMA_EN);
+	i2s_outw(I2S_I2SCFG, data);
+	
+	data = i2s_inw(I2S_I2SCFG);
+	data |= REGBIT(0x1, I2S_EN);
+	i2s_outw(I2S_I2SCFG, data);
+	ptri2s_config->bRxDMAEnable = 1;
+	
+	MSG("i2s_rx_enable done\n");
+	return I2S_OK;
+}
+/* Turn Off Tx DMA and INT */
+int i2s_tx_disable(i2s_config_type* ptri2s_config)
+{
+	unsigned long data;
+
+#if defined(I2S_HW_INTERRUPT_EN)	
+	data = i2s_inw(I2S_INT_EN);
+	data &= ~REGBIT(0x1, I2S_TX_INT3_EN);
+	data &= ~REGBIT(0x1, I2S_TX_INT2_EN);
+	data &= ~REGBIT(0x1, I2S_TX_INT1_EN);
+	data &= ~REGBIT(0x1, I2S_TX_INT0_EN);
+	i2s_outw(I2S_INT_EN, data);
+#endif	
+
+	data = i2s_inw(I2S_I2SCFG);
+#if defined(CONFIG_I2S_TXRX)	
+	data &= ~REGBIT(0x1, I2S_TX_EN);
+#endif	
+	if(ptri2s_config->bRxDMAEnable==0)
+	{
+		MSG("=====%s+++++:%d\n",__func__,ptri2s_config->bTxDMAEnable);
+		ptri2s_config->bTxDMAEnable = 0;
+		data &= ~REGBIT(0x1, I2S_DMA_EN);
+                data &= ~REGBIT(0x1, I2S_EN);
+	}
+	i2s_outw(I2S_I2SCFG, data);
+	return I2S_OK;
+}
+/* Turn Off Rx DMA and INT */	
+int i2s_rx_disable(i2s_config_type* ptri2s_config)
+{
+	unsigned long data;
+
+#if defined(I2S_HW_INTERRUPT_EN)	
+	data = i2s_inw(I2S_INT_EN);
+	data &= ~REGBIT(0x1, I2S_RX_INT3_EN);
+	data &= ~REGBIT(0x1, I2S_RX_INT2_EN);
+	data &= ~REGBIT(0x1, I2S_RX_INT1_EN);
+	data &= ~REGBIT(0x1, I2S_RX_INT0_EN);
+	i2s_outw(I2S_INT_EN, data);
+#endif
+	
+	data = i2s_inw(I2S_I2SCFG);
+#if defined(CONFIG_I2S_TXRX)	
+	data &= ~REGBIT(0x1, I2S_RX_EN);
+#endif
+	if(ptri2s_config->bTxDMAEnable==0)
+	{
+		ptri2s_config->bRxDMAEnable = 0;
+		data &= ~REGBIT(0x1, I2S_DMA_EN);
+                data &= ~REGBIT(0x1, I2S_EN);
+	}
+	i2s_outw(I2S_I2SCFG, data);
+	return I2S_OK;
+}
+
+int i2s_dma_tx_transf_data(i2s_config_type* ptri2s_config, u32 dma_ch)
+{
+	int tx_r_idx;
+
+	if((pi2s_config->bALSAEnable==1) && (pi2s_config->bALSAMMAPEnable==1)&&(pi2s_config->mmap_index <= MAX_I2S_PAGE))
+		tx_r_idx = (pi2s_config->tx_r_idx + ALSA_MMAP_IDX_SHIFT)%MAX_I2S_PAGE;
+	else
+		tx_r_idx = pi2s_config->tx_r_idx;
+	//MSG(">>>>>>  tx_r_idx:%d\n",tx_r_idx);
+	if(dma_ch==GDMA_I2S_TX0)
+        {
+        	if(pi2s_config->is_tx_mmap){
+				dma_sync_single_for_device(NULL,  i2s_mmap_addr[tx_r_idx], I2S_PAGE_SIZE, DMA_TO_DEVICE);
+#if defined(ARM_ARCH)
+				GdmaI2sTx(i2s_mmap_addr[tx_r_idx], I2S_TX_FIFO_WREG_PHY, 0, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#else
+				GdmaI2sTx((u32)(pi2s_config->pMMAPTxBufPtr[tx_r_idx]), I2S_TX_FIFO_WREG, 0, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#endif
+			}
+			else{
+				memcpy(pi2s_config->pPage0TxBuf8ptr,  pi2s_config->pMMAPTxBufPtr[tx_r_idx], I2S_PAGE_SIZE);
+#if defined(ARM_ARCH)
+				GdmaI2sTx(i2s_txdma_addr0, I2S_TX_FIFO_WREG_PHY, 0, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#else
+				GdmaI2sTx((u32)(pi2s_config->pPage0TxBuf8ptr), I2S_TX_FIFO_WREG, 0, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#endif
+			}
+            pi2s_config->dmach = GDMA_I2S_TX0;
+			pi2s_config->tx_r_idx = (pi2s_config->tx_r_idx+1)%MAX_I2S_PAGE;
+	}
+        else
+        {
+        	if(pi2s_config->is_tx_mmap){
+				dma_sync_single_for_device(NULL,  i2s_mmap_addr[tx_r_idx], I2S_PAGE_SIZE, DMA_TO_DEVICE);
+#if defined(ARM_ARCH)
+				GdmaI2sTx(i2s_mmap_addr[tx_r_idx], I2S_TX_FIFO_WREG_PHY, 1, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#else
+				GdmaI2sTx((u32)(pi2s_config->pMMAPTxBufPtr[tx_r_idx]), I2S_TX_FIFO_WREG, 1, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#endif
+			}
+			else{
+				memcpy(pi2s_config->pPage1TxBuf8ptr,  pi2s_config->pMMAPTxBufPtr[tx_r_idx], I2S_PAGE_SIZE);
+#if defined(ARM_ARCH)
+				GdmaI2sTx(i2s_txdma_addr1, I2S_TX_FIFO_WREG_PHY, 1, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#else
+				GdmaI2sTx((u32)(pi2s_config->pPage1TxBuf8ptr), I2S_TX_FIFO_WREG, 1, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#endif
+			}
+                pi2s_config->dmach = GDMA_I2S_TX1;
+                pi2s_config->tx_r_idx = (pi2s_config->tx_r_idx+1)%MAX_I2S_PAGE;
+	}
+#if defined(CONFIG_I2S_WITH_AEC)
+	if(aecFuncP->AECFeEnq){
+		aecFuncP->AECFeEnq(0,pi2s_config->pMMAPTxBufPtr[pi2s_config->tx_r_idx],I2S_PAGE_SIZE);
+	}
+#endif
+	return 0;
+}
+
+int i2s_dma_tx_transf_zero(i2s_config_type* ptri2s_config, u32 dma_ch)
+{
+	if(dma_ch==GDMA_I2S_TX0)
+        {
+         	memset(pi2s_config->pPage0TxBuf8ptr, 0, I2S_PAGE_SIZE);
+#if defined(ARM_ARCH)
+		GdmaI2sTx(i2s_txdma_addr0, I2S_TX_FIFO_WREG_PHY, 0, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#else
+			MSG("+++++++%s+++++\n",__func__);
+            GdmaI2sTx((u32)pi2s_config->pPage0TxBuf8ptr, I2S_TX_FIFO_WREG, 0, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#endif
+        }
+        else
+        {
+                memset(pi2s_config->pPage1TxBuf8ptr, 0, I2S_PAGE_SIZE);
+#if defined(ARM_ARCH)
+		GdmaI2sTx(i2s_txdma_addr1, I2S_TX_FIFO_WREG_PHY, 1, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#else
+                GdmaI2sTx((u32)pi2s_config->pPage1TxBuf8ptr, I2S_TX_FIFO_WREG, 1, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#endif
+        }
+	return 0;
+}
+
+int i2s_dma_rx_transf_data(i2s_config_type* ptri2s_config, u32 dma_ch)
+{
+	int rx_w_idx;
+
+	pi2s_config->rx_w_idx = (pi2s_config->rx_w_idx+1)%MAX_I2S_PAGE;
+
+	if ((pi2s_config->bALSAEnable==1) && (pi2s_config->bALSAMMAPEnable==1))
+		rx_w_idx = (pi2s_config->rx_w_idx+ALSA_MMAP_IDX_SHIFT)%MAX_I2S_PAGE;
+	else
+		rx_w_idx = (pi2s_config->rx_w_idx)%MAX_I2S_PAGE;
+	//MSG("=========== rx_w_idx:%d\n",rx_w_idx+MAX_I2S_PAGE);
+	if(dma_ch==GDMA_I2S_RX0)
+        {
+             if(ptri2s_config->is_rx_mmap){
+				  dma_sync_single_for_device(NULL,	i2s_mmap_addr[rx_w_idx+MAX_I2S_PAGE], I2S_PAGE_SIZE, DMA_FROM_DEVICE);
+#if defined(ARM_ARCH)
+				 GdmaI2sRx(I2S_RX_FIFO_RREG_PHY, (u32)i2s_mmap_addr[rx_w_idx+MAX_I2S_PAGE], 0, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#else
+				 GdmaI2sRx(I2S_RX_FIFO_RREG, (u32)(pi2s_config->pMMAPRxBufPtr[rx_w_idx]), 0, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#endif
+			 }
+			 else{
+				memcpy(pi2s_config->pMMAPRxBufPtr[rx_w_idx], pi2s_config->pPage0RxBuf8ptr, I2S_PAGE_SIZE);
+#if defined(ARM_ARCH)
+				GdmaI2sRx(I2S_RX_FIFO_RREG_PHY, i2s_rxdma_addr0, 0, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#else
+				GdmaI2sRx(I2S_RX_FIFO_RREG, (u32)(pi2s_config->pPage0RxBuf8ptr), 0, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#endif
+			 }
+             pi2s_config->dmach = GDMA_I2S_RX0;
+        }
+	else
+        {
+             if(ptri2s_config->is_rx_mmap){
+				dma_sync_single_for_device(NULL,  i2s_mmap_addr[rx_w_idx+ MAX_I2S_PAGE], I2S_PAGE_SIZE, DMA_FROM_DEVICE);
+#if defined(ARM_ARCH)
+				GdmaI2sRx(I2S_RX_FIFO_RREG_PHY, (u32)i2s_mmap_addr[rx_w_idx+MAX_I2S_PAGE], 1, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#else
+				GdmaI2sRx(I2S_RX_FIFO_RREG, (u32)(pi2s_config->pMMAPRxBufPtr[rx_w_idx]), 1, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#endif
+			 }
+			 else{
+				memcpy(pi2s_config->pMMAPRxBufPtr[rx_w_idx], pi2s_config->pPage1RxBuf8ptr, I2S_PAGE_SIZE);
+#if defined(ARM_ARCH)
+				GdmaI2sRx(I2S_RX_FIFO_RREG_PHY, i2s_rxdma_addr1, 1, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#else
+				GdmaI2sRx(I2S_RX_FIFO_RREG, (u32)(pi2s_config->pPage1RxBuf8ptr), 1, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#endif
+			 }
+                pi2s_config->dmach = GDMA_I2S_RX1;
+
+        }
+#if defined(CONFIG_I2S_WITH_AEC)
+		if(aecFuncP->AECNeEnq){
+			aecFuncP->AECNeEnq(0,pi2s_config->pMMAPRxBufPtr[rx_w_idx],I2S_PAGE_SIZE);
+		}
+#endif
+	return 0;
+}
+
+int i2s_dma_rx_transf_zero(i2s_config_type* ptri2s_config, u32 dma_ch)
+{
+	if(dma_ch==GDMA_I2S_RX0)
+        {	
+		memset(pi2s_config->pPage0RxBuf8ptr, 0, I2S_PAGE_SIZE);
+#if defined(ARM_ARCH)
+		GdmaI2sRx(I2S_RX_FIFO_RREG_PHY, i2s_rxdma_addr0, 0, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#else
+          GdmaI2sRx(I2S_RX_FIFO_RREG, (u32)pi2s_config->pPage0RxBuf8ptr, 0, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#endif
+        }
+        else
+       	{
+		memset(pi2s_config->pPage1RxBuf8ptr, 0, I2S_PAGE_SIZE);
+#if defined(ARM_ARCH)
+		GdmaI2sRx(I2S_RX_FIFO_RREG_PHY, i2s_rxdma_addr1, 1, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#else
+         GdmaI2sRx(I2S_RX_FIFO_RREG, (u32)pi2s_config->pPage1RxBuf8ptr, 1, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#endif
+        }
+	return 0;
+}
+
+void i2s_dma_tx_handler(u32 dma_ch)
+{
+	pi2s_config->enLable = 1; /* TX:enLabel=1; RX:enLabel=2 */
+	//printk("******* %s *******\n", __func__);
+
+	if(pi2s_config->bTxDMAEnable==0) 
+	{
+		if(pi2s_config->end_cnt != 0)
+		{
+			i2s_dma_tx_transf_data(pi2s_config, dma_ch);
+			pi2s_config->end_cnt --;
+	        	MSG("end_cnt = %d, r_idx = %d\n", pi2s_config->end_cnt, pi2s_config->tx_r_idx);
+		}
+		else
+		{
+			pi2s_config->tx_stop_cnt++;
+			i2s_dma_tx_soft_stop(pi2s_config, dma_ch);
+			MSG("tx_stop=%d, ch=%d\n", pi2s_config->tx_stop_cnt, dma_ch);
+			if (pi2s_config->tx_stop_cnt == 3)
+			{
+                        	wake_up_interruptible(&(pi2s_config->i2s_tx_qh));
+				MSG("T:wake up!!\n");
+			}
+		}
+		return;
+	}
+	
+	pi2s_config->tx_isr_cnt++;
+
+#ifdef 	I2S_STATISTIC
+	i2s_int_status(dma_ch);
+#endif
+	/* FIXME */
+	if(pi2s_config->bALSAEnable)
+	{
+		if(pi2s_config->dmaStat[STREAM_PLAYBACK])
+		{
+			if(!pi2s_config->bTrigger[STREAM_PLAYBACK]){
+				MSG("trigger stop: rIdx:%d widx:%d\n", pi2s_config->tx_r_idx,pi2s_config->tx_w_idx);
+                i2s_dma_tx_transf_zero(pi2s_config, dma_ch);
+                //i2s_dma_tx_transf_data(pi2s_config, dma_ch);
+                if(pi2s_config->bPreTrigger[STREAM_PLAYBACK]){
+                    /* mtk04880 commented:
+                     * for corner case, there are cases which ALSA Trigger stop before disabling DMA.
+                     * For which case, it needs to keep call snd_pcm_elapased to keep ALSA hw ptr updating.
+                     * It is so called post stop handlment.
+                     */
+                    //MSG("post-stop\n");
+                    goto EXIT;
+                }
+                else{
+                    //MSG("pre-stop\n");
+                    wake_up_interruptible(&(pi2s_config->i2s_tx_qh));
+                    return;
+                }
+             }
+            else{
+                    if(!pi2s_config->bPreTrigger[STREAM_PLAYBACK]){
+                            pi2s_config->bPreTrigger[STREAM_PLAYBACK] = 1;
+							MSG("bPreTrigger:STREAM_PLAYBACK\n");
+                    	}
+			}
+		}	
+	}
+	else
+	{
+		if(pi2s_config->tx_r_idx==pi2s_config->tx_w_idx)
+		{
+			/* Buffer Empty */
+			MSG("TXBE r=%d w=%d[i=%u,c=%u]\n",pi2s_config->tx_r_idx,pi2s_config->tx_w_idx,pi2s_config->tx_isr_cnt,dma_ch);
+#ifdef I2S_STATISTIC		
+			pi2s_status->txbuffer_unrun++;
+#endif	
+			i2s_dma_tx_transf_zero(pi2s_config, dma_ch);
+			goto EXIT;	
+		}
+	}
+
+	if(pi2s_config->pMMAPTxBufPtr[pi2s_config->tx_r_idx]==NULL)
+	{
+		MSG("mmap buf NULL [%d]\n",pi2s_config->tx_r_idx);
+		i2s_dma_tx_transf_zero(pi2s_config, dma_ch);
+
+		goto EXIT;	
+	}
+
+	if(pi2s_config->tx_pause_en == 1)
+	{
+		/* Enable PAUSE */
+		MSG("TX pause now\n");
+		i2s_dma_tx_transf_zero(pi2s_config, dma_ch);
+
+		goto EXIT;	
+	}
+
+#ifdef I2S_STATISTIC	
+	pi2s_status->txbuffer_len--;
+#endif
+	i2s_dma_tx_transf_data(pi2s_config, dma_ch);
+
+EXIT:
+#if defined(CONFIG_SND_MT76XX_SOC)
+	if(pi2s_config->bALSAEnable == 1){
+		if(pi2s_config->pss[STREAM_PLAYBACK])
+			snd_pcm_period_elapsed(pi2s_config->pss[STREAM_PLAYBACK]);
+	}
+#endif
+	wake_up_interruptible(&(pi2s_config->i2s_tx_qh));		
+	return;
+}
+
+void i2s_dma_rx_handler(u32 dma_ch)
+{
+	pi2s_config->enLable = 2; /* TX:enLabel=1; RX:enLabel=2 */
+	//printk("******* %s *******\n", __func__);
+#if defined(CONFIG_I2S_TXRX)
+	if(pi2s_config->rx_isr_cnt==0)
+	{
+		pi2s_config->next_p0_idx = 0;
+		pi2s_config->next_p1_idx = 1;
+	}	
+	pi2s_config->rx_isr_cnt++;
+	
+#ifdef  I2S_STATISTIC
+	i2s_int_status(dma_ch);
+#endif
+
+	if (pi2s_config->bRxDMAEnable==0)
+	{
+		pi2s_config->rx_stop_cnt++;
+		i2s_dma_rx_soft_stop(pi2s_config, dma_ch);
+		MSG("<-------------------->rx_stop=%d\n", pi2s_config->rx_stop_cnt);
+
+		if(pi2s_config->rx_stop_cnt == 2)
+		{
+			wake_up_interruptible(&(pi2s_config->i2s_rx_qh));
+			_printk("R:wake up!!\n");
+		}
+		return;	
+	}
+
+	if(pi2s_config->bALSAEnable)
+	{
+		 if(pi2s_config->dmaStat[STREAM_CAPTURE]){
+			if(!pi2s_config->bTrigger[STREAM_CAPTURE]){
+                    //MSG("trigger stop: rIdx:%d widx:%d\n", pi2s_config->rx_r_idx,pi2s_config->rx_w_idx);
+					i2s_dma_rx_transf_zero(pi2s_config, dma_ch);
+                    wake_up_interruptible(&(pi2s_config->i2s_rx_qh));
+                    return;
+			}
+		 }
+	}
+	else
+	{
+		if(((pi2s_config->rx_w_idx+1)%MAX_I2S_PAGE)==pi2s_config->rx_r_idx){
+			/* Buffer Full */
+			MSG("RXBF r=%d w=%d[i=%u,c=%u]\n",pi2s_config->rx_r_idx,pi2s_config->rx_w_idx,pi2s_config->rx_isr_cnt,dma_ch);
+#ifdef I2S_STATISTIC		
+			pi2s_status->rxbuffer_unrun++;
+#endif	
+			i2s_dma_rx_transf_zero(pi2s_config, dma_ch);
+			goto EXIT;	
+		}
+	}
+
+	if(pi2s_config->rx_pause_en == 1)
+	{
+		/* Enable PAUSE */
+		i2s_dma_rx_transf_zero(pi2s_config, dma_ch);
+
+		goto EXIT;	
+	}
+
+#ifdef I2S_STATISTIC	
+	pi2s_status->rxbuffer_len++;
+#endif
+	i2s_dma_rx_transf_data(pi2s_config, dma_ch);
+
+EXIT:
+#if defined(CONFIG_SND_MT76XX_SOC)
+	if(pi2s_config->bALSAEnable == 1){
+		if(pi2s_config->pss[STREAM_CAPTURE])
+			snd_pcm_period_elapsed(pi2s_config->pss[STREAM_CAPTURE]);
+	}
+#endif
+	wake_up_interruptible(&(pi2s_config->i2s_rx_qh));
+#endif	
+	return;
+}
+
+#ifdef I2S_STATISTIC
+void i2s_int_status(u32 dma_ch)
+{
+	u32 i2s_status;
+	
+	if((pi2s_config->tx_isr_cnt>0)||(pi2s_config->rx_isr_cnt>0))
+	{
+		i2s_status = i2s_inw(I2S_INT_STATUS);
+		
+		if(i2s_status&REGBIT(1, I2S_TX_DMA_FAULT))
+		{
+			pi2s_status->txdmafault++;
+		}
+		if(i2s_status&REGBIT(1, I2S_TX_OVRUN))
+		{
+			pi2s_status->txovrun++;
+		}
+		if(i2s_status&REGBIT(1, I2S_TX_UNRUN))
+		{
+			pi2s_status->txunrun++;
+		}
+		if(i2s_status&REGBIT(1, I2S_TX_THRES))
+		{
+			pi2s_status->txthres++;
+		}
+		if(i2s_status&REGBIT(1, I2S_RX_DMA_FAULT))
+		{
+			pi2s_status->rxdmafault++;
+		}
+		if(i2s_status&REGBIT(1, I2S_RX_OVRUN))
+		{
+			pi2s_status->rxovrun++;
+		}
+		if(i2s_status&REGBIT(1, I2S_RX_UNRUN))
+		{
+			pi2s_status->rxunrun++;
+		}
+		if(i2s_status&REGBIT(1, I2S_RX_THRES))
+		{
+			pi2s_status->rxthres++;
+		}
+	}
+#if 0
+	if(pi2s_config->enLable == 1)
+	{
+		if((pi2s_config->tx_isr_cnt>0) && (pi2s_config->tx_isr_cnt%40==0))
+		{
+			MSG("tisr i=%u,ch=%u,o=%u,u=%d,s=%X [r=%d,w=%d]\n",\
+				pi2s_config->tx_isr_cnt,dma_ch,pi2s_status->txovrun,pi2s_status->txunrun,\
+				i2s_inw(I2S_INT_STATUS),pi2s_config->tx_r_idx,pi2s_config->tx_w_idx);
+		}
+	}
+	
+	if(pi2s_config->enLable == 2)
+	{
+		if((pi2s_config->rx_isr_cnt>0) && (pi2s_config->rx_isr_cnt%40==0))
+		{
+			MSG("risr i=%u,ch=%u,o=%u,u=%d,s=%X [r=%d,w=%d]\n",\
+				pi2s_config->rx_isr_cnt,dma_ch,pi2s_status->rxovrun,pi2s_status->rxunrun,\
+				i2s_inw(I2S_INT_STATUS),pi2s_config->rx_r_idx,pi2s_config->rx_w_idx);
+		}
+	}
+#endif
+	
+	*(unsigned long*)(I2S_INT_STATUS) = 0xFFFFFFFF;
+}
+#endif
+
+#if defined(I2S_HW_INTERRUPT_EN)&&(I2S_SW_IRQ_EN)
+irqreturn_t i2s_irq_isr(int irq, void *irqaction)
+{
+	u32 i2s_status;
+	
+	//MSG("i2s_irq_isr [0x%08X]\n",i2s_inw(I2S_INT_STATUS));
+	if((pi2s_config->tx_isr_cnt>0)||(pi2s_config->rx_isr_cnt>0))
+	{
+		i2s_status = i2s_inw(I2S_INT_STATUS);
+		MSG("i2s_irq_isr [0x%08X]\n",i2s_status);
+	}
+	else
+		return IRQ_HANDLED;
+		
+	if(i2s_status&REGBIT(1, I2S_TX_DMA_FAULT))
+	{
+#ifdef I2S_STATISTIC
+		pi2s_status->txdmafault++;
+#endif
+	}
+	if(i2s_status&REGBIT(1, I2S_TX_OVRUN))
+	{
+#ifdef I2S_STATISTIC
+		pi2s_status->txovrun++;
+#endif
+	}
+	if(i2s_status&REGBIT(1, I2S_TX_UNRUN))
+	{
+#ifdef I2S_STATISTIC
+		pi2s_status->txunrun++;
+#endif
+	}
+	if(i2s_status&REGBIT(1, I2S_TX_THRES))
+	{
+#ifdef I2S_STATISTIC
+		pi2s_status->txthres++;
+#endif
+	}
+	if(i2s_status&REGBIT(1, I2S_RX_DMA_FAULT))
+	{
+#ifdef I2S_STATISTIC
+		pi2s_status->rxdmafault++;
+#endif
+	}
+	if(i2s_status&REGBIT(1, I2S_RX_OVRUN))
+	{
+#ifdef I2S_STATISTIC
+		pi2s_status->rxovrun++;
+#endif
+	}
+	if(i2s_status&REGBIT(1, I2S_RX_UNRUN))
+	{
+#ifdef I2S_STATISTIC
+		pi2s_status->rxunrun++;
+#endif
+	}
+	if(i2s_status&REGBIT(1, I2S_RX_THRES))
+	{
+#ifdef I2S_STATISTIC
+		pi2s_status->rxthres++;
+#endif
+	}
+	i2s_outw(I2S_INT_STATUS, 0xFFFFFFFF);
+	return IRQ_HANDLED;
+}
+#endif
+
+void i2s_tx_task(unsigned long pData)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&pi2s_config->lock, flags);
+	MSG("******* %s *******\n", __func__);
+	//if (pi2s_config->bTxDMAEnable!=0)
+	{	
+		if (pi2s_config->tx_unmask_ch!=0)
+		{
+			u32 dmach = pi2s_config->tx_unmask_ch;
+			u32 ch;
+			for (ch = 0; ch < 16; ch++)
+			{
+				if (dmach& (1<<ch))
+				{
+					MSG("do unmask ch%d tisr=%d in tx_isr\n",ch,pi2s_config->tx_isr_cnt);
+					GdmaUnMaskChannel(ch);
+				}	
+			}
+			pi2s_config->tx_unmask_ch = 0;	
+		}
+	}	
+	spin_unlock_irqrestore(&pi2s_config->lock, flags);
+}
+
+void i2s_rx_task(unsigned long pData)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&pi2s_config->lock, flags);
+	MSG("******* %s *******\n", __func__);
+	//if (pi2s_config->bRxDMAEnable!=0)
+	{	
+		if (pi2s_config->rx_unmask_ch!=0)
+		{
+			u32 dmach = pi2s_config->rx_unmask_ch;
+			u32 ch;
+			for (ch = 0; ch < 16; ch++)
+			{
+				if (dmach& (1<<ch))
+				{
+					MSG("do unmask ch%d risr=%d in rx_isr\n",ch,pi2s_config->rx_isr_cnt);
+					GdmaUnMaskChannel(ch);
+				}	
+			}
+			pi2s_config->rx_unmask_ch = 0;	
+	
+		}
+	}	
+	spin_unlock_irqrestore(&pi2s_config->lock, flags);
+}
+
+
+void i2s_dma_unmask_handler(u32 dma_ch)
+{
+	MSG("i2s_dma_unmask_handler ch=%d\n",dma_ch);
+	
+	GdmaUnMaskChannel(dma_ch);
+
+	return;
+}
+
+void i2s_dma_tx_unmask_handler(u32 dma_ch)
+{
+	MSG("i2s_dma_tx_unmask_handler ch=%d\n",dma_ch);
+	pi2s_config->tx_unmask_ch |= (1<<dma_ch);
+	tasklet_hi_schedule(&i2s_tx_tasklet);
+	return;
+}
+
+void i2s_dma_rx_unmask_handler(u32 dma_ch)
+{
+	MSG("i2s_dma_rx_unmask_handler ch=%d\n",dma_ch);
+	pi2s_config->rx_unmask_ch |= (1<<dma_ch);
+	tasklet_hi_schedule(&i2s_rx_tasklet);
+	return;
+}
+
+void i2s_dma_mask_handler(u32 dma_ch)
+{
+        MSG("i2s_dma_mask_handler ch=%d\n", dma_ch);
+        GdmaMaskChannel(dma_ch);
+        return;
+}
+
+void i2s_dma_tx_init(i2s_config_type* ptri2s_config)
+{
+	MSG("******* %s *******\n", __func__);
+
+	memset(pi2s_config->pPage0TxBuf8ptr, 0, I2S_PAGE_SIZE);
+	memset(pi2s_config->pPage1TxBuf8ptr, 0, I2S_PAGE_SIZE);
+#if defined(ARM_ARCH)
+	GdmaI2sTx(i2s_txdma_addr0, I2S_TX_FIFO_WREG_PHY, 0, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+	GdmaI2sTx(i2s_txdma_addr1, I2S_TX_FIFO_WREG_PHY, 1, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#else
+	//finish dma exec i2s_dma_tx_handler func
+	//start dma exec i2s_dma_tx_unmask_handler func
+	GdmaI2sTx((u32)ptri2s_config->pPage0TxBuf8ptr, I2S_FIFO_WREG, 0, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+	GdmaI2sTx((u32)ptri2s_config->pPage1TxBuf8ptr, I2S_FIFO_WREG, 1, I2S_PAGE_SIZE, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#endif
+
+	return;
+}
+
+void i2s_dma_rx_init(i2s_config_type* ptri2s_config)
+{
+	MSG("******* %s *******\n", __func__);
+
+	memset(pi2s_config->pPage0RxBuf8ptr, 0, I2S_PAGE_SIZE);
+	memset(pi2s_config->pPage1RxBuf8ptr, 0, I2S_PAGE_SIZE);
+
+#if defined(ARM_ARCH)
+	GdmaI2sRx(I2S_RX_FIFO_RREG_PHY, i2s_rxdma_addr0, 0, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+	GdmaI2sRx(I2S_RX_FIFO_RREG_PHY, i2s_rxdma_addr1, 1, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#else
+	GdmaI2sRx(I2S_RX_FIFO_RREG, (u32)ptri2s_config->pPage0RxBuf8ptr, 0, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+	GdmaI2sRx(I2S_RX_FIFO_RREG, (u32)ptri2s_config->pPage1RxBuf8ptr, 1, I2S_PAGE_SIZE, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#endif
+
+	return;
+}
+
+void i2s_dma_tx_end_handle(i2s_config_type* ptri2s_config)
+{
+	if (ptri2s_config->tx_w_idx < ptri2s_config->tx_r_idx)
+        {
+        	ptri2s_config->end_cnt = (ptri2s_config->tx_w_idx + MAX_I2S_PAGE)-ptri2s_config->tx_r_idx;
+                MSG("case1: w=%d, r=%d, end=%d\n", ptri2s_config->tx_w_idx, ptri2s_config->tx_r_idx, ptri2s_config->end_cnt);
+        }
+        else if (ptri2s_config->tx_w_idx > ptri2s_config->tx_r_idx)
+        {
+                ptri2s_config->end_cnt = ptri2s_config->tx_w_idx-ptri2s_config->tx_r_idx;
+                MSG("case2: w=%d, r=%d, end=%d\n", ptri2s_config->tx_w_idx, ptri2s_config->tx_r_idx, ptri2s_config->end_cnt);
+        }
+	else
+	{
+		MSG("case3: w=%d, r=%d, end=%d\n", ptri2s_config->tx_w_idx, ptri2s_config->tx_r_idx, ptri2s_config->end_cnt);
+		
+	}
+	if (ptri2s_config->end_cnt > 0)
+	{
+		interruptible_sleep_on(&(ptri2s_config->i2s_tx_qh));
+	}
+
+	return;
+}
+
+void i2s_tx_end_sleep_on(i2s_config_type* ptri2s_config)
+{
+	while(ptri2s_config->tx_stop_cnt<3)
+		interruptible_sleep_on(&(ptri2s_config->i2s_tx_qh));
+	
+	return;
+}
+
+void i2s_rx_end_sleep_on(i2s_config_type* ptri2s_config)
+{
+	while(ptri2s_config->rx_stop_cnt<2)
+		interruptible_sleep_on(&(ptri2s_config->i2s_rx_qh));
+	return;
+}
+
+int i2s_dma_tx_soft_stop(i2s_config_type* ptri2s_config, u32 dma_ch)
+{
+	if(dma_ch==GDMA_I2S_TX0)
+        {
+#if defined(ARM_ARCH)
+		GdmaI2sTx(i2s_txdma_addr0, I2S_TX_FIFO_WREG_PHY, 0, 4, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#else
+		GdmaI2sTx((u32)pi2s_config->pPage0TxBuf8ptr, I2S_TX_FIFO_WREG, 0, 4, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#endif
+        }
+        else
+        {
+#if defined(ARM_ARCH)
+		GdmaI2sTx(i2s_txdma_addr1, I2S_TX_FIFO_WREG_PHY, 1, 4, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#else
+                GdmaI2sTx((u32)pi2s_config->pPage1TxBuf8ptr, I2S_TX_FIFO_WREG, 1, 4, i2s_dma_tx_handler, i2s_dma_tx_unmask_handler);
+#endif
+        }
+
+	return 0;
+}
+
+int i2s_dma_rx_soft_stop(i2s_config_type* ptri2s_config, u32 dma_ch)
+{
+	if(dma_ch==GDMA_I2S_RX0)
+        {
+		memset(pi2s_config->pPage0RxBuf8ptr, 0, I2S_PAGE_SIZE);
+#if defined(ARM_ARCH)
+		GdmaI2sRx(I2S_RX_FIFO_RREG_PHY, i2s_rxdma_addr0, 0, 4, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#else
+		GdmaI2sRx(I2S_RX_FIFO_RREG, (u32)pi2s_config->pPage0RxBuf8ptr, 0, 4, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#endif
+        }
+        else
+        {
+		memset(pi2s_config->pPage1RxBuf8ptr, 0, I2S_PAGE_SIZE);
+#if defined(ARM_ARCH)
+		GdmaI2sRx(I2S_RX_FIFO_RREG_PHY, i2s_rxdma_addr1, 1, 4, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#else
+                GdmaI2sRx(I2S_RX_FIFO_RREG, (u32)pi2s_config->pPage1RxBuf8ptr, 1, 4, i2s_dma_rx_handler, i2s_dma_rx_unmask_handler);
+#endif
+        }
+
+	return 0;
+}
+
+void i2s_gen_test_pattern(void)
+{
+	int i;
+	for (i=0; i<I2S_PAGE_SIZE; i++)
+	{
+		test_buf[i] = 0x5A;
+		test_buf_1[i] = 0x11;
+		test_buf_2[i] = 0x22;
+
+	}
+}
+
+int i2s_put_audio(i2s_config_type* ptri2s_config, unsigned long arg)
+{
+	unsigned long flags;
+	int tx_w_idx;
+
+	do{
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+
+		if(((ptri2s_config->tx_w_idx+4)%MAX_I2S_PAGE)!=ptri2s_config->tx_r_idx)
+		{
+			ptri2s_config->tx_w_idx = (ptri2s_config->tx_w_idx+1)%MAX_I2S_PAGE;	
+			tx_w_idx = ptri2s_config->tx_w_idx;
+			spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+			//_printk("put TB[%d] for user write\n",ptri2s_config->tx_w_idx);
+#if defined(CONFIG_I2S_MMAP)
+			put_user(tx_w_idx, (int*)arg);
+#else
+			copy_from_user(ptri2s_config->pMMAPTxBufPtr[tx_w_idx], (char*)arg, I2S_PAGE_SIZE);
+#endif
+			pi2s_status->txbuffer_len++;
+			//spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+			break;
+		}
+		else
+		{
+			/* Buffer Full */
+			//_printk("TBF tr=%d, tw=%d\n", ptri2s_config->tx_r_idx, ptri2s_config->tx_w_idx);
+			pi2s_status->txbuffer_ovrun++;
+			spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+			interruptible_sleep_on(&(ptri2s_config->i2s_tx_qh));
+			if (ptri2s_config->bTxDMAEnable==0 && ptri2s_config->end_cnt==0)
+			{
+				_printk("wake up for exit i2s driver\n");
+				put_user(-1, (int*)arg);
+				break;
+			}
+		}
+	}while(1);
+
+	return 0;
+}
+
+int i2s_get_audio(i2s_config_type* ptri2s_config, unsigned long arg)
+{
+	unsigned long flags;
+	int rx_r_idx;
+
+	do{
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		//_printk("GA rr=%d, rw=%d,i=%d\n", ptri2s_config->rx_r_idx, ptri2s_config->rx_w_idx,ptri2s_config->rx_isr_cnt);
+		if(((ptri2s_config->rx_r_idx+2)%MAX_I2S_PAGE)!=ptri2s_config->rx_w_idx)
+		{			
+			rx_r_idx = ptri2s_config->rx_r_idx;
+			ptri2s_config->rx_r_idx = (ptri2s_config->rx_r_idx+1)%MAX_I2S_PAGE;
+			spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+#if defined(CONFIG_I2S_MMAP)
+			put_user(rx_r_idx, (int*)arg);
+#else
+			copy_to_user((char*)arg, ptri2s_config->pMMAPRxBufPtr[rx_r_idx], I2S_PAGE_SIZE);
+#endif
+			//_printk("rx_r_idx=%d\n", ptri2s_config->rx_r_idx);
+			//ptri2s_config->rx_r_idx = (ptri2s_config->rx_r_idx+1)%MAX_I2S_PAGE;
+			pi2s_status->rxbuffer_len--;
+			//spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+			break;
+		}
+		else
+		{
+			/* Buffer Full */
+			//_printk("RBF rr=%d, rw=%d\n", ptri2s_config->rx_r_idx, ptri2s_config->rx_w_idx);
+			pi2s_status->rxbuffer_ovrun++;
+			spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+			interruptible_sleep_on(&(ptri2s_config->i2s_rx_qh));
+		}
+#if defined(CONFIG_I2S_WITH_AEC)
+		if(aecFuncP->AECECDeq){
+			aecFuncP->AECECDeq(0,pi2s_config->pMMAPRxBufPtr[ptri2s_config->rx_r_idx],I2S_PAGE_SIZE);
+		}
+#endif
+	}while(1);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+long i2s_ioctl (struct file *filp, unsigned int cmd, unsigned long arg)
+#else
+int i2s_ioctl (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+#endif
+{
+	int i ;
+	i2s_config_type* ptri2s_config;
+	unsigned long flags;
+	    
+	ptri2s_config = filp->private_data;
+	switch (cmd) {
+	case I2S_RESET:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		i2s_reset_config(ptri2s_config);
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+	case I2S_SRATE:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+#if defined(CONFIG_I2S_WM8960)
+		if((arg>MAX_SRATE_HZ)||(arg<MIN_SRATE_HZ))
+		{
+			MSG("Audio sampling rate %u should be %d ~ %d Hz. Set SRate to 48000Hz\n", (u32)arg, MIN_SRATE_HZ, MAX_SRATE_HZ);
+			ptri2s_config->srate = 48000;
+			spin_unlock(&ptri2s_config->lock);
+			break;
+		}	
+#elif defined(CONFIG_I2S_WM8750)
+		if((arg>MAX_SRATE_HZ)||(arg<MIN_SRATE_HZ))
+		{
+			MSG("Audio sampling rate %u should be %d ~ %d Hz. Set SRate to 96000Hz\n", (u32)arg, MIN_SRATE_HZ, MAX_SRATE_HZ);
+			ptri2s_config->srate = 96000;
+			spin_unlock(&ptri2s_config->lock);
+			break;
+		}
+#endif
+		ptri2s_config->srate = arg;
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		MSG("set audio sampling rate to %d Hz\n", ptri2s_config->srate);
+		break;
+	case I2S_TX_VOL:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		
+		if((int)arg > 127)
+			ptri2s_config->txvol = 127;
+		else if((int)arg < 48)
+			ptri2s_config->txvol = 48;
+		else
+			ptri2s_config->txvol = arg;
+		
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+#if (defined(CONFIG_I2S_WM8750) || defined(CONFIG_I2S_WM8751))
+		audiohw_set_master_vol(arg,arg);
+#elif defined(CONFIG_I2S_WM8960)
+		audiohw_set_lineout_vol(1, ptri2s_config->txvol, ptri2s_config->txvol);
+#endif
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+	case I2S_RX_VOL:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		
+		if((int)arg > 63)
+			ptri2s_config->rxvol = 63;
+		else if((int)arg < 0)
+			ptri2s_config->rxvol = 0;
+		else
+			ptri2s_config->rxvol = arg;
+		
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+#if defined (CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+	case I2S_WORD_LEN:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		if((int)arg == 16)
+		{
+			ptri2s_config->wordlen_24b = 0;
+			MSG("Enable 16 bit word length.\n");
+		}
+		else if ((int)arg == 24)
+		{
+			ptri2s_config->wordlen_24b = 1;
+			MSG("Enable 24 bit word length.\n");
+		}
+		else
+		{
+			MSG("MT7628 only support 16bit/24bit word length.\n");
+			spin_unlock(&ptri2s_config->lock);
+			break;
+		}
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+	case I2S_ENDIAN_FMT:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		if((int)arg == 1)
+		{
+			ptri2s_config->little_edn = 1;
+			MSG("Little endian format.\n");
+		}
+		else 
+		{
+			ptri2s_config->little_edn = 0;
+			MSG("Big endian format.\n");
+		}
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;	
+#endif
+	case I2S_INTERNAL_LBK:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		if((int)arg == 1)
+		{
+			ptri2s_config->lbk = 1;
+			MSG("Enable internal loopback.\n");
+		}
+		else 
+		{
+			ptri2s_config->lbk = 0;
+			MSG("Disable internal loopback.\n");
+		}
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+	case I2S_EXTERNAL_LBK:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		if((int)arg == 1)
+		{
+			ptri2s_config->extlbk = 1;
+			MSG("Enable external loopback.\n");
+		}
+		else 
+		{
+			ptri2s_config->extlbk = 0;
+			MSG("Disable external loopback.\n");
+		}
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+	case I2S_TXRX_COEXIST:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		if((int)arg == 1)
+		{
+			ptri2s_config->txrx_coexist = 1;
+			MSG("TX/RX coexist.\n");
+		}
+		else 
+		{
+			ptri2s_config->txrx_coexist = 0;
+			MSG("TX/RX coexist.\n");
+		}
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+
+	case I2S_TX_ENABLE:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		MSG("I2S_TXENABLE\n");
+
+		pi2s_config->tx_unmask_ch = 0;
+		tasklet_init(&i2s_tx_tasklet, i2s_tx_task, (u32)pi2s_config);
+
+		pi2s_config->dis_match = 0;
+		pi2s_config->start_cnt = 0;
+		i2s_gen_test_pattern();
+
+		/* allocate tx buffer */
+		i2s_txPagebuf_alloc(ptri2s_config);
+		i2s_txbuf_alloc(ptri2s_config);
+	
+		/* Init two dma channels */
+		i2s_dma_tx_init(ptri2s_config);
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		/* Init & config all tx param */
+		i2s_reset_tx_param(ptri2s_config);
+		ptri2s_config->bTxDMAEnable = 1;
+		/* Clear all ALSA related config */
+		ptri2s_config->bALSAEnable = 0;
+		ptri2s_config->bALSAMMAPEnable = 0;
+
+		i2s_tx_config(ptri2s_config);
+	
+		if(ptri2s_config->bRxDMAEnable==0)
+			i2s_clock_enable(ptri2s_config);
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+	
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+#if defined(CONFIG_I2S_WM8960)||defined(CONFIG_I2S_WM8750)||defined(CONFIG_I2S_WM8751)
+		audiohw_set_lineout_vol(1, ptri2s_config->txvol, ptri2s_config->txvol);
+#endif
+		//GdmaUnMaskChannel(GDMA_I2S_TX0);
+
+		i2s_tx_enable(ptri2s_config);
+	
+		/* Kick off dma channel */	
+		GdmaUnMaskChannel(GDMA_I2S_TX0);
+
+		MSG("I2S_TXENABLE done\n");
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+	case I2S_TX_DISABLE:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		MSG("I2S_TXDISABLE\n");
+
+		//tasklet_kill(&i2s_tx_tasklet);
+
+		/* Handle tx end data */
+		ptri2s_config->bTxDMAEnable = 0;
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+
+		i2s_tx_end_sleep_on(ptri2s_config);
+	
+		tasklet_kill(&i2s_tx_tasklet);
+
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		i2s_reset_tx_param(ptri2s_config);
+		i2s_tx_disable(ptri2s_config);
+		if((ptri2s_config->bRxDMAEnable==0)&&(ptri2s_config->bTxDMAEnable==0))
+			i2s_clock_disable(ptri2s_config);
+	
+		i2s_txbuf_free(ptri2s_config);		
+		if(ptri2s_config->mmap_index <= MAX_I2S_PAGE)
+			ptri2s_config->mmap_index = 0;
+		
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+	case I2S_RX_ENABLE:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		MSG("I2S_RXENABLE\n");
+		pi2s_config->rx_unmask_ch = 0;
+		tasklet_init(&i2s_rx_tasklet, i2s_rx_task, (u32)pi2s_config);
+		
+		/* allocate rx buffer */
+		i2s_rxPagebuf_alloc(ptri2s_config);
+		i2s_rxbuf_alloc(ptri2s_config);	
+
+		/* Init two dma channels */
+		i2s_dma_rx_init(ptri2s_config);	
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		/* Init & config all rx param */
+		i2s_reset_rx_param(ptri2s_config);
+		ptri2s_config->bRxDMAEnable = 1;
+		ptri2s_config->bALSAEnable = 0;
+		ptri2s_config->bALSAMMAPEnable = 0;
+
+		i2s_rx_config(ptri2s_config);
+
+		if(ptri2s_config->bTxDMAEnable==0)
+			i2s_clock_enable(ptri2s_config);
+
+#if defined(CONFIG_I2S_TXRX)
+#if defined(CONFIG_I2S_WM8960)||defined(CONFIG_I2S_WM8750)||defined(CONFIG_I2S_WM8751)
+		audiohw_set_linein_vol(ptri2s_config->rxvol,  ptri2s_config->rxvol);
+#endif
+#endif
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		/* Kick off dma channel */
+		GdmaUnMaskChannel(GDMA_I2S_RX0);
+
+		i2s_rx_enable(ptri2s_config);
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+	case I2S_RX_DISABLE:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		MSG("I2S_RXDISABLE\n");
+		//tasklet_kill(&i2s_rx_tasklet);
+
+		ptri2s_config->bRxDMAEnable = 0;
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+
+		i2s_rx_end_sleep_on(ptri2s_config);		
+		tasklet_kill(&i2s_rx_tasklet);
+
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		i2s_reset_rx_param(ptri2s_config);
+		i2s_rx_disable(ptri2s_config);
+		if((ptri2s_config->bRxDMAEnable==0)&&(ptri2s_config->bTxDMAEnable==0))
+			i2s_clock_disable(ptri2s_config);
+		
+		i2s_rxbuf_free(ptri2s_config);
+		if(ptri2s_config->mmap_index <= MAX_I2S_PAGE)
+			ptri2s_config->mmap_index = 0;	
+		//i2s_rxPagebuf_free(ptri2s_config);
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+	case I2S_PUT_AUDIO:
+		i2s_put_audio(ptri2s_config, arg);		
+		break;
+	case I2S_GET_AUDIO:
+		i2s_get_audio(ptri2s_config, arg);
+		break;
+	case I2S_TX_STOP:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		MSG("TxGDMA STOP\n");
+		ptri2s_config->bTxDMAEnable = 0;
+		ptri2s_config->end_cnt = 0;
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+
+		while(ptri2s_config->tx_stop_cnt<3)
+                        interruptible_sleep_on(&(ptri2s_config->i2s_tx_qh));
+
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		i2s_reset_tx_param(ptri2s_config);
+		i2s_tx_disable(ptri2s_config);
+		if((ptri2s_config->bRxDMAEnable==0)&&(ptri2s_config->bTxDMAEnable==0))
+			i2s_clock_disable(ptri2s_config);
+		
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		i2s_txbuf_free(ptri2s_config);		
+		if(ptri2s_config->mmap_index <= MAX_I2S_PAGE)
+			ptri2s_config->mmap_index = 0;
+		//i2s_txPagebuf_free(ptri2s_config);
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+	case I2S_TX_PAUSE:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+                ptri2s_config->tx_pause_en = 1;
+		MSG("* tx_pause_en = 1 *\n");
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+                break;
+	case I2S_TX_RESUME:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+                ptri2s_config->tx_pause_en = 0;
+		MSG("# tx_pause_en = 0 #\n");
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+                break;
+	case I2S_RX_STOP:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		MSG("I2S_RX_STOP\n");
+		ptri2s_config->bRxDMAEnable = 0;
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+
+		while(ptri2s_config->rx_stop_cnt<2)
+                        interruptible_sleep_on(&(ptri2s_config->i2s_rx_qh));
+
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		i2s_reset_rx_param(ptri2s_config);
+		i2s_rx_disable(ptri2s_config);
+		if((ptri2s_config->bRxDMAEnable==0)&&(ptri2s_config->bTxDMAEnable==0))
+			i2s_clock_disable(ptri2s_config);
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		i2s_rxbuf_free(ptri2s_config);
+		if(ptri2s_config->mmap_index <= MAX_I2S_PAGE)
+			ptri2s_config->mmap_index = 0;	
+		//i2s_rxPagebuf_free(ptri2s_config);
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+	case I2S_RX_PAUSE:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+                ptri2s_config->rx_pause_en = 1;
+		MSG("* rx_pause_en = 1 *\n");
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+                break;
+	case I2S_RX_RESUME:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+                ptri2s_config->rx_pause_en = 0;
+		MSG("# rx_pause_en = 0 #\n");
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+                break;
+	case I2S_CODEC_MIC_BOOST:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		if((int)arg > 3)
+			ptri2s_config->micboost = 3;
+		else if((int)arg < 0)
+			ptri2s_config->micboost = 0;
+		else
+			ptri2s_config->micboost = arg;
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+	case I2S_CODEC_MIC_IN:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		if((int)arg == 1)
+			ptri2s_config->micin = 1;
+		else
+			ptri2s_config->micin = 0;
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+        case I2S_CLOCK_ENABLE:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+                i2s_clock_disable(ptri2s_config);
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+                ptri2s_config->wordlen_24b = 1;
+#endif
+                i2s_tx_config(ptri2s_config);
+                i2s_clock_enable(ptri2s_config);
+                i2s_tx_enable(ptri2s_config);
+                spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+                break;
+	case I2S_DEBUG_CODEC:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		for (i=0; i<10; i++)
+		{
+			_printk("### i=%d ###\n", i);
+			i2s_clock_enable(ptri2s_config);
+			i2s_clock_disable(ptri2s_config);
+		}
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+	      	break;
+#if defined(CONFIG_I2S_MS_CTRL)
+	case I2S_MS_MODE_CTRL:
+		spin_lock_irqsave(&ptri2s_config->lock, flags);
+		if((int)arg == 1)
+		{
+			ptri2s_config->slave_en = 1;
+			_printk("I2S in slave mode.\n");
+		}
+		else 
+		{
+			ptri2s_config->slave_en = 0;
+			_printk("I2S in master mode.\n");
+		}
+		spin_unlock_irqrestore(&ptri2s_config->lock, flags);
+		break;
+#endif
+	case I2S_DEBUG_CLKGEN:
+	case I2S_DEBUG_INLBK:
+	case I2S_DEBUG_EXLBK:
+	case I2S_DEBUG_CODECBYPASS:	
+	case I2S_DEBUG_FMT:
+#if defined(CONFIG_I2S_WM8960)
+	case I2S_DEBUG_CODEC_EXLBK:
+#endif
+	case I2S_DEBUG_RESET:
+		i2s_debug_cmd(cmd, arg);
+		break;							
+	default :
+		MSG("i2s_ioctl: command format error\n");
+	}
+
+	return 0;
+}
+
+/************************
+ *      API for ALSA    *
+ *                      *
+ ************************/
+char* i2s_memPool_Alloc(i2s_config_type* ptri2s_config,int dir)
+{
+        //_printk("%s\n",__func__);
+        if(!ptri2s_config)
+                return NULL;
+        if(dir == STREAM_PLAYBACK){
+			if(ptri2s_config->is_tx_mmap)
+				i2s_mmap_alloc(I2S_TOTAL_PAGE_SIZE,dir);
+			i2s_txbuf_alloc(ptri2s_config);
+					
+		return ptri2s_config->pMMAPTxBufPtr[0];
+        }else{
+        	if(ptri2s_config->is_rx_mmap)
+				i2s_mmap_alloc(I2S_TOTAL_PAGE_SIZE,dir);					
+			i2s_rxbuf_alloc(ptri2s_config);	
+		return ptri2s_config->pMMAPRxBufPtr[0];
+	}
+        return NULL;
+}
+
+void i2s_memPool_free(i2s_config_type* ptri2s_config,int dir)
+{
+        if(!ptri2s_config)
+                return;
+		MSG("is_tx_mmap:%d\n",ptri2s_config->is_tx_mmap);
+		MSG("is_rx_mmap:%d\n",ptri2s_config->is_rx_mmap);
+        if(dir == STREAM_PLAYBACK){
+			if(ptri2s_config->is_tx_mmap)
+				i2s_mem_unmap(ptri2s_config,dir);
+			i2s_txbuf_free(ptri2s_config);
+			
+        }else{
+        	if(ptri2s_config->is_rx_mmap)
+				i2s_mem_unmap(ptri2s_config,dir);
+			i2s_rxbuf_free(ptri2s_config);
+        }
+
+        return;
+}
+
+int i2s_page_prepare(i2s_config_type* ptri2s_config,int dir)
+{
+        if(dir == STREAM_PLAYBACK){
+                /* allocate tx buffer */
+                i2s_txPagebuf_alloc(ptri2s_config);
+		i2s_dma_tx_init(ptri2s_config);
+	}else{
+                /* allocate rx buffer */
+		i2s_rxPagebuf_alloc(ptri2s_config);
+		i2s_dma_rx_init(ptri2s_config);
+        }
+        return 0;
+}
+
+int i2s_page_release(i2s_config_type* ptri2s_config,int dir)
+{
+        if(!ptri2s_config)
+                return (-1);
+        if(dir == STREAM_PLAYBACK)
+		i2s_txPagebuf_free(ptri2s_config);
+        else
+		i2s_rxPagebuf_free(ptri2s_config);
+        
+	return 0;
+}
+
+int i2s_startup(void)
+{
+	MSG("%s*******************\n",__func__);
+
+	memset(pi2s_config, 0, sizeof(i2s_config_type));
+	
+#ifdef I2S_STATISTIC
+	memset(pi2s_status, 0, sizeof(i2s_status_type));	
+#endif
+
+	i2s_param_init(pi2s_config);
+	pi2s_config->bALSAEnable = 1;
+	
+
+
+#if defined (CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+	pi2s_config->little_edn = 1;
+#endif
+
+    	init_waitqueue_head(&(pi2s_config->i2s_tx_qh));
+    	init_waitqueue_head(&(pi2s_config->i2s_rx_qh));
+	spin_lock_init(&pi2s_config->lock);
+
+	return 0;
+}
+
+int gdma_En_Switch(i2s_config_type* ptri2s_config,int dir,int enabled){
+        if(!ptri2s_config)
+                return (-1);
+        if(dir == STREAM_PLAYBACK){
+                ptri2s_config->bTxDMAEnable = enabled;
+                //MSG("%s:%d\n",__func__,ptri2s_config->bTxDMAEnable);
+        }else{
+                ptri2s_config->bRxDMAEnable = enabled;
+				MSG("%s:%d\n",__func__,ptri2s_config->bRxDMAEnable);
+        }
+        return 0;
+}
+
+int i2s_audio_exchange(i2s_config_type* ptri2s_config,int dir,unsigned long arg)
+{
+        //MSG("I2S_PUT_AUDIO\n");
+        if(!ptri2s_config)
+                return (-1);
+        if(dir == STREAM_PLAYBACK){
+        	i2s_put_audio(ptri2s_config, arg);
+	}else{
+		i2s_get_audio(ptri2s_config, arg);
+        }
+        return 0;
+}
+
+void gdma_mask_handler(u32 dma_ch)
+{
+	i2s_dma_mask_handler(dma_ch);
+        return;
+}
+
+void gdma_unmask_handler(u32 dma_ch)
+{
+        i2s_dma_unmask_handler(dma_ch);
+	return;
+}
+
+u32 i2s_mmap_phys_addr(i2s_config_type* ptri2s_config,int dir)
+{
+	if((ptri2s_config->pMMAPBufPtr[0]!=NULL) && (dir == STREAM_PLAYBACK))
+		return (dma_addr_t)i2s_mmap_addr[0];
+	else if((ptri2s_config->pMMAPBufPtr[MAX_I2S_PAGE]!=NULL) && (dir == STREAM_CAPTURE))
+		return (dma_addr_t)i2s_mmap_addr[MAX_I2S_PAGE];
+	else
+		return -1;
+}
+
+EXPORT_SYMBOL(i2s_startup);
+EXPORT_SYMBOL(i2s_mem_unmap);
+EXPORT_SYMBOL(i2s_mmap_alloc);
+EXPORT_SYMBOL(i2s_mmap_remap);
+EXPORT_SYMBOL(i2s_param_init);
+EXPORT_SYMBOL(i2s_txbuf_alloc);
+EXPORT_SYMBOL(i2s_rxbuf_alloc);
+EXPORT_SYMBOL(i2s_txPagebuf_alloc);
+EXPORT_SYMBOL(i2s_rxPagebuf_alloc);
+EXPORT_SYMBOL(i2s_txbuf_free);
+EXPORT_SYMBOL(i2s_rxbuf_free);
+EXPORT_SYMBOL(i2s_txPagebuf_free);
+EXPORT_SYMBOL(i2s_rxPagebuf_free);
+EXPORT_SYMBOL(i2s_rx_disable);
+EXPORT_SYMBOL(i2s_tx_disable);
+EXPORT_SYMBOL(i2s_rx_enable);
+EXPORT_SYMBOL(i2s_tx_enable);
+EXPORT_SYMBOL(i2s_rx_config);
+EXPORT_SYMBOL(i2s_tx_config);
+EXPORT_SYMBOL(i2s_reset_config);
+EXPORT_SYMBOL(i2s_clock_disable);
+EXPORT_SYMBOL(i2s_clock_enable);
+EXPORT_SYMBOL(i2s_reset_rx_param);
+EXPORT_SYMBOL(i2s_reset_tx_param);
+EXPORT_SYMBOL(i2s_dma_rx_handler);
+EXPORT_SYMBOL(i2s_dma_tx_handler);
+EXPORT_SYMBOL(i2s_dma_unmask_handler);
+EXPORT_SYMBOL(i2s_dma_tx_unmask_handler);
+EXPORT_SYMBOL(i2s_dma_rx_unmask_handler);
+EXPORT_SYMBOL(i2s_dma_mask_handler);
+EXPORT_SYMBOL(i2s_dma_tx_init);
+EXPORT_SYMBOL(i2s_dma_rx_init);
+EXPORT_SYMBOL(i2s_tx_end_sleep_on);
+EXPORT_SYMBOL(i2s_rx_end_sleep_on);
+EXPORT_SYMBOL(i2s_mmap_phys_addr);
+EXPORT_SYMBOL(i2s_open);
+EXPORT_SYMBOL(pi2s_config);
+#if defined(CONFIG_I2S_IN_MCLK)
+#if defined(CONFIG_I2S_MCLK_12MHZ)
+EXPORT_SYMBOL(i2s_refclk_12m_enable);
+#endif
+#if defined(CONFIG_I2S_MCLK_12P288MHZ)
+EXPORT_SYMBOL(i2s_refclk_12p288m_enable);
+#endif
+#endif
+#if defined(MT7628_ASIC_BOARD) || defined(CONFIG_ARCH_MT7623)
+EXPORT_SYMBOL(i2s_driving_strength_adjust);
+#endif
+EXPORT_SYMBOL(i2s_refclk_disable);
+EXPORT_SYMBOL(i2s_refclk_gpio_out_config);
+EXPORT_SYMBOL(i2s_refclk_gpio_in_config);
+EXPORT_SYMBOL(i2s_share_pin_config);
+EXPORT_SYMBOL(i2s_share_pin_mt7623);
+EXPORT_SYMBOL(i2s_ws_config);
+EXPORT_SYMBOL(i2s_mode_config);
+EXPORT_SYMBOL(i2s_codec_frequency_config);
+EXPORT_SYMBOL(i2s_dma_tx_transf_data);
+EXPORT_SYMBOL(i2s_dma_tx_transf_zero);
+EXPORT_SYMBOL(i2s_dma_rx_transf_data);
+EXPORT_SYMBOL(i2s_dma_rx_transf_zero);
+EXPORT_SYMBOL(i2s_dma_tx_end_handle);
+EXPORT_SYMBOL(i2s_dma_tx_soft_stop);
+EXPORT_SYMBOL(i2s_dma_rx_soft_stop);
+EXPORT_SYMBOL(i2s_tx_task);
+EXPORT_SYMBOL(i2s_rx_task);
+
+EXPORT_SYMBOL(i2s_memPool_Alloc);
+EXPORT_SYMBOL(i2s_memPool_free);
+EXPORT_SYMBOL(i2s_page_prepare);
+EXPORT_SYMBOL(i2s_page_release);
+EXPORT_SYMBOL(gdma_En_Switch);
+EXPORT_SYMBOL(i2s_audio_exchange);
+EXPORT_SYMBOL(gdma_mask_handler);
+EXPORT_SYMBOL(gdma_unmask_handler);
+#if defined(CONFIG_I2S_WITH_AEC)
+EXPORT_SYMBOL(aecFuncP);
+#endif
+module_init(i2s_mod_init);
+module_exit(i2s_mod_exit);
+
+MODULE_DESCRIPTION("Ralink SoC I2S Controller Module");
+MODULE_AUTHOR("Qwert Chin <qwert.chin@ralinktech.com.tw>");
+MODULE_SUPPORTED_DEVICE("I2S");
+MODULE_VERSION(I2S_MOD_VERSION);
+MODULE_LICENSE("GPL");
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,12)
+MODULE_PARM (i2sdrv_major, "i");
+#else
+module_param (i2sdrv_major, int, 0);
+#endif
Index: linux-3.10.108/sound/soc/mtk/i2s_ctrl.h
===================================================================
--- /dev/null
+++ linux-3.10.108/sound/soc/mtk/i2s_ctrl.h
@@ -0,0 +1,529 @@
+#ifndef __RALINK_I2S_H_
+#define __RALINK_I2S_H_
+
+#ifdef __KERNEL__
+#include <asm/mach-ralink/rt_mmap.h>
+#endif
+
+#if defined(CONFIG_I2S_WITH_AEC)
+#include "aec/aec_api.h"
+#endif
+
+#define I2S_MAX_DEV			1
+#define I2S_MOD_VERSION			"0.1"
+#define phys_to_bus(a) (a & 0x1FFFFFFF)
+
+#ifndef u32
+#define u32 unsigned int
+#endif
+
+#ifndef u16
+#define u16 unsigned short
+#endif
+
+#ifndef u8
+#define u8 unsigned char
+#endif
+
+#ifndef REGBIT
+#define REGBIT(x, n)		(x << n)
+#endif
+
+#define Virtual2Physical(x)             (((int)x) & 0x1fffffff)
+#define Physical2Virtual(x)             (((int)x) | 0x80000000)
+#define Virtual2NonCache(x)             (((int)x) | 0x20000000)
+#define Physical2NonCache(x)            (((int)x) | 0xa0000000)
+#define NonCache2Virtual(x)             (((int)x) & 0xDFFFFFFF)
+
+#if defined(CONFIG_I2S_MCLK_12MHZ)
+#define CONFIG_I2S_CODEC_PLL_EN		1
+#else
+#define CONFIG_I2S_CODEC_PLL_EN		0
+#endif
+
+//#define CONFIG_I2S_MS_CTRL		
+#define CONFIG_I2S_MS_MODE
+//#define memory_test
+
+#if defined (CONFIG_ARCH_MT7623)
+#define MT7623_ASIC_BOARD
+#define ARM_ARCH
+#endif
+
+#if defined (CONFIG_RALINK_MT7621)
+#define MT7621_ASIC_BOARD
+#endif
+
+#if defined (CONFIG_RALINK_MT7628)
+#define MT7628_ASIC_BOARD
+#endif
+
+// #define I2S_DEBUG_PRN
+#ifdef I2S_DEBUG_PRN
+#define MSG(fmt, args...) printk("I2S: " fmt, ## args)
+#else
+#define MSG(fmt, args...) { }
+#endif
+
+#ifdef I2S_DEBUG_PRN
+#define i2s_outw(address, value)	do{printk("0x%08X = 0x%08X\n",(u32)address,(u32)value);*((volatile uint32_t *)(address)) = cpu_to_le32(value);}while(0)
+#else
+#define i2s_outw(address, value)    	*((volatile uint32_t *)(address)) = cpu_to_le32(value)
+#endif
+#define i2s_inw(address)		le32_to_cpu(*(volatile u32 *)(address))
+
+/* HW feature definiations */
+#if defined(CONFIG_RALINK_RT3883)
+#define CONFIG_I2S_TXRX			1
+#define CONFIG_I2S_IN_MCLK		1
+//#define CONFIG_I2S_WS_EDGE		1
+#define CONFIG_I2S_FRAC_DIV		1
+#define CONFIG_I2S_IN_CLK		1
+#define CONFIG_I2S_MS_MODE		1
+#endif
+
+#if defined(CONFIG_RALINK_RT3352)||defined(CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) \
+	|| defined(CONFIG_RALINK_RT6855A) || defined(CONFIG_RALINK_MT7620) || defined(CONFIG_RALINK_MT7621) \
+	|| defined (CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+#define CONFIG_I2S_TXRX			1
+//#define CONFIG_I2S_WS_EDGE		1
+#define CONFIG_I2S_FRAC_DIV		1
+#define CONFIG_I2S_IN_CLK		1
+#endif
+
+#if defined(CONFIG_RALINK_RT3350)
+#define CONFIG_I2S_IN_MCLK		1
+#endif
+
+#if defined(CONFIG_RALINK_RT3052)
+#define CONFIG_I2S_MS_MODE		1
+#endif
+
+/* This is decided in menuconfig */
+#define CONFIG_I2S_MMAP           	1
+
+/* For MT7623 ASIC PLL Setting */
+#if defined(CONFIG_ARCH_MT7623)
+#define AUD1PLL_CON0		(0xF0209270)
+#define AUD1PLL_CON1		(0xF0209274)
+#define AUD1PLL_CON2		(0xF0209278)
+#define AUD1PLL_PWR_CON0	(0xF020927C)
+#define AUD2PLL_CON0		(0xF02092C0)
+#define AUD2PLL_CON1		(0xF02092C4)
+#define AUD2PLL_CON2		(0xF02092C8)
+#define AUD2PLL_PWR_CON0	(0xF02092CC)
+#endif
+
+/* Register Map, Ref to RT3052 Data Sheet */
+
+/* Register Map Detail */
+#if defined(CONFIG_ARCH_MT7623)
+#define I2S_I2SCFG			(ETHDMASYS_I2S_BASE+0x0000)
+#define I2S_INT_STATUS			(ETHDMASYS_I2S_BASE+0x0004)
+#define I2S_INT_EN			(ETHDMASYS_I2S_BASE+0x0008)
+#define I2S_FF_STATUS			(ETHDMASYS_I2S_BASE+0x000c)
+#define I2S_FIFO_WREG			(ETHDMASYS_I2S_BASE+0x0010)
+#define I2S_TX_FIFO_WREG		I2S_FIFO_WREG
+#define I2S_RX_FIFO_RREG		(ETHDMASYS_I2S_BASE+0x0014)
+#define I2S_I2SCFG1			(ETHDMASYS_I2S_BASE+0x0018)
+#define I2S_DIVINT_CFG			(ETHDMASYS_I2S_BASE+0x0024)
+#define I2S_DIVCOMP_CFG			(ETHDMASYS_I2S_BASE+0x0020)
+#else
+#define I2S_I2SCFG			(RALINK_I2S_BASE+0x0000)
+#define I2S_INT_STATUS			(RALINK_I2S_BASE+0x0004)
+#define I2S_INT_EN			(RALINK_I2S_BASE+0x0008)
+#define I2S_FF_STATUS			(RALINK_I2S_BASE+0x000c)
+#define I2S_FIFO_WREG			(RALINK_I2S_BASE+0x0010)
+#define I2S_TX_FIFO_WREG		I2S_FIFO_WREG
+#define I2S_RX_FIFO_RREG		(RALINK_I2S_BASE+0x0014)
+#define I2S_I2SCFG1			(RALINK_I2S_BASE+0x0018)
+#define I2S_DIVINT_CFG			(RALINK_I2S_BASE+0x0024)
+#define I2S_DIVCOMP_CFG			(RALINK_I2S_BASE+0x0020)
+#endif
+
+
+/* I2SCFG bit field */
+#define I2S_EN			31
+#define I2S_DMA_EN		30
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+#define I2S_LITTLE_ENDIAN	29
+#define I2S_SYS_ENDIAN		28
+#elif defined(CONFIG_RALINK_RT6855A)
+#define I2S_BYTE_SWAP		28
+#endif
+#define I2S_TX_EN		24
+#define I2S_RX_EN		20
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+#define I2S_NORM_24BIT		18
+#define I2S_DATA_24BIT		17
+#endif
+#define I2S_SLAVE_MODE		16
+#define I2S_RX_FF_THRES		12
+#define I2S_RX_CH_SWAP		11
+#define I2S_RX_CH1_OFF		10
+#define I2S_RX_CH0_OFF		9
+#if defined(CONFIG_RALINK_RT3052)
+#define I2S_CLK_OUT_DIS		8
+#endif
+#define I2S_TX_FF_THRES		4
+#define I2S_TX_CH_SWAP		3
+#define I2S_TX_CH1_OFF		2
+#define I2S_TX_CH0_OFF		1
+#if defined(CONFIG_RALINK_RT3052)
+#define I2S_SLAVE_EN            0
+#else
+#define I2S_WS_INV		0
+#endif
+/* INT_EN bit field */
+#define I2S_RX_INT3_EN		7
+#define I2S_RX_INT2_EN		6
+#define I2S_RX_INT1_EN		5
+#define I2S_RX_INT0_EN		4
+#define I2S_TX_INT3_EN		3
+#define I2S_TX_INT2_EN		2
+#define I2S_TX_INT1_EN		1
+#define I2S_TX_INT0_EN		0
+
+/* INT_STATUS bit field */
+#define I2S_RX_DMA_FAULT	7
+#define I2S_RX_OVRUN		6
+#define I2S_RX_UNRUN		5
+#define I2S_RX_THRES		4
+#define I2S_TX_DMA_FAULT	3
+#define I2S_TX_OVRUN		2
+#define I2S_TX_UNRUN		1
+#define I2S_TX_THRES		0
+
+/* FF_STATUS bit field */
+#define I2S_RX_EPCNT		4
+#define I2S_TX_EPCNT		0
+/* I2S_DIVCOMP_CFG bit field */
+#define I2S_CLKDIV_EN		31
+
+/* I2S_CFG1 bit field */
+#define I2S_LBK_EN		31
+#define I2S_EXT_LBK_EN		30
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+#define I2S_DATA_FMT		0
+#endif
+
+/* FIFO_WREG bit field */
+#define I2S_FIFO_WDATA		0
+
+/* Constant definition */
+#define NFF_THRES		4
+//#define I2S_PAGE_SIZE		3072//(3*4096)//(1152*2*2*2)
+#define I2S_PAGE_SIZE		6144//(3*4096)//(1152*2*2*2)
+
+#define I2S_MIN_PAGE_SIZE	4096
+#define MAX_I2S_PAGE		8
+#define I2S_TOTAL_PAGE_SIZE 	(I2S_PAGE_SIZE*MAX_I2S_PAGE)
+
+#if defined(CONFIG_I2S_WM8960)
+#define MAX_SRATE_HZ            48000
+#define MIN_SRATE_HZ            8000
+#elif defined(CONFIG_I2S_WM8750)
+#define MAX_SRATE_HZ		96000
+#define MIN_SRATE_HZ		8000
+#endif
+
+#define MAX_VOL_DB		+0			
+#define MIN_VOL_DB		-127
+
+#define ALSA_MMAP_IDX_SHIFT	2
+#if defined(CONFIG_SND_MT76XX_SOC)
+#define STREAM_PLAYBACK		SNDRV_PCM_STREAM_PLAYBACK 
+#define STREAM_CAPTURE		SNDRV_PCM_STREAM_CAPTURE
+#else
+#define STREAM_PLAYBACK		0
+#define STREAM_CAPTURE		1
+#endif
+
+/* I2S I/O command */
+#define I2S_SRATE		0
+#define I2S_VOL			1
+#define I2S_ENABLE		2
+#define I2S_DISABLE		3
+#define I2S_TX_ENABLE		27
+#define I2S_TX_DISABLE		3
+#define I2S_GET_WBUF	 	4
+#define I2S_PUT_WBUF		5
+#define I2S_RX_ENABLE		6
+#define I2S_RX_DISABLE		7
+#define I2S_PUT_AUDIO		4
+#define I2S_GET_AUDIO		5
+#define I2S_TX_VOL		1
+#define I2S_RX_VOL		8
+#define I2S_WORD_LEN		9
+#define I2S_ENDIAN_FMT		10
+#define I2S_INTERNAL_LBK	11
+#define I2S_TX_STOP             12
+#define I2S_DEBUG_CODEC		13
+#define I2S_MS_MODE_CTRL	14
+#define I2S_TX_PAUSE		15
+#define I2S_TX_RESUME		16
+#define I2S_RESET		17
+#define I2S_RX_STOP		18
+#define I2S_EXTERNAL_LBK	19
+#define I2S_TXRX_COEXIST	20
+#define I2S_RX_PAUSE		21
+#define I2S_RX_RESUME		22
+#define I2S_CODEC_MIC_BOOST	23
+#define I2S_CODEC_MIC_IN	24
+#define I2S_CLOCK_ENABLE	25
+#define I2S_TEST_TEST		26
+
+#define I2S_DEBUG		30
+#define I2S_DEBUG_CLKGEN	30
+#define I2S_DEBUG_INLBK		31
+#define I2S_DEBUG_EXLBK		32
+#define I2S_DEBUG_FMT		33
+#define I2S_DEBUG_RESET		34
+#define I2S_DEBUG_CODECBYPASS	35
+#if defined(CONFIG_I2S_WM8960)
+#define I2S_DEBUG_CODEC_EXLBK	36
+#endif
+
+/* configuration */
+#define CONFIG_I2S_TFF_THRES	NFF_THRES
+#define CONFIG_I2S_CH_SWAP	0
+#if defined(CONFIG_I2S_MS_MODE)    
+#define CONFIG_I2S_SLAVE_EN	0
+#else
+#define CONFIG_I2S_SLAVE_EN	1
+#endif
+
+/* driver status definition */
+#define I2S_OK			0
+#define I2S_OUTOFMEM		0x01
+#define I2S_GDMAFAILED		0x02
+#define I2S_REQUEST_IRQ_FAILED	0x04
+#define I2S_REG_SETUP_FAILED	0x08
+
+#define I2S_STATISTIC
+//#define I2S_HW_INTERRUPT_EN
+//#define I2S_SW_IRQ_EN
+#define I2S_MAJOR		234
+
+/* parameter for ALSA */
+/*GDMA for I2S Status*/
+#define GDMA_I2S_DIS (0)
+#define GDMA_I2S_EN (1)
+
+
+typedef struct i2s_status_t
+{
+	u32 txdmafault;
+	u32 txovrun;
+	u32 txunrun;
+	u32 txthres;
+	int txbuffer_unrun;
+	int txbuffer_ovrun;
+	int txbuffer_len;
+	
+	u32 rxdmafault;
+	u32 rxovrun;
+	u32 rxunrun;
+	u32 rxthres;
+	int rxbuffer_unrun;
+	int rxbuffer_ovrun;
+	int rxbuffer_len;
+}i2s_status_type;
+
+
+typedef struct i2s_config_t
+{
+
+	int srate;
+	int txvol;
+	int rxvol;
+	u32 pos;
+	u32 tx_isr_cnt;
+	u32 rx_isr_cnt;
+	int bSleep;
+	int bTxDMAEnable;
+	int bRxDMAEnable;
+	int enLable;
+	int micboost;
+	int micin;
+	int is_tx_mmap;
+	int is_rx_mmap;
+	
+	/* parameters fo ALSA */
+	int bALSAEnable;
+	int bALSAMMAPEnable;
+	unsigned char bTrigger[2];
+	unsigned char bPreTrigger[2];
+	unsigned char dmaStat[2];
+	unsigned char i2sStat[2];
+	unsigned int hw_base_frame[2];
+	struct snd_pcm_substream *pss[2];
+
+#ifdef __KERNEL__		
+	spinlock_t lock;
+	wait_queue_head_t i2s_tx_qh, i2s_rx_qh;
+#endif
+	u32 dmach;
+	u32 tx_unmask_ch;
+	u32 rx_unmask_ch;
+	u32 dma_unmask_status;
+	u32 dma_done_status;   
+	u32 tx_ff_thres;
+	u32 tx_ch_swap;
+	u32 rx_ff_thres;
+	u32 rx_ch_swap;
+	u32 slave_en;
+
+	u32 dis_match;
+	int start_cnt;
+#if defined (CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+	int little_edn;  /* test file's fmt: little endian->1; big endian->0 */
+        int sys_endian;  /* kernal' system fmt: little endian->0; big endian->1 */	
+#endif
+	int wordlen_24b;
+	int codec_pll_en;
+	int codec_num;
+	int tx_pause_en;
+	int rx_pause_en;
+	int end_cnt;
+	int txrx_coexist;
+	int tx_stop_cnt;
+	int rx_stop_cnt;
+	/* for I2S_CFG1 */
+	u32 lbk;
+	u32 extlbk;
+	u32 fmt;
+	
+	int w_idx;
+	int r_idx;
+	
+	int tx_w_idx;
+	int tx_r_idx;
+	int rx_w_idx;
+	int rx_r_idx;
+	int mmap_index;
+	int next_p0_idx;
+	int next_p1_idx;
+	
+	u8* buf8ptr;	
+	char* pMMAPBufPtr[MAX_I2S_PAGE*2];	
+	char* pMMAPTxBufPtr[MAX_I2S_PAGE];
+	char* pMMAPRxBufPtr[MAX_I2S_PAGE];
+	
+	union {
+		u16* pPage0TxBuf16Ptr;	
+		u8* pPage0TxBuf8ptr;	
+	};
+	union {
+		u16* pPage1TxBuf16Ptr;	
+		u8* pPage1TxBuf8ptr;	
+	};
+		
+	union {
+		u16* pPage0RxBuf16Ptr;	
+		u8* pPage0RxBuf8ptr;	
+	};
+	union {
+		u16* pPage1RxBuf16Ptr;	
+		u8* pPage1RxBuf8ptr;	
+	};
+
+}i2s_config_type;
+
+int i2s_mmap_alloc(unsigned long size,int dir);
+
+void i2s_gen_test_pattern(void);
+int i2s_mem_unmap(i2s_config_type* ptri2s_config,int dir);
+int i2s_param_init(i2s_config_type* ptri2s_config);
+int i2s_txbuf_alloc(i2s_config_type* ptri2s_config);
+int i2s_rxbuf_alloc(i2s_config_type* ptri2s_config);
+int i2s_txPagebuf_alloc(i2s_config_type* ptri2s_config);
+int i2s_rxPagebuf_alloc(i2s_config_type* ptri2s_config);
+int i2s_txbuf_free(i2s_config_type* ptri2s_config);
+int i2s_rxbuf_free(i2s_config_type* ptri2s_config);
+int i2s_txPagebuf_free(i2s_config_type* ptri2s_config);
+int i2s_rxPagebuf_free(i2s_config_type* ptri2s_config);
+int i2s_reset_tx_param(i2s_config_type* ptri2s_config);
+int i2s_reset_rx_param(i2s_config_type* ptri2s_config);
+int i2s_tx_config(i2s_config_type* ptri2s_config);
+int i2s_rx_config(i2s_config_type* ptri2s_config);
+int i2s_tx_enable(i2s_config_type* ptri2s_config);
+int i2s_tx_disable(i2s_config_type* ptri2s_config);
+int i2s_rx_enable(i2s_config_type* ptri2s_config);
+int i2s_rx_disable(i2s_config_type* ptri2s_config);
+int i2s_codec_enable(i2s_config_type* ptri2s_config);
+int i2s_codec_disable(i2s_config_type* ptri2s_config);
+int i2s_clock_enable(i2s_config_type* ptri2s_config);
+int i2s_clock_disable(i2s_config_type* ptri2s_config);
+int i2s_reset_config(i2s_config_type* ptri2s_config);
+int i2s_refclk_disable(void);
+int i2s_refclk_gpio_out_config(void);
+int i2s_refclk_gpio_in_config(void);
+int i2s_share_pin_config(i2s_config_type* ptri2s_config);
+int i2s_share_pin_mt7623(i2s_config_type* ptri2s_config);
+int i2s_master_clock_gpio_out_mt7623(void);
+int i2s_slave_clock_gpio_in_mt7623(void);
+int i2s_ws_config(i2s_config_type* ptri2s_config, unsigned long index);
+int i2s_mode_config(u32 slave_en);
+int i2s_codec_frequency_config(i2s_config_type* ptri2s_config, unsigned long index);
+void i2s_tx_end_sleep_on(i2s_config_type* ptri2s_config);
+void i2s_rx_end_sleep_on(i2s_config_type* ptri2s_config);
+
+#if defined(CONFIG_I2S_MCLK_12MHZ)
+int i2s_refclk_12m_enable(void);
+#endif
+#if defined(CONFIG_I2S_MCLK_12P288MHZ)
+int i2s_refclk_12p288m_enable(void);
+#endif
+
+#if defined(MT7621_ASIC_BOARD)
+int i2s_pll_config_mt7621(unsigned long index);
+int i2s_pll_refclk_set(void);
+#endif
+#if defined(MT7623_ASIC_BOARD)
+int i2s_pll_config_mt7623(unsigned long index);
+#endif
+#if defined(MT7628_ASIC_BOARD) || defined(CONFIG_ARCH_MT7623)
+int i2s_driving_strength_adjust(void);
+#endif
+#if defined(I2S_STATISTIC)
+void i2s_int_status(u32 dma_ch);
+#endif
+void i2s_dma_tx_handler(u32 dma_ch);
+void i2s_dma_rx_handler(u32 dma_ch);
+void i2s_dma_unmask_handler(u32 dma_ch);
+void i2s_dma_mask_handler(u32 dma_ch);
+void i2s_dma_tx_init(i2s_config_type* ptri2s_config);
+void i2s_dma_rx_init(i2s_config_type* ptri2s_config);
+void i2s_tx_task(unsigned long pData);
+void i2s_rx_task(unsigned long pData);
+void i2s_dma_tx_unmask_handler(u32 dma_ch);
+void i2s_dma_rx_unmask_handler(u32 dma_ch);
+int i2s_dma_tx_transf_data(i2s_config_type* ptri2s_config, u32 dma_ch);
+int i2s_dma_tx_transf_zero(i2s_config_type* ptri2s_config, u32 dma_ch);
+int i2s_dma_rx_transf_data(i2s_config_type* ptri2s_config, u32 dma_ch);
+int i2s_dma_rx_transf_zero(i2s_config_type* ptri2s_config, u32 dma_ch);
+void i2s_dma_tx_end_handle(i2s_config_type* ptri2s_config);
+int i2s_dma_tx_soft_stop(i2s_config_type* ptri2s_config, u32 dma_ch);
+int i2s_dma_rx_soft_stop(i2s_config_type* ptri2s_config, u32 dma_ch);
+
+int i2s_page_prepare(i2s_config_type* ptri2s_config,int dir);
+int i2s_page_release(i2s_config_type* ptri2s_config,int dir);
+int gdma_En_Switch(i2s_config_type* ptri2s_config,int dir,int enabled);
+int i2s_startup(void);
+int i2s_audio_exchange(i2s_config_type* ptri2s_config,int dir,unsigned long arg);
+void gdma_unmask_handler(u32 dma_ch);
+char* i2s_memPool_Alloc(i2s_config_type* ptri2s_config,int dir);
+void i2s_memPool_free(i2s_config_type* ptri2s_config,int dir);
+u32 i2s_mmap_phys_addr(i2s_config_type* ptri2s_config,int dir);
+
+
+#if !defined(CONFIG_I2S_TXRX)
+#define GdmaI2sRx	//GdmaI2sRx
+#endif
+
+#define RALINK_I2S_VERSION	"1.0"
+#define I2SDRV_DEVNAME		"i2s0"
+
+#endif /* __RALINK_I2S_H_ */
+
Index: linux-3.10.108/sound/soc/mtk/i2s_debug.c
===================================================================
--- /dev/null
+++ linux-3.10.108/sound/soc/mtk/i2s_debug.c
@@ -0,0 +1,698 @@
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h> /* printk() */
+#include "i2s_ctrl.h"
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/random.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h> /* copy_from/to_user */
+
+#if defined(CONFIG_SND_RALINK_SOC)
+#include <sound/soc/mtk/mtk_audio_device.h>
+#endif
+
+#if defined(CONFIG_I2S_WM8750)
+#include "../codec/i2c_wm8750.h"
+#endif
+#if defined(CONFIG_I2S_WM8751)
+#include "../codec/i2c_wm8751.h"
+#endif
+#if defined(CONFIG_I2S_WM8960)
+#include "i2c_wm8960.h"
+#endif
+
+
+//#define INTERNAL_LOOPBACK_DEBUG
+
+extern unsigned long i2s_codec_12p288Mhz[11];
+extern unsigned long i2s_codec_12Mhz[11]; 
+#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+extern unsigned long i2s_inclk_int_16bit[13];
+extern unsigned long i2s_inclk_comp_16bit[13];
+extern unsigned long i2s_inclk_int_24bit[13];
+extern unsigned long i2s_inclk_comp_24bit[13];
+#else
+extern unsigned long i2s_inclk_int[11];
+extern unsigned long i2s_inclk_comp[11];
+#endif
+extern int i2s_pll_config_mt7621(unsigned long index);
+extern int i2s_pll_config_mt7623(unsigned long index);
+
+#if defined(CONFIG_I2S_WM8960) || defined(CONFIG_I2S_WM8750) || defined(CONFIG_I2S_WM8751)
+extern void audiohw_loopback(int fsel);
+extern void audiohw_bypass(void);
+extern int audiohw_set_lineout_vol(int Aout, int vol_l, int vol_r);
+extern int audiohw_set_linein_vol(int vol_l, int vol_r);
+#endif
+
+#if defined(CONFIG_I2S_WM8960)
+extern void audiohw_codec_exlbk(void);
+#endif
+
+unsigned long txbuffer[512] = {
+				0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f10, 0x11121314, 0x15161718, 0x191a1b1c, 0x1d1e1f20,
+			       	0x21222324, 0x25262728, 0x292a2b2c, 0x2d2e2f30, 0x31323334, 0x35363738, 0x393a3b3c, 0x3d3e3f40,
+				0x41424344, 0x45464748, 0x494a4b4c, 0x4d4e4f50, 0x51525354, 0x55565758, 0x595a5b5c, 0x5d5e5f60,
+				0x61626364, 0x65666768, 0x696a6b6c, 0x6d6e6f70, 0x71727374, 0x75767778, 0x797a7b7c, 0x7d7e7f80,
+				0x81828384, 0x85868788, 0x898a8b8c, 0x8d8e8f90, 0x91929394, 0x95969798, 0x999a9b9c, 0x9d9e9fa0,
+				0xa1a2a3a4, 0xa5a6a7a8, 0xa9aaabac, 0xadaeafb0, 0xb1b2b3b4, 0xb5b6b7b8, 0xb9babbbc, 0xbdbebfc0,
+				0xc1c2c3c4, 0xc5c6c7c8, 0xc9cacbcc, 0xcdcecfd0, 0xd1d2d3d4, 0xd5d6d7d8, 0xd9dadbdc, 0xdddedfe0,
+				0xe1e2e3e4, 0xe5e6e7e8, 0xe9eaebec, 0xedeeeff0, 0xf1f2f3f4, 0xf5f6f7f8, 0xf9fafbfc, 0xfdfeff00, //round 1
+0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f10, 0x11121314, 0x15161718, 0x191a1b1c, 0x1d1e1f20,
+			       	0x21222324, 0x25262728, 0x292a2b2c, 0x2d2e2f30, 0x31323334, 0x35363738, 0x393a3b3c, 0x3d3e3f40,
+				0x41424344, 0x45464748, 0x494a4b4c, 0x4d4e4f50, 0x51525354, 0x55565758, 0x595a5b5c, 0x5d5e5f60,
+				0x61626364, 0x65666768, 0x696a6b6c, 0x6d6e6f70, 0x71727374, 0x75767778, 0x797a7b7c, 0x7d7e7f80,
+				0x81828384, 0x85868788, 0x898a8b8c, 0x8d8e8f90, 0x91929394, 0x95969798, 0x999a9b9c, 0x9d9e9fa0,
+				0xa1a2a3a4, 0xa5a6a7a8, 0xa9aaabac, 0xadaeafb0, 0xb1b2b3b4, 0xb5b6b7b8, 0xb9babbbc, 0xbdbebfc0,
+				0xc1c2c3c4, 0xc5c6c7c8, 0xc9cacbcc, 0xcdcecfd0, 0xd1d2d3d4, 0xd5d6d7d8, 0xd9dadbdc, 0xdddedfe0,
+				0xe1e2e3e4, 0xe5e6e7e8, 0xe9eaebec, 0xedeeeff0, 0xf1f2f3f4, 0xf5f6f7f8, 0xf9fafbfc, 0xfdfeff00, //round 2
+0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f10, 0x11121314, 0x15161718, 0x191a1b1c, 0x1d1e1f20,
+			       	0x21222324, 0x25262728, 0x292a2b2c, 0x2d2e2f30, 0x31323334, 0x35363738, 0x393a3b3c, 0x3d3e3f40,
+				0x41424344, 0x45464748, 0x494a4b4c, 0x4d4e4f50, 0x51525354, 0x55565758, 0x595a5b5c, 0x5d5e5f60,
+				0x61626364, 0x65666768, 0x696a6b6c, 0x6d6e6f70, 0x71727374, 0x75767778, 0x797a7b7c, 0x7d7e7f80,
+				0x81828384, 0x85868788, 0x898a8b8c, 0x8d8e8f90, 0x91929394, 0x95969798, 0x999a9b9c, 0x9d9e9fa0,
+				0xa1a2a3a4, 0xa5a6a7a8, 0xa9aaabac, 0xadaeafb0, 0xb1b2b3b4, 0xb5b6b7b8, 0xb9babbbc, 0xbdbebfc0,
+				0xc1c2c3c4, 0xc5c6c7c8, 0xc9cacbcc, 0xcdcecfd0, 0xd1d2d3d4, 0xd5d6d7d8, 0xd9dadbdc, 0xdddedfe0,
+				0xe1e2e3e4, 0xe5e6e7e8, 0xe9eaebec, 0xedeeeff0, 0xf1f2f3f4, 0xf5f6f7f8, 0xf9fafbfc, 0xfdfeff00, //round 3
+0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f10, 0x11121314, 0x15161718, 0x191a1b1c, 0x1d1e1f20,
+			       	0x21222324, 0x25262728, 0x292a2b2c, 0x2d2e2f30, 0x31323334, 0x35363738, 0x393a3b3c, 0x3d3e3f40,
+				0x41424344, 0x45464748, 0x494a4b4c, 0x4d4e4f50, 0x51525354, 0x55565758, 0x595a5b5c, 0x5d5e5f60,
+				0x61626364, 0x65666768, 0x696a6b6c, 0x6d6e6f70, 0x71727374, 0x75767778, 0x797a7b7c, 0x7d7e7f80,
+				0x81828384, 0x85868788, 0x898a8b8c, 0x8d8e8f90, 0x91929394, 0x95969798, 0x999a9b9c, 0x9d9e9fa0,
+				0xa1a2a3a4, 0xa5a6a7a8, 0xa9aaabac, 0xadaeafb0, 0xb1b2b3b4, 0xb5b6b7b8, 0xb9babbbc, 0xbdbebfc0,
+				0xc1c2c3c4, 0xc5c6c7c8, 0xc9cacbcc, 0xcdcecfd0, 0xd1d2d3d4, 0xd5d6d7d8, 0xd9dadbdc, 0xdddedfe0,
+				0xe1e2e3e4, 0xe5e6e7e8, 0xe9eaebec, 0xedeeeff0, 0xf1f2f3f4, 0xf5f6f7f8, 0xf9fafbfc, 0xfdfeff00, //round 4
+0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f10, 0x11121314, 0x15161718, 0x191a1b1c, 0x1d1e1f20,
+			       	0x21222324, 0x25262728, 0x292a2b2c, 0x2d2e2f30, 0x31323334, 0x35363738, 0x393a3b3c, 0x3d3e3f40,
+				0x41424344, 0x45464748, 0x494a4b4c, 0x4d4e4f50, 0x51525354, 0x55565758, 0x595a5b5c, 0x5d5e5f60,
+				0x61626364, 0x65666768, 0x696a6b6c, 0x6d6e6f70, 0x71727374, 0x75767778, 0x797a7b7c, 0x7d7e7f80,
+				0x81828384, 0x85868788, 0x898a8b8c, 0x8d8e8f90, 0x91929394, 0x95969798, 0x999a9b9c, 0x9d9e9fa0,
+				0xa1a2a3a4, 0xa5a6a7a8, 0xa9aaabac, 0xadaeafb0, 0xb1b2b3b4, 0xb5b6b7b8, 0xb9babbbc, 0xbdbebfc0,
+				0xc1c2c3c4, 0xc5c6c7c8, 0xc9cacbcc, 0xcdcecfd0, 0xd1d2d3d4, 0xd5d6d7d8, 0xd9dadbdc, 0xdddedfe0,
+				0xe1e2e3e4, 0xe5e6e7e8, 0xe9eaebec, 0xedeeeff0, 0xf1f2f3f4, 0xf5f6f7f8, 0xf9fafbfc, 0xfdfeff00, //round 5
+0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f10, 0x11121314, 0x15161718, 0x191a1b1c, 0x1d1e1f20,
+			       	0x21222324, 0x25262728, 0x292a2b2c, 0x2d2e2f30, 0x31323334, 0x35363738, 0x393a3b3c, 0x3d3e3f40,
+				0x41424344, 0x45464748, 0x494a4b4c, 0x4d4e4f50, 0x51525354, 0x55565758, 0x595a5b5c, 0x5d5e5f60,
+				0x61626364, 0x65666768, 0x696a6b6c, 0x6d6e6f70, 0x71727374, 0x75767778, 0x797a7b7c, 0x7d7e7f80,
+				0x81828384, 0x85868788, 0x898a8b8c, 0x8d8e8f90, 0x91929394, 0x95969798, 0x999a9b9c, 0x9d9e9fa0,
+				0xa1a2a3a4, 0xa5a6a7a8, 0xa9aaabac, 0xadaeafb0, 0xb1b2b3b4, 0xb5b6b7b8, 0xb9babbbc, 0xbdbebfc0,
+				0xc1c2c3c4, 0xc5c6c7c8, 0xc9cacbcc, 0xcdcecfd0, 0xd1d2d3d4, 0xd5d6d7d8, 0xd9dadbdc, 0xdddedfe0,
+				0xe1e2e3e4, 0xe5e6e7e8, 0xe9eaebec, 0xedeeeff0, 0xf1f2f3f4, 0xf5f6f7f8, 0xf9fafbfc, 0xfdfeff00, //round 6
+0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f10, 0x11121314, 0x15161718, 0x191a1b1c, 0x1d1e1f20,
+			       	0x21222324, 0x25262728, 0x292a2b2c, 0x2d2e2f30, 0x31323334, 0x35363738, 0x393a3b3c, 0x3d3e3f40,
+				0x41424344, 0x45464748, 0x494a4b4c, 0x4d4e4f50, 0x51525354, 0x55565758, 0x595a5b5c, 0x5d5e5f60,
+				0x61626364, 0x65666768, 0x696a6b6c, 0x6d6e6f70, 0x71727374, 0x75767778, 0x797a7b7c, 0x7d7e7f80,
+				0x81828384, 0x85868788, 0x898a8b8c, 0x8d8e8f90, 0x91929394, 0x95969798, 0x999a9b9c, 0x9d9e9fa0,
+				0xa1a2a3a4, 0xa5a6a7a8, 0xa9aaabac, 0xadaeafb0, 0xb1b2b3b4, 0xb5b6b7b8, 0xb9babbbc, 0xbdbebfc0,
+				0xc1c2c3c4, 0xc5c6c7c8, 0xc9cacbcc, 0xcdcecfd0, 0xd1d2d3d4, 0xd5d6d7d8, 0xd9dadbdc, 0xdddedfe0,
+				0xe1e2e3e4, 0xe5e6e7e8, 0xe9eaebec, 0xedeeeff0, 0xf1f2f3f4, 0xf5f6f7f8, 0xf9fafbfc, 0xfdfeff00, //round 7
+0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f10, 0x11121314, 0x15161718, 0x191a1b1c, 0x1d1e1f20,
+			       	0x21222324, 0x25262728, 0x292a2b2c, 0x2d2e2f30, 0x31323334, 0x35363738, 0x393a3b3c, 0x3d3e3f40,
+				0x41424344, 0x45464748, 0x494a4b4c, 0x4d4e4f50, 0x51525354, 0x55565758, 0x595a5b5c, 0x5d5e5f60,
+				0x61626364, 0x65666768, 0x696a6b6c, 0x6d6e6f70, 0x71727374, 0x75767778, 0x797a7b7c, 0x7d7e7f80,
+				0x81828384, 0x85868788, 0x898a8b8c, 0x8d8e8f90, 0x91929394, 0x95969798, 0x999a9b9c, 0x9d9e9fa0,
+				0xa1a2a3a4, 0xa5a6a7a8, 0xa9aaabac, 0xadaeafb0, 0xb1b2b3b4, 0xb5b6b7b8, 0xb9babbbc, 0xbdbebfc0,
+				0xc1c2c3c4, 0xc5c6c7c8, 0xc9cacbcc, 0xcdcecfd0, 0xd1d2d3d4, 0xd5d6d7d8, 0xd9dadbdc, 0xdddedfe0,
+				0xe1e2e3e4, 0xe5e6e7e8, 0xe9eaebec, 0xedeeeff0, 0xf1f2f3f4, 0xf5f6f7f8, 0xf9fafbfc, 0xfdfeff00  //round 8
+				};
+
+int i2s_debug_cmd(unsigned int cmd, unsigned long arg)
+{
+	unsigned long data, index;
+	unsigned long *pTable;
+	int i;
+
+	switch(cmd)
+	{
+		case I2S_DEBUG_CLKGEN:
+			MSG("I2S_DEBUG_CLKGEN\n");
+#if defined(CONFIG_RALINK_RT3052)
+			*(volatile unsigned long*)(0xB0000060) = 0x00000016;
+			*(volatile unsigned long*)(0xB0000030) = 0x00009E00;
+			*(volatile unsigned long*)(0xB0000A00) = 0xC0000040;
+#elif defined(CONFIG_RALINK_RT3350)		
+			*(volatile unsigned long*)(0xB0000060) = 0x00000018;
+			*(volatile unsigned long*)(0xB000002C) = 0x00000100;
+			*(volatile unsigned long*)(0xB0000030) = 0x00009E00;
+			*(volatile unsigned long*)(0xB0000A00) = 0xC0000040;			
+#elif defined(CONFIG_RALINK_RT3883)	
+			*(volatile unsigned long*)(0xB0000060) = 0x00000018;
+			*(volatile unsigned long*)(0xB000002C) = 0x00003000;
+			*(volatile unsigned long*)(0xB0000A00) = 0xC1104040;
+			*(volatile unsigned long*)(0xB0000A24) = 0x00000027;
+			*(volatile unsigned long*)(0xB0000A20) = 0x80000020;
+#elif (defined(CONFIG_RALINK_RT3352)||defined(CONFIG_RALINK_RT5350)) || defined (CONFIG_RALINK_RT6855)
+			*(volatile unsigned long*)(0xB0000060) = 0x00000018;
+			*(volatile unsigned long*)(0xB000002C) = 0x00000300;
+			*(volatile unsigned long*)(0xB0000A00) = 0xC1104040;
+			*(volatile unsigned long*)(0xB0000A24) = 0x00000027;
+			*(volatile unsigned long*)(0xB0000A20) = 0x80000020;			
+#elif defined(CONFIG_RALINK_RT6855A)
+			*(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x860) = 0x00008080;
+			*(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x82C) = 0x00000300;
+			*(volatile unsigned long*)(RALINK_I2S_BASE+0x00) = 0xC1104040;
+			*(volatile unsigned long*)(RALINK_I2S_BASE+0x24) = 0x00000027;
+			*(volatile unsigned long*)(RALINK_I2S_BASE+0x20) = 0x80000020;	
+#else
+//#error "I2S debug mode not support this Chip"			
+#endif			
+			break;
+		case I2S_DEBUG_INLBK:
+			MSG("I2S_DEBUG_INLBK\n");
+#if defined(CONFIG_RALINK_MT7621)
+                        switch(96000)
+                        {
+                                case 8000:
+                                        index = 0;
+                                        break;
+                                case 11025:
+                                        index = 1;
+                                        break;
+                                case 12000:
+                                        index = 2;
+                                        break;
+                                case 16000:
+                                        index = 3;
+                                        break;
+                                case 22050:
+                                        index = 4;
+                                        break;
+                                case 24000:
+                                        index = 5;
+                                        break;
+                                case 32000:
+                                        index = 6;
+                                        break;
+                                case 44100:
+                                        index = 7;
+                                        break;
+                                case 48000:
+                                        index = 8;
+                                        break;
+                                case 88200:
+                                        index = 9;
+                                        break;
+                                case 96000:
+                                        index = 10;
+                                        break;
+				case 192000:
+                                        index = 11;
+                                        break;
+                                default:
+                                        index = 7;
+                        }
+                        i2s_pll_config_mt7621(index);
+#elif defined(CONFIG_ARCH_MT7623)
+			i2s_pll_config_mt7623(11);
+#endif
+
+
+#if defined(CONFIG_RALINK_RT3052)
+			break;
+#endif
+#if defined(CONFIG_RALINK_RT6855A)
+			*(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x834) |= 0x00020000;
+			*(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x834) &= 0xFFFDFFFF;	
+			*(volatile unsigned long*)(RALINK_I2S_BASE+0x0) &= 0x7FFFFFFF;	//Rest I2S to default vaule	
+			*(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x860) |= 0x00008080;
+			*(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x82C) = 0x00000300;
+#elif defined(CONFIG_RALINK_MT7621)
+                        *(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x34) |= 0x00020000;
+                        *(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x34) &= 0xFFFDFFFF;
+                        *(volatile unsigned long*)(RALINK_I2S_BASE+0x0) &= 0x7FFFFFFF;   //Rest I2S to default vaule
+                        *(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x60) = 0x00000010;     //GPIO purpose selection
+#elif defined(CONFIG_RALINK_MT7628)
+                        *(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x34) |= 0x00020000;
+                        *(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x34) &= 0xFFFDFFFF;
+                        *(volatile unsigned long*)(RALINK_I2S_BASE+0x0) &= 0x7FFFFFFF;   //Rest I2S to default vaule
+                        *(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x60) &= ~((0x3)<<6);     //GPIO purpose selection /*FIXME*/
+#elif defined(CONFIG_ARCH_MT7623)
+			*(volatile unsigned long*)(0xFB000034) |= 0x00020000;
+			*(volatile unsigned long*)(0xFB000034) &= 0xFFFDFFFF;
+			*(volatile unsigned long*)(ETHDMASYS_I2S_BASE+0x0) &= 0x7FFFFFFF;   //Rest I2S to default vaule
+			
+			*(volatile unsigned long*)(0xF0005840) &= ~((0x7)<<12);
+			*(volatile unsigned long*)(0xF0005840) |= ((0x6)<<12);
+			*(volatile unsigned long*)(0xF0005840) &= ~((0x7)<<9);
+			*(volatile unsigned long*)(0xF0005840) |= ((0x6)<<9);
+			*(volatile unsigned long*)(0xF0005040) |= ((0x1)<<10);
+			*(volatile unsigned long*)(0xF0005040) |= ((0x1)<<9);
+
+			*(volatile unsigned long*)(0xF00057F0) &= ~((0x7)<<12);
+			*(volatile unsigned long*)(0xF00057F0) |= ((0x6)<<12);
+			*(volatile unsigned long*)(0xF0005030) |= ((0x1)<<1);
+
+			*(volatile unsigned long*)(0xF0005840) &= ~((0x7)<<6);
+			*(volatile unsigned long*)(0xF0005840) |= ((0x6)<<6);
+			*(volatile unsigned long*)(0xF0005040) &= ~((0x1)<<8);
+
+			*(volatile unsigned long*)(0xF00058F0) &= ~((0x7)<<3);
+			*(volatile unsigned long*)(0xF00058F0) |= ((0x6)<<3);
+			*(volatile unsigned long*)(0xF0005070) |= ((0x1)<<14);
+
+
+#else	
+			*(volatile unsigned long*)(0xB0000034) |= 0x00020000;
+			*(volatile unsigned long*)(0xB0000034) &= 0xFFFDFFFF;	
+			*(volatile unsigned long*)(0xB0000A00) &= 0x7FFFFFFF;	//Rest I2S to default vaule
+			*(volatile unsigned long*)(0xB0000060) = 0x00000018;
+
+#if defined(CONFIG_RALINK_RT3883)			
+			*(volatile unsigned long*)(0xB000002C) = 0x00003000;
+#elif defined(CONFIG_ARCH_MT7623)
+
+#else
+			*(volatile unsigned long*)(0xB000002C) = 0x00000300;
+#endif
+#endif			
+#if defined(CONFIG_RALINK_MT7621)
+                        *(volatile unsigned long*)(RALINK_I2S_BASE+0x18) = 0x80000000;
+                        *(volatile unsigned long*)(RALINK_I2S_BASE+0x00) = 0xc1104040;
+
+                        pTable = i2s_inclk_int;
+                        data = pTable[index];
+                        //*(volatile unsigned long*)(RALINK_I2S_BASE+0x24) = data;
+                        i2s_outw(RALINK_I2S_BASE+0x24, data);
+
+                        pTable = i2s_inclk_comp;
+                        data = pTable[index];
+                        //*(volatile unsigned long*)(RALINK_I2S_BASE+0x20) = data;
+                        i2s_outw(RALINK_I2S_BASE+0x20, (data|0x80000000));
+#elif defined(CONFIG_RALINK_MT7628)
+			index =11;  /* SR: 192k */
+			*(volatile unsigned long*)(RALINK_I2S_BASE+0x18) = 0x80000000;
+                        *(volatile unsigned long*)(RALINK_I2S_BASE+0x00) = 0xc1104040;
+
+                        pTable = i2s_inclk_int_16bit;
+			//pTable = i2s_inclk_int_24bit;
+                        data = pTable[index];
+                        //*(volatile unsigned long*)(RALINK_I2S_BASE+0x24) = data;
+                        i2s_outw(RALINK_I2S_BASE+0x24, data);
+
+                        pTable = i2s_inclk_comp_16bit;
+			//pTable = i2s_inclk_comp_24bit;
+                        data = pTable[index];
+                        //*(volatile unsigned long*)(RALINK_I2S_BASE+0x20) = data;
+                        i2s_outw(RALINK_I2S_BASE+0x20, (data|0x80000000));
+			mdelay(5);
+#elif defined(CONFIG_ARCH_MT7623)
+			index = 11;
+			*(volatile unsigned long*)(I2S_I2SCFG1) = 0x80000000;
+			*(volatile unsigned long*)(I2S_I2SCFG) = 0xE1104040;
+			*(volatile unsigned long*)(ETHDMASYS_SYSCTL_BASE+0x30) |= 0x00020000;
+			*(volatile unsigned long*)(ETHDMASYS_SYSCTL_BASE+0x2c) |= 0x00000080;
+
+			pTable = i2s_inclk_int_16bit;
+			//pTable = i2s_inclk_int_24bit;
+                        data = pTable[index];
+                        i2s_outw(I2S_DIVINT_CFG, data);
+
+                        pTable = i2s_inclk_comp_16bit;
+			//pTable = i2s_inclk_comp_24bit;
+                        data = pTable[index];
+                        i2s_outw(I2S_DIVCOMP_CFG, (data|0x80000000));
+			mdelay(5);
+#else
+			*(volatile unsigned long*)(RALINK_I2S_BASE+0x18) = 0x80000000;
+			*(volatile unsigned long*)(RALINK_I2S_BASE+0x00) = 0xC1104040;
+			*(volatile unsigned long*)(RALINK_I2S_BASE+0x24) = 0x00000006;
+			*(volatile unsigned long*)(RALINK_I2S_BASE+0x20) = 0x80000105;
+#endif
+			{
+				int count = 0;
+				int k=0;
+				int enable_cnt=0;
+				unsigned long param[4];
+				unsigned long data;
+				//unsigned long data_tmp;
+				unsigned long ff_status;
+			  	//unsigned long* txbuffer;
+#if 0
+				int j=0;
+				int temp = 0;
+#endif
+#if defined (INTERNAL_LOOPBACK_DEBUG)
+				int count2 = 0;
+#endif
+				memset(param, 0, 4*sizeof(unsigned long) );	
+				copy_from_user(param, (unsigned long*)arg, sizeof(long)*2);
+#if 0
+				txbuffer = (unsigned long*)kcalloc(param[0], sizeof(unsigned long), GFP_KERNEL);
+				if(txbuffer == NULL)
+					return -1;
+#endif
+
+				//ff_status = *(volatile unsigned long*)(RALINK_I2S_BASE+0x0C);
+				ff_status = *(volatile unsigned long*)(I2S_FF_STATUS);
+				printk("ff status=[0x%08X]\n",(u32)ff_status);
+
+#if 0
+				for(i = 0; i < param[0]; i++)
+				{
+					if (i==0)
+					{
+						txbuffer[i] = 0x555A555A;
+						printk("%d: 0x%8lx\n", i, txbuffer[i]);
+					}
+					else 
+					{
+						#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,14)
+						srandom32(jiffies);
+						txbuffer[i] = random32()%(0x555A555A)+1;
+						//printk("%d: 0x%8x\n", i, txbuffer[i]);
+						#else
+						//TODO:do we need to implement random32()
+						txbuffer[i] = 0x01010101;					
+						#endif
+					}
+				}
+#endif
+	
+				for( i = 0 ; i < param[0] ; i ++ )
+				{
+					ff_status = *(volatile unsigned long*)(I2S_FF_STATUS);
+				#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)	
+					if((ff_status&0xFF) > 0)
+				#else
+					if((ff_status&0x0F) > 0)
+				#endif
+					{
+						*(volatile unsigned long*)(I2S_TX_FIFO_WREG) = txbuffer[i];
+						mdelay(1);
+					}
+					else
+					{
+						mdelay(1);
+						printk("[%d]NO TX FREE FIFO ST=[0x%08X]\n", i, (u32)ff_status);
+						continue;	
+					}
+
+					//if(i >= 16)
+					{
+
+						ff_status = *(volatile unsigned long*)(I2S_FF_STATUS);
+					#if defined(CONFIG_RALINK_MT7628)
+						if(((ff_status>>8)&0xFF) > 0)
+					#else
+						if(((ff_status>>4)&0x0F) > 0)
+					#endif
+						{
+							data = *(volatile unsigned long*)(I2S_RX_FIFO_RREG);
+							//data_tmp = *(volatile unsigned long*)(I2S_RX_FIFO_RREG);
+							//MSG("[0x%08X] vs [0x%08X]\n", (u32)data, (u32)data_tmp);
+						}
+						else
+						{
+							printk("*[%d]NO RX FREE FIFO ST=[0x%08X]\n", i, (u32)ff_status);
+							continue;
+						}
+						
+						if (data == txbuffer[0])
+						{
+							k = i;
+							enable_cnt = 1;
+						}
+						if (enable_cnt==1)
+						{
+							if(data!= txbuffer[i-k])
+							{
+								MSG("[%d][0x%08X] vs [0x%08X]\n", (i-k), (u32)data, (u32)txbuffer[i-k]);
+							}
+							else
+							{
+								//MSG("**[%d][0x%08X] vs [0x%08X]\n" ,(i-k), (u32)data , (u32)txbuffer[i-k]);
+								count++;
+								data=0;
+							}
+						}
+
+					}	
+				}
+#if 0	
+				temp = i-k;
+				for (j=0; j<k; j++)
+				{
+
+					//ff_status = *(volatile unsigned long*)(RALINK_I2S_BASE+0x0C);
+					ff_status = *(volatile unsigned long*)(I2S_FF_STATUS);
+				#if defined(CONFIG_RALINK_MT7628) || defined(CONFIG_ARCH_MT7623)
+					if(((ff_status>>8)&0xFF) > 0)
+				#else
+					if(((ff_status>>4)&0x0F) > 0)
+				#endif
+					{
+						//data = *(volatile unsigned long*)(RALINK_I2S_BASE+0x14);
+						data = *(volatile unsigned long*)(I2S_RX_FIFO_RREG);
+					}
+					else
+					{
+						printk("*NO RX FREE FIFO ST=[0x%08X]\n", (u32)ff_status);
+						continue;
+					}
+
+					if(data!= txbuffer[temp+j])
+					{
+						MSG("[%d][0x%08X] vs [0x%08X]\n", (temp+j), (u32)data, (u32)txbuffer[temp+j]);
+					}
+					else
+					{
+						//MSG("&&[%d][0x%08X] vs [0x%08X]\n" ,(temp+j), (u32)data , (u32)txbuffer[temp+j]);
+						count++;
+						data=0;
+					}
+					if ((temp+j)==128)
+					{
+						//ff_status = *(volatile unsigned long*)(RALINK_I2S_BASE+0x0C);
+						ff_status = *(volatile unsigned long*)(I2S_FF_STATUS);
+						//printk("[%d]FIFO ST=[0x%08X]\n", (temp+j), (u32)ff_status);
+					}
+				}
+#endif
+
+#if defined (INTERNAL_LOOPBACK_DEBUG)
+				for( i = 0 ; i < param[0] ; i ++ )
+				{
+					//ff_status = *(volatile unsigned long*)(RALINK_I2S_BASE+0x0C);
+					ff_status = *(volatile unsigned long*)(I2S_FF_STATUS);
+				#if defined(CONFIG_RALINK_MT7628)|| defined(CONFIG_ARCH_MT7623)
+					if((ff_status&0xFF) > 0)
+				#else
+					if((ff_status&0x0F) > 0)
+				#endif
+					{
+						//*(volatile unsigned long*)(RALINK_I2S_BASE+0x10) = txbuffer[i];
+						*(volatile unsigned long*)(I2S_TX_FIFO_WREG) = txbuffer[i];
+						mdelay(1);
+					}
+					else
+					{
+						mdelay(1);
+						printk("[%d]NO TX FREE FIFO ST=[0x%08X]\n", i, (u32)ff_status);
+						continue;	
+					}
+
+					//if(i >= 16)
+					{
+
+						//ff_status = *(volatile unsigned long*)(RALINK_I2S_BASE+0x0C);
+						ff_status = *(volatile unsigned long*)(I2S_FF_STATUS);
+					#if defined(CONFIG_RALINK_MT7628)|| defined(CONFIG_ARCH_MT7623)
+						if(((ff_status>>8)&0xFF) > 0)
+					#else
+						if(((ff_status>>4)&0x0F) > 0)
+					#endif
+						{
+							//data = *(volatile unsigned long*)(RALINK_I2S_BASE+0x14);
+							data = *(volatile unsigned long*)(I2S_RX_FIFO_RREG);
+						}
+						else
+						{
+							printk("*[%d]NO RX FREE FIFO ST=[0x%08X]\n", i, (u32)ff_status);
+							continue;
+						}
+						
+						{
+							if(data!= txbuffer[i])
+							{
+								MSG("[%d][0x%08X] vs [0x%08X]\n", (i), (u32)data, (u32)txbuffer[i]);
+							}
+							else
+							{
+								MSG("**[%d][0x%08X] vs [0x%08X]\n" ,(i), (u32)data , (u32)txbuffer[i]);
+								count2++;
+								data=0;
+							}
+						}
+
+					}	
+				}
+				printk("Pattern match done count2=%d.\n", count2);
+#endif
+				printk("Pattern match done count=%d.\n", count);
+
+			}	
+#if defined(CONFIG_ARCH_MT7623)
+			*(volatile unsigned long*)(0xFB000034) |= 0x00020000;
+			*(volatile unsigned long*)(0xFB000034) &= 0xFFFDFFFF;
+			*(volatile unsigned long*)(ETHDMASYS_I2S_BASE+0x0) &= 0x7FFFFFFF;   //Rest I2S to default vaule
+#endif	
+
+#if !defined(CONFIG_RALINK_RT3052)
+			break;
+#endif
+		case I2S_DEBUG_EXLBK:
+			MSG("I2S_DEBUG_EXLBK\n");
+#if !defined(CONFIG_ARCH_MT7623)
+			switch(arg)
+			{
+				case 8000:
+					index = 0;
+					break;
+				case 11025:
+					index = 1;
+					break;
+				case 12000:
+					index = 2;
+					break;			
+				case 16000:
+					index = 3;
+					break;
+				case 22050:
+					index = 4;
+					break;
+				case 24000:
+					index = 5;
+					break;	
+				case 32000:
+					index = 6;
+					break;			
+				case 44100:
+					index = 7;
+					break;
+				case 48000:
+					index = 8;
+					break;
+				case 88200:
+					index = 9;
+					break;	
+				case 96000:
+					index = 10;
+					break;
+				default:
+					index = 7;
+			}
+#if defined(CONFIG_RALINK_RT3052)
+			break;
+#endif			
+#if defined(CONFIG_RALINK_RT6855A)
+			*(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x860) = 0x00008080;
+			//*(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x82C) = 0x00000300;
+#else			
+			*(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x60) = 0x00000018;
+#if defined(CONFIG_RALINK_RT3883)
+			*(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x2C) = 0x00003000;			
+#else
+			*(volatile unsigned long*)(RALINK_SYSCTL_BASE+0x2C) = 0x00000300;
+#endif
+#endif
+	
+			*(volatile unsigned long*)(RALINK_I2S_BASE+0x18) = 0x40000000;
+			*(volatile unsigned long*)(RALINK_I2S_BASE+0x00) = 0x81104040;
+#if defined(CONFIG_RALINK_MT7628)
+			pTable = i2s_inclk_int_16bit;
+#else
+			pTable = i2s_inclk_int;
+#endif
+			data = (volatile unsigned long)(pTable[index]);
+			i2s_outw(I2S_DIVINT_CFG, data);
+#if defined(CONFIG_RALINK_MT7628)
+			pTable = i2s_inclk_comp_16bit;
+#else
+			pTable = i2s_inclk_comp;
+#endif
+			data = (volatile unsigned long)(pTable[index]);
+			data |= REGBIT(1, I2S_CLKDIV_EN);
+			i2s_outw(I2S_DIVCOMP_CFG, data);
+
+		#if defined(CONFIG_I2S_MCLK_12MHZ)
+			pTable = i2s_codec_12Mhz;
+			#if defined(CONFIG_I2S_WM8960)
+				data = pTable[index];
+			#else
+				data = pTable[index]|0x01;
+			#endif
+		#else
+			pTable = i2s_codec_12p288Mhz;
+			data = pTable[index];
+		#endif
+
+		#if defined(CONFIG_I2S_WM8960) || defined(CONFIG_I2S_WM8750) || defined(CONFIG_I2S_WM8751)
+			audiohw_preinit();
+		#endif
+
+
+		#if defined (CONFIG_I2S_WM8960)
+			audiohw_postinit(1, 1, 1, 1, 0); // for codec apll enable, 16 bit word length 
+		#elif defined(CONFIG_I2S_WM8750) || defined(CONFIG_I2S_WM8751)
+    			audiohw_postinit(1, 1, 1, 0); // for 16 bit word length 
+		#endif
+
+
+		#if defined (CONFIG_I2S_WM8960)
+			audiohw_set_frequency(data, 1);	// for codec apll enable
+		#elif defined(CONFIG_I2S_WM8750) || defined(CONFIG_I2S_WM8751)
+            		audiohw_set_frequency(data|0x1);
+		#endif
+
+
+		#if defined(CONFIG_I2S_WM8960) || defined(CONFIG_I2S_WM8750) || defined(CONFIG_I2S_WM8751)
+			audiohw_set_lineout_vol(1, 100, 100);
+			audiohw_set_linein_vol(100, 100);
+		#endif
+		
+
+		#if defined(CONFIG_I2S_TXRX)			
+			//audiohw_loopback(data);
+		#endif
+		#if !defined(CONFIG_RALINK_RT3052)
+			break;
+		#endif
+#endif
+		case I2S_DEBUG_CODECBYPASS:			
+		#if defined(CONFIG_I2S_TXRX)
+		#if defined(CONFIG_RALINK_MT7628)	
+			data = i2s_inw(RALINK_SYSCTL_BASE+0x60); 
+			//data &= ~(0x3<<4);
+			data &= ~(0x3<<6);
+			data &= ~(0x3<<16);
+			data &= ~(0x1<<14);
+			i2s_outw(RALINK_SYSCTL_BASE+0x60, data);
+
+			data = i2s_inw(RALINK_SYSCTL_BASE+0x2c);
+			data &= ~(0x07<<9);
+			i2s_outw(RALINK_SYSCTL_BASE+0x2c, data);
+		#endif
+		
+		#if defined(CONFIG_I2S_WM8960) || defined(CONFIG_I2S_WM8750) || defined(CONFIG_I2S_WM8751)
+			audiohw_bypass();	/* did not work */
+		#endif
+		#endif
+			break;	
+		case I2S_DEBUG_FMT:
+			break;
+		case I2S_DEBUG_RESET:
+			break;
+#if defined(CONFIG_I2S_WM8960)
+		case I2S_DEBUG_CODEC_EXLBK:
+			audiohw_codec_exlbk();
+			break;
+#endif	
+		default:
+			MSG("Not support this debug cmd [%d]\n", cmd);	
+			break;				
+	}
+	
+	return 0;	
+}
Index: linux-3.10.108/sound/soc/mtk/ralink_gdma.c
===================================================================
--- /dev/null
+++ linux-3.10.108/sound/soc/mtk/ralink_gdma.c
@@ -0,0 +1,920 @@
+/*
+ ***************************************************************************
+ * Ralink Tech Inc.
+ * 5F., No.36, Taiyuan St., Jhubei City,
+ * Hsinchu County 302,
+ * Taiwan, R.O.C.
+ *
+ * (c) Copyright, Ralink Technology, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ ***************************************************************************
+ *
+  Module Name:
+  ralink_gdma.c
+
+  Abstract:
+
+  Revision History:
+  Who         When            What
+  --------    ----------      ----------------------------------------------
+  Name        Date            Modification logs
+  Steven Liu  2009-03-24      Support RT3883
+ *
+ */
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#if defined (CONFIG_MIPS)
+  #include <asm/uaccess.h>
+  #include <asm/addrspace.h>
+#endif
+
+#include "ralink_gdma.h"
+#include "asm/mach-ralink/surfboardint.h"
+
+/*
+ * RT305x:
+ * Ch0 : Pcm0_Rx0 | Pcm0_Rx0 | ALL
+ * Ch1 : Pcm0_Rx1 | Pcm0_Rx1 | ALL
+ * Ch2 : Pcm0_Tx0 | Pcm0_Tx0 | ALL
+ * Ch3 : Pcm0_Tx1 | Pcm0_Tx1 | ALL
+ * Ch4 : Pcm1_Rx0 | I2S_Tx0  | ALL
+ * Ch5 : Pcm1_Rx1 | I2S_Tx1  | ALL
+ * Ch6 : Pcm1_Tx0 |  ALL     | ALL
+ * Ch7 : Pcm1_Tx1 |  ALL     | ALL
+ *
+ * RT3883:
+ * Ch0  : Pcm0_Rx0 | Pcm0_Rx0 | ALL
+ * Ch1  : Pcm0_Rx1 | Pcm0_Rx1 | ALL
+ * Ch2  : Pcm0_Tx0 | Pcm0_Tx0 | ALL
+ * Ch3  : Pcm0_Tx1 | Pcm0_Tx1 | ALL
+ * Ch4  : Pcm1_Rx0 | I2S_Tx0  | ALL
+ * Ch5  : Pcm1_Rx1 | I2S_Tx1  | ALL
+ * Ch6  : Pcm1_Tx0 | I2S_Rx0  | ALL
+ * Ch7  : Pcm1_Tx1 | I2S_Rx1  | ALL
+ * Ch8  : ALL	   |  ALL     | ALL
+ * Ch9  : ALL	   |  ALL     | ALL
+ * Ch10 : ALL	   |  ALL     | ALL
+ * Ch11 : ALL	   |  ALL     | ALL
+ * Ch12 : ALL	   |  ALL     | ALL PCI TX
+ * Ch13 : ALL	   |  ALL     | ALL PCI RX
+ * Ch14 : ALL	   |  ALL     | ALL
+ * Ch15 : ALL	   |  ALL     | ALL
+ *
+ */
+
+spinlock_t  gdma_lock;
+spinlock_t  gdma_lock_mem;
+spinlock_t  gdma_int_lock;
+void (*GdmaDoneIntCallback[MAX_GDMA_CHANNEL])(uint32_t);
+void (*GdmaUnMaskIntCallback[MAX_GDMA_CHANNEL])(uint32_t);
+
+
+/**
+ * @brief Get free GDMA channel
+ *
+ * @param  ChNum   GDMA channel number
+ * @retval 1  	   channel is available
+ * @retval 0  	   channels are all busy
+ */
+int _GdmaGetFreeCh(uint32_t *ChNum)
+{
+    unsigned long flags;
+    uint32_t Data=0;
+    uint32_t Ch=0;
+#if defined (CONFIG_GDMA_DEBUG)
+    static uint32_t Ch_RR=0;
+#endif
+
+    spin_lock_irqsave(&gdma_lock, flags);
+
+#if defined (CONFIG_GDMA_PCM_ONLY)
+#if defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+    for(Ch=14; Ch<MAX_GDMA_CHANNEL;Ch++)  //channel 14~max_channe, channel 0~13 be usedl
+#else
+    for(Ch=MAX_GDMA_CHANNEL; Ch<MAX_GDMA_CHANNEL;Ch++)  //no free channel
+#endif
+#elif defined (CONFIG_GDMA_PCM_I2S_OTHERS)
+#if defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+    for(Ch=14; Ch<MAX_GDMA_CHANNEL;Ch++)  //channel 14~max_channe, channel 0~13 be usedl
+#else
+    for(Ch=6; Ch<MAX_GDMA_CHANNEL;Ch++)  //channel 6~max_channel
+#endif
+#elif defined (CONFIG_GDMA_EVERYBODY)
+    for(Ch=0; Ch<MAX_GDMA_CHANNEL;Ch++)  //all channel
+#elif defined (CONFIG_GDMA_DEBUG)
+    for(Ch=(Ch_RR++)%MAX_GDMA_CHANNEL; Ch<MAX_GDMA_CHANNEL;Ch++)  //round robin
+#endif
+    {
+	Data=GDMA_READ_REG(GDMA_CTRL_REG(Ch));
+
+	/* hardware will reset this bit if transaction is done.
+	 * It means channel is free */
+	if((Data & (0x01<<CH_EBL_OFFSET))==0) { 
+	    *ChNum = Ch;
+	    spin_unlock_irqrestore(&gdma_lock, flags);
+	    return 1; //Channel is free
+	}
+    }
+
+    spin_unlock_irqrestore(&gdma_lock, flags);
+    return 0; // Channels are all busy
+
+}
+
+/**
+ * @brief Set channel is masked
+ *
+ * When channel is masked, the GDMA transaction will stop. 
+ * When GDMA controller comes back from another channel (chain feature)
+ *
+ * >> Channel Mask=0: It's strange, and turns on related bit in GDMA interrupt
+ * status register (16:23 Unmasked)
+ *
+ * >> Channel Mask=1: It'll start GDMA transation, and clear this bit. 
+ *
+ * @param  ChNum   	GDMA channel number
+ * @retval 1  	   	success
+ * @retval 0  	   	fail
+ */
+int GdmaMaskChannel(uint32_t ChNum)
+{
+    uint32_t Data=0;
+
+    Data=GDMA_READ_REG(GDMA_CTRL_REG1(ChNum));
+    Data |= ( 0x01 << CH_MASK_OFFSET); 
+    GDMA_WRITE_REG(GDMA_CTRL_REG1(ChNum), Data);
+    GDMA_PRINT("%s: Write %0X to %X\n", __FUNCTION__, Data, GDMA_CTRL_REG1(ChNum));
+
+    return 1;
+}
+
+/**
+ * @brief Set channel is unmasked
+ *
+ * You can unmask the channel to start GDMA transaction. 
+ *
+ * When GDMA controller comes back from another channel (chain feature)
+ *
+ * >> Channel Mask=0: It's strange, and turns on related bit in GDMA interrupt
+ * status register (16:23 Unmasked)
+ *
+ * >> Channel Mask=1: It'll start GDMA transation, and clear this bit. 
+ *
+ * @param  ChNum   	GDMA channel number
+ * @retval 1  	   	success
+ * @retval 0  	   	fail
+ */
+int GdmaUnMaskChannel(uint32_t ChNum)
+{
+    uint32_t Data=0;
+
+    Data=GDMA_READ_REG(GDMA_CTRL_REG1(ChNum));
+    Data &= ~( 0x01 << CH_MASK_OFFSET); 
+    GDMA_WRITE_REG(GDMA_CTRL_REG1(ChNum), Data);
+    GDMA_PRINT("%s: Write %0X to %X\n", __FUNCTION__, Data, GDMA_CTRL_REG1(ChNum));
+
+    return 1;
+}
+
+/**
+ * @brief Insert new GDMA entry to start GDMA transaction
+ *
+ * @param  ChNum   	GDMA channel number
+ * @retval 1  	   	success
+ * @retval 0  	   	fail
+ */
+int GdmaReqQuickIns(uint32_t ChNum)
+{
+    uint32_t Data=0;
+
+    //Mask Channel
+    Data = GDMA_READ_REG(GDMA_CTRL_REG1(ChNum));
+    Data |= ( 0x1 << CH_MASK_OFFSET); 
+    GDMA_WRITE_REG(GDMA_CTRL_REG1(ChNum), Data);
+
+    //Channel Enable
+    Data = GDMA_READ_REG(GDMA_CTRL_REG(ChNum));
+    Data |= (0x01<<CH_EBL_OFFSET); 
+    GDMA_WRITE_REG(GDMA_CTRL_REG(ChNum), Data);
+
+    return 1;
+
+}
+
+int _GdmaReqEntryIns(GdmaReqEntry *NewEntry)
+{
+    uint32_t Data=0;
+#if 0
+    GDMA_PRINT("== << GDMA Control Reg (Channel=%d) >> ===\n", NewEntry->ChNum);
+    GDMA_PRINT(" Channel Source Addr = %x \n", NewEntry->Src);
+    GDMA_PRINT(" Channel Dest Addr = %x \n", NewEntry->Dst);
+    GDMA_PRINT(" Transfer Count=%d\n", NewEntry->TransCount);
+    GDMA_PRINT(" Source DMA Req= DMA_REQ%d\n", NewEntry->SrcReqNum);
+    GDMA_PRINT(" Dest DMA Req= DMA_REQ%d\n", NewEntry->DstReqNum);
+    GDMA_PRINT(" Source Burst Mode=%s\n", NewEntry->SrcBurstMode ? "Fix" : "Inc");
+    GDMA_PRINT(" Dest Burst Mode=%s\n", NewEntry->DstBurstMode ? "Fix" : "Inc");
+    GDMA_PRINT(" Burst Size=%s\n", NewEntry->BurstSize ==0 ? "1 transfer" : \
+	    NewEntry->BurstSize ==1 ? "2 transfer" :\
+	    NewEntry->BurstSize ==2 ? "4 transfer" :\
+	    NewEntry->BurstSize ==3 ? "8 transfer" :\
+	    NewEntry->BurstSize ==4 ? "16 transfer" :\
+	    "Error");
+    GDMA_PRINT(" Hardware/Software Mode = %s\n", NewEntry->SoftMode ?
+	    "Soft" : "Hw");
+    GDMA_PRINT("== << GDMA Control Reg1 (Channel=%d) >> =\n", NewEntry->ChNum);
+    GDMA_PRINT("Channel Done Interrput=%s\n", (NewEntry->DoneIntCallback!=NULL) ? 
+	    "Enable" : "Disable");
+    GDMA_PRINT("Channel Unmasked Int=%s\n", (NewEntry->UnMaskIntCallback!=NULL) ? 
+	    "Enable" : "Disable");
+#if !defined (CONFIG_RALINK_RT3052) && !defined (CONFIG_RALINK_RT3883)
+    GDMA_PRINT("Coherent Interrupt =%s\n", (NewEntry->CoherentIntEbl==1)?
+	    "Enable" : "Disable");
+#endif
+    GDMA_PRINT("Next Unmasked Channel=%d\n", NewEntry->NextUnMaskCh);
+    GDMA_PRINT("Channel Mask=%d\n", NewEntry->ChMask);
+    GDMA_PRINT("========================================\n");
+#endif 
+
+    GDMA_WRITE_REG(GDMA_SRC_REG(NewEntry->ChNum), NewEntry->Src);
+    //GDMA_PRINT("SrcAddr: Write %0X to %X\n", \
+	   // NewEntry->Src, GDMA_SRC_REG(NewEntry->ChNum));
+
+    GDMA_WRITE_REG(GDMA_DST_REG(NewEntry->ChNum), NewEntry->Dst);
+    //GDMA_PRINT("DstAddr: Write %0X to %X\n", \
+	 //   NewEntry->Dst, GDMA_DST_REG(NewEntry->ChNum));
+
+    Data |= ( (NewEntry->NextUnMaskCh) << NEXT_UNMASK_CH_OFFSET); 
+    Data |= ( NewEntry->ChMask << CH_MASK_OFFSET); 
+#if !defined (CONFIG_RALINK_RT3052) && !defined (CONFIG_RALINK_RT3883)
+    Data |= ( NewEntry->CoherentIntEbl << COHERENT_INT_EBL_OFFSET); 
+#endif
+
+    if(NewEntry->UnMaskIntCallback!=NULL) {
+	Data |= (0x01<<CH_UNMASKINT_EBL_OFFSET); 
+	GdmaUnMaskIntCallback[NewEntry->ChNum] = NewEntry->UnMaskIntCallback;
+    }
+
+#if defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+    Data |= (NewEntry->SrcReqNum << SRC_DMA_REQ_OFFSET); 
+    Data |= (NewEntry->DstReqNum << DST_DMA_REQ_OFFSET); 
+#endif
+
+    GDMA_WRITE_REG(GDMA_CTRL_REG1(NewEntry->ChNum), Data);
+    //GDMA_PRINT("CTRL1: Write %08X to %8X\n", Data, GDMA_CTRL_REG1(NewEntry->ChNum));
+
+    Data = ((NewEntry->TransCount) << TRANS_CNT_OFFSET); 
+#if defined (CONFIG_RALINK_RT3052)
+    Data |= (NewEntry->SrcReqNum << SRC_DMA_REQ_OFFSET); 
+    Data |= (NewEntry->DstReqNum << DST_DMA_REQ_OFFSET); 
+#endif
+    Data |= (NewEntry->SrcBurstMode << SRC_BRST_MODE_OFFSET); 
+    Data |= (NewEntry->DstBurstMode << DST_BRST_MODE_OFFSET); 
+    Data |= (NewEntry->BurstSize << BRST_SIZE_OFFSET); 
+
+    if(NewEntry->DoneIntCallback!=NULL) {
+	Data |= (0x01<<CH_DONEINT_EBL_OFFSET); 
+	GdmaDoneIntCallback[NewEntry->ChNum] = NewEntry->DoneIntCallback;
+    }
+
+    if(NewEntry->SoftMode) {
+	Data |= (0x01<<MODE_SEL_OFFSET); 
+    }
+
+    Data |= (0x01<<CH_EBL_OFFSET); 
+    GDMA_WRITE_REG(GDMA_CTRL_REG(NewEntry->ChNum), Data);
+    //GDMA_READ_REG(GDMA_CTRL_REG(NewEntry->ChNum));
+    //GDMA_PRINT("CTRL: Write %08X to %8X\n", Data, GDMA_CTRL_REG(NewEntry->ChNum));    
+     //if there is no interrupt handler, this function will 
+    //return 1 until GDMA done.
+    if(NewEntry->DoneIntCallback==NULL) { 
+	//wait for GDMA processing done
+#if defined (CONFIG_RALINK_RT3052)	
+	while((GDMA_READ_REG(RALINK_GDMAISTS) & 
+		    (0x1<<NewEntry->ChNum))==0); 
+	//write 1 clear
+	GDMA_WRITE_REG(RALINK_GDMAISTS, 1<< NewEntry->ChNum); 
+#elif defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+	while((GDMA_READ_REG(RALINK_GDMA_DONEINT) & 
+		    (0x1<<NewEntry->ChNum))==0); 
+	//write 1 clear
+	GDMA_WRITE_REG(RALINK_GDMA_DONEINT, 1<< NewEntry->ChNum); 
+#endif
+    }
+
+    return 1;
+
+}
+
+#if defined(CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+/**
+ * @brief Start GDMA transaction for sending data to SPI
+ *
+ * @param  *Src   	source address
+ * @param  *Dst    	destination address
+
+ * @param  TransCount  	data length
+ * @param  *DoneIntCallback  callback function when transcation is done
+ * @param  *UnMaskIntCallback  callback func when ch mask field is incorrect
+ * @retval 1  	   	success
+ * @retval 0  	   	fail
+ */
+int GdmaSpiTx(
+	uint32_t Src, 
+	uint32_t Dst, 
+	uint16_t TransCount,
+	void (*DoneIntCallback)(uint32_t data),
+	void (*UnMaskIntCallback)(uint32_t data)
+	)
+{
+    GdmaReqEntry Entry;
+
+	#if defined (CONFIG_MIPS)
+    Entry.Src= (Src & 0x1FFFFFFF);
+    Entry.Dst= (Dst & 0x1FFFFFFF);
+  #else  
+    Entry.Src= Src;
+    Entry.Dst= Dst;
+  #endif
+    Entry.TransCount = TransCount;
+    Entry.SrcBurstMode=INC_MODE;
+    Entry.DstBurstMode=FIX_MODE;
+    Entry.BurstSize=BUSTER_SIZE_4B; 
+    Entry.SrcReqNum=DMA_MEM_REQ;
+    Entry.DstReqNum=DMA_SPI_TX_REQ;
+    Entry.DoneIntCallback=DoneIntCallback;
+    Entry.UnMaskIntCallback=UnMaskIntCallback;
+    Entry.SoftMode=0;
+    Entry.ChMask=0;
+    Entry.CoherentIntEbl=0;
+  
+	//enable chain feature
+	Entry.ChNum = GDMA_SPI_TX;
+	Entry.NextUnMaskCh = GDMA_SPI_TX;
+
+    return _GdmaReqEntryIns(&Entry);
+}
+
+int GdmaSpiRx(
+	uint32_t Src, 
+	uint32_t Dst, 
+	uint16_t TransCount,
+	void (*DoneIntCallback)(uint32_t data),
+	void (*UnMaskIntCallback)(uint32_t data)
+	)
+{
+    GdmaReqEntry Entry;
+
+	#if defined (CONFIG_MIPS)
+    Entry.Src= (Src & 0x1FFFFFFF);
+    Entry.Dst= (Dst & 0x1FFFFFFF);
+  #else  
+    Entry.Src= Src;
+    Entry.Dst= Dst;
+  #endif
+    Entry.TransCount = TransCount;
+    Entry.SrcBurstMode=FIX_MODE;
+    Entry.DstBurstMode=INC_MODE;
+    Entry.BurstSize=BUSTER_SIZE_4B; 
+    Entry.SrcReqNum=DMA_SPI_RX_REQ;
+    Entry.DstReqNum=DMA_MEM_REQ;
+    Entry.DoneIntCallback=DoneIntCallback;
+    Entry.UnMaskIntCallback=UnMaskIntCallback;
+    Entry.SoftMode=0;
+    Entry.ChMask=0;
+    Entry.CoherentIntEbl=1;
+    
+
+	//enable chain feature
+	Entry.ChNum=GDMA_SPI_RX;
+	Entry.NextUnMaskCh=GDMA_SPI_RX;
+    
+
+    return _GdmaReqEntryIns(&Entry);
+
+}
+#endif
+
+
+/**
+ * @brief Start GDMA transaction for sending data to I2S
+ *
+ * @param  *Src   	source address
+ * @param  *Dst    	destination address
+ * @param  TxNo    	I2S Tx number 
+ * @param  TransCount  	data length
+ * @param  *DoneIntCallback  callback function when transcation is done
+ * @param  *UnMaskIntCallback  callback func when ch mask field is incorrect
+ * @retval 1  	   	success
+ * @retval 0  	   	fail
+ */
+int GdmaI2sTx(
+	uint32_t Src, 
+	uint32_t Dst, 
+	uint8_t TxNo,
+	uint16_t TransCount,
+	void (*DoneIntCallback)(uint32_t data),
+	void (*UnMaskIntCallback)(uint32_t data)
+	)
+{
+    GdmaReqEntry Entry;
+
+	#if defined (CONFIG_MIPS)
+    Entry.Src= (Src & 0x1FFFFFFF);
+    Entry.Dst= (Dst & 0x1FFFFFFF);
+  #else  
+    Entry.Src= Src;
+    Entry.Dst= Dst;
+  #endif
+    Entry.TransCount = TransCount;
+    Entry.SrcBurstMode=INC_MODE;
+    Entry.DstBurstMode=FIX_MODE;
+    Entry.BurstSize=BUSTER_SIZE_4B; 
+    Entry.SrcReqNum=DMA_MEM_REQ;
+    Entry.DstReqNum=DMA_I2S_TX_REQ;
+    Entry.DoneIntCallback=DoneIntCallback;
+    Entry.UnMaskIntCallback=UnMaskIntCallback;
+    Entry.SoftMode=0;
+    Entry.ChMask=1;
+    Entry.CoherentIntEbl=0;
+   
+    if(TxNo==0) { //TX0
+	//enable chain feature
+	Entry.ChNum=GDMA_I2S_TX0;
+	Entry.NextUnMaskCh= (TransCount==4) ?  GDMA_I2S_TX0 : GDMA_I2S_TX1;
+    }else if(TxNo==1) { //TX1
+	//enable chain feature
+	Entry.ChNum=GDMA_I2S_TX1;
+	Entry.NextUnMaskCh= (TransCount==4) ? GDMA_I2S_TX1 : GDMA_I2S_TX0;
+    }else {
+	GDMA_PRINT("I2S Tx Number %x is invalid\n", TxNo);
+	return 0;
+    }
+
+    return _GdmaReqEntryIns(&Entry);
+
+}
+
+
+#if defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+/**
+ * @brief Start GDMA transaction for receiving data to I2S
+ *
+ * @param  *Src   	source address
+ * @param  *Dst    	destination address
+ * @param  TxNo    	I2S Tx number 
+ * @param  TransCount  	data length
+ * @param  *DoneIntCallback  callback function when transcation is done
+ * @param  *UnMaskIntCallback  callback func when ch mask field is incorrect
+ * @retval 1  	   	success
+ * @retval 0  	   	fail
+ */
+int GdmaI2sRx(
+	uint32_t Src, 
+	uint32_t Dst, 
+	uint8_t RxNo,
+	uint16_t TransCount,
+	void (*DoneIntCallback)(uint32_t data),
+	void (*UnMaskIntCallback)(uint32_t data)
+	)
+{
+    GdmaReqEntry Entry;
+	#if defined (CONFIG_MIPS)
+    Entry.Src= (Src & 0x1FFFFFFF);
+    Entry.Dst= (Dst & 0x1FFFFFFF);
+  #else  
+    Entry.Src= Src;
+    Entry.Dst= Dst;
+  #endif
+    Entry.TransCount = TransCount;
+    Entry.SrcBurstMode=FIX_MODE;
+    Entry.DstBurstMode=INC_MODE;
+    Entry.BurstSize=BUSTER_SIZE_4B; 
+    Entry.SrcReqNum=DMA_I2S_RX_REQ;
+    Entry.DstReqNum=DMA_MEM_REQ;
+    Entry.DoneIntCallback=DoneIntCallback;
+    Entry.UnMaskIntCallback=UnMaskIntCallback;
+    Entry.SoftMode=0;
+    Entry.ChMask=1;
+    Entry.CoherentIntEbl=1;
+    
+    if(RxNo==0) { //RX0
+	//enable chain feature
+	Entry.ChNum=GDMA_I2S_RX0;
+	Entry.NextUnMaskCh=(TransCount==4) ? GDMA_I2S_RX0 : GDMA_I2S_RX1;
+    }else if(RxNo==1) { //RX1
+	//enable chain feature
+	Entry.ChNum=GDMA_I2S_RX1;
+	Entry.NextUnMaskCh=(TransCount==4) ? GDMA_I2S_RX1 : GDMA_I2S_RX0;
+    }else {
+	GDMA_PRINT("I2S Rx Number %x is invalid\n", RxNo);
+	return 0;
+    }
+
+    return _GdmaReqEntryIns(&Entry);
+
+}
+
+#endif
+
+/**
+ * @brief Start GDMA transaction for receiving data from PCM
+ *
+ * @param  *Src   	source address
+ * @param  *Dst    	destination address
+ * @param  TransCount   data length
+ * @param  PcmNo    	PCM channel
+ * @param  RxNo    	PCM Rx number 
+ * @param  *DoneIntCallback  callback function when transcation is done
+ * @param  *UnMaskIntCallback  callback func when ch mask field is incorrect
+ * @retval 1  	   	success
+ * @retval 0  	   	fail
+ */
+int GdmaPcmRx(
+	uint32_t Src, 
+	uint32_t Dst, 
+	uint8_t PcmNo,
+	uint8_t RxNo,
+	uint16_t TransCount, 
+	void (*DoneIntCallback)(uint32_t data),
+	void (*UnMaskIntCallback)(uint32_t data)
+	)
+{
+    GdmaReqEntry Entry;
+
+	#if defined (CONFIG_MIPS)
+    Entry.Src= (Src & 0x1FFFFFFF);
+    Entry.Dst= (Dst & 0x1FFFFFFF);
+  #else  
+    Entry.Src= Src;
+    Entry.Dst= Dst;
+  #endif
+    Entry.TransCount = TransCount;
+    Entry.SrcBurstMode=FIX_MODE;
+    Entry.DstBurstMode=INC_MODE;
+    Entry.BurstSize=BUSTER_SIZE_4B; 
+    Entry.DstReqNum=DMA_MEM_REQ; 
+    Entry.DoneIntCallback=DoneIntCallback;
+    Entry.UnMaskIntCallback=UnMaskIntCallback;
+    Entry.SoftMode=0;
+    Entry.ChMask=1;
+    Entry.CoherentIntEbl=1;
+
+	if(RxNo > 2) {
+		GDMA_PRINT("PCM Rx Number %x is invalid\n", RxNo);
+		return 0;
+	}
+
+	switch(PcmNo)
+	{
+	case 0:
+		Entry.SrcReqNum=DMA_PCM_RX0_REQ;
+		break;
+	case 1:
+		Entry.SrcReqNum=DMA_PCM_RX1_REQ;
+		break;
+#if defined(CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+	case 2:
+		Entry.SrcReqNum=DMA_PCM_RX2_REQ;
+		break;
+	case 3:
+		Entry.SrcReqNum=DMA_PCM_RX3_REQ;
+		break;
+#endif
+	default:
+		GDMA_PRINT("PCM Channel %x is invalid\n", PcmNo);
+		return 0;
+	}
+	Entry.ChNum=GDMA_PCM_RX(PcmNo,RxNo);
+	Entry.NextUnMaskCh=GDMA_PCM_RX(PcmNo,1-RxNo);
+
+    return _GdmaReqEntryIns(&Entry);
+
+}
+
+/**
+ * @brief Start GDMA transaction for sending data to PCM
+ *
+ * @param  *Src		    source address
+ * @param  *Dst		    destination address
+ * @param  TransCount	    data length
+ * @param  PcmNo	    PCM channel
+ * @param  TxNo		    PCM Tx number 
+ * @param  *DoneIntCallback  callback func when transcation is done
+ * @param  *UnMaskIntCallback  callback func when ch mask field is incorrect
+ * @retval 1		    success
+ * @retval 0		    fail
+ */
+int GdmaPcmTx(
+	uint32_t Src, 
+	uint32_t Dst, 
+	uint8_t PcmNo,
+	uint8_t TxNo,
+	uint16_t TransCount, 
+	void (*DoneIntCallback)(uint32_t data),
+	void (*UnMaskIntCallback)(uint32_t data)
+	)
+{
+    GdmaReqEntry Entry;
+
+	#if defined (CONFIG_MIPS)
+    Entry.Src= (Src & 0x1FFFFFFF);
+    Entry.Dst= (Dst & 0x1FFFFFFF);
+  #else  
+    Entry.Src= Src;
+    Entry.Dst= Dst;
+  #endif
+    Entry.TransCount = TransCount;
+    Entry.SrcBurstMode=INC_MODE;
+    Entry.DstBurstMode=FIX_MODE;
+    Entry.BurstSize=BUSTER_SIZE_4B; 
+    Entry.SrcReqNum=DMA_MEM_REQ; 
+    Entry.DoneIntCallback=DoneIntCallback;
+    Entry.UnMaskIntCallback=UnMaskIntCallback;
+    Entry.SoftMode=0; //Hardware Mode
+    Entry.ChMask=1;
+    Entry.CoherentIntEbl=0;
+
+	if(TxNo > 2) {
+        GDMA_PRINT("PCM Tx Number %x is invalid\n", TxNo);
+		return 0;
+	}
+	switch(PcmNo)
+	{
+	case 0:
+		Entry.DstReqNum=DMA_PCM_TX0_REQ;
+		break;
+	case 1:
+		Entry.DstReqNum=DMA_PCM_TX1_REQ;
+		break;
+#if defined(CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+	case 2:
+		Entry.DstReqNum=DMA_PCM_TX2_REQ;
+		break;
+	case 3:
+		Entry.DstReqNum=DMA_PCM_TX3_REQ;
+		break;
+#endif
+	default:
+		GDMA_PRINT("PCM Channel %x is invalid\n", PcmNo);	
+		return 0;
+	}
+	Entry.ChNum=GDMA_PCM_TX(PcmNo,TxNo);
+	Entry.NextUnMaskCh=GDMA_PCM_TX(PcmNo,1-TxNo);
+
+    return _GdmaReqEntryIns(&Entry);
+
+}
+
+
+/**
+ * @brief Start GDMA transaction for memory to memory copy
+ *
+ * @param  *Src		    source address
+ * @param  *Dst		    destination address
+ * @param  TransCount	    data length
+ * @param  *DoneIntCallback  callback function when transcation is done
+ * @retval 1		    success
+ * @retval 0		    fail
+ */
+int GdmaMem2Mem(
+	uint32_t Src, 
+	uint32_t Dst, 
+	uint16_t TransCount,
+	void (*DoneIntCallback)(uint32_t data)
+	)
+
+{
+
+    GdmaReqEntry Entry;
+	#if defined (CONFIG_MIPS)
+    Entry.Src= (Src & 0x1FFFFFFF);
+    Entry.Dst= (Dst & 0x1FFFFFFF);
+  #else  
+    Entry.Src= Src;
+    Entry.Dst= Dst;
+  #endif
+
+    //Entry.Src= virt_to_phys(Src);
+    //Entry.Dst= virt_to_phys(Dst);    
+    
+    
+    
+    Entry.TransCount = TransCount;
+    Entry.SrcBurstMode=INC_MODE;
+    Entry.DstBurstMode=INC_MODE;
+    Entry.BurstSize=BUSTER_SIZE_64B; 
+    Entry.SrcReqNum=DMA_MEM_REQ; 
+    Entry.DstReqNum=DMA_MEM_REQ; 
+    Entry.DoneIntCallback=DoneIntCallback;
+    Entry.UnMaskIntCallback=NULL;
+    Entry.SoftMode=1;
+    Entry.ChMask=0;
+
+    Entry.CoherentIntEbl=1;
+
+    //No reserved channel for Memory to Memory GDMA,
+    //get free channel on demand
+    if(!_GdmaGetFreeCh(&Entry.ChNum)) {
+			GDMA_PRINT("GDMA Channels are all busy\n");
+			return 0;
+    }
+
+
+    //set next channel to their own channel 
+    //to disable chain feature
+    Entry.NextUnMaskCh= Entry.ChNum;
+      //printk ("ChNum = %d\n", Entry.ChNum);
+    //set next channel to another channel
+    //to enable chain feature
+    //Entry.NextUnMaskCh= (Entry.ChNum+1) % MAX_GDMA_CHANNEL;
+
+    return _GdmaReqEntryIns(&Entry);
+ 
+
+}
+
+/**
+ * @brief GDMA interrupt handler 
+ *
+ * When GDMA transcation is done, call related handler 
+ * to do the remain job.
+ *
+ */
+irqreturn_t GdmaIrqHandler(
+	int irq, 
+	void *irqaction
+	)
+{
+
+    u32 Ch=0;
+    unsigned long flags;
+#if defined (CONFIG_RALINK_RT3052)	
+    u32 GdmaUnMaskStatus=GDMA_READ_REG(RALINK_GDMAISTS) & 0xFF0000;
+    u32 GdmaDoneStatus=GDMA_READ_REG(RALINK_GDMAISTS) & 0xFF;
+#elif defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+    u32 GdmaUnMaskStatus=GDMA_READ_REG(RALINK_GDMA_UNMASKINT);
+    u32 GdmaDoneStatus=GDMA_READ_REG(RALINK_GDMA_DONEINT);
+#endif
+    //printk("********GDMA Interrupt*******************\n");
+
+    //GDMA_PRINT("========================================\n");
+    //GDMA_PRINT("GdmaUnMask Interrupt=%x\n",GdmaUnMaskStatus);
+    //GDMA_PRINT("GdmaDone Interrupt=%x\n",GdmaDoneStatus);
+    //GDMA_PRINT("========================================\n");
+
+    spin_lock_irqsave(&gdma_int_lock, flags);
+    
+    //write 1 clear
+#if defined (CONFIG_RALINK_RT3052)	
+    GDMA_WRITE_REG(RALINK_GDMAISTS, GdmaUnMaskStatus); 
+#elif defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+    GDMA_WRITE_REG(RALINK_GDMA_UNMASKINT, GdmaUnMaskStatus); 
+#endif
+
+    //UnMask error
+    for(Ch=0;Ch<MAX_GDMA_CHANNEL;Ch++) {
+
+	if(GdmaUnMaskStatus & (0x1 << (UNMASK_INT_STATUS(Ch))) ) {
+	    if(GdmaUnMaskIntCallback[Ch] != NULL) {
+		GdmaUnMaskIntCallback[Ch](Ch);
+	      // printk("GdmaUnMaskIntCallback \n");
+	    }
+	}
+     }	
+    //write 1 clear
+#if defined (CONFIG_RALINK_RT3052)	
+     GDMA_WRITE_REG(RALINK_GDMAISTS, GdmaDoneStatus); 
+#elif defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+     GDMA_WRITE_REG(RALINK_GDMA_DONEINT, GdmaDoneStatus); 
+#endif
+	
+     //printk("interrupt status = %x \n", GdmaDoneStatus);
+     //processing done
+     for(Ch=0;Ch<MAX_GDMA_CHANNEL;Ch++) {
+			if(GdmaDoneStatus & (0x1<<Ch)) {
+		    	if(GdmaDoneIntCallback[Ch] != NULL) {
+						GdmaDoneIntCallback[Ch](Ch); 
+						//printk("DoneInt Ch=%d\n", Ch);
+		    	}
+			}
+    }
+
+	//printk("interrupt  clear = %x \n", GDMA_READ_REG(RALINK_GDMA_DONEINT));
+    spin_unlock_irqrestore(&gdma_int_lock, flags);
+
+    return IRQ_HANDLED;
+
+}
+
+static int RalinkGdmaInit(void)
+{
+
+    uint32_t Ret=0;
+    uint32_t val = 0;
+    printk("Enable Ralink GDMA Controller Module \n");
+#if defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+    printk("GDMA IP Version=%d\n", GET_GDMA_IP_VER);
+#endif
+spin_lock_init(&gdma_int_lock);
+spin_lock_init(&gdma_lock);
+//spin_lock_init(&gdma_lock_mem);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+	#if defined (CONFIG_MIPS)
+	    Ret = request_irq(SURFBOARDINT_DMA, GdmaIrqHandler, \
+		    IRQF_DISABLED, "Ralink_DMA", NULL);
+	#else
+	    Ret = request_irq(SURFBOARDINT_DMA, GdmaIrqHandler, \
+		    IRQF_TRIGGER_LOW, "Ralink_DMA", NULL);
+	#endif
+#else
+    Ret = request_irq(SURFBOARDINT_DMA, GdmaIrqHandler, \
+	    SA_INTERRUPT, "Ralink_DMA", NULL);
+#endif
+
+/*
+    Ret = request_irq(131, GdmaIrqHandler, \
+	    IRQF_TRIGGER_LOW, "Ralink_DMA", NULL);
+	    */
+    if(Ret){
+	GDMA_PRINT("IRQ %d is not free.\n", SURFBOARDINT_DMA);
+	return 1;
+    }
+    
+#if defined (CONFIG_MIPS)
+    //Enable GDMA interrupt
+    val = le32_to_cpu(*(volatile u32 *)(RALINK_REG_INTENA));
+    val |= RALINK_INTCTL_DMA;
+    GDMA_WRITE_REG(RALINK_REG_INTENA, val);
+#endif
+
+    //Channel0~Channel7 are round-robin
+#if defined (CONFIG_RALINK_RT3052)
+    GDMA_WRITE_REG(RALINK_GDMAGCT, 0x01);
+#elif defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+    GDMA_WRITE_REG(RALINK_GDMA_GCT, 0x01);
+#else
+#error Please Choose System Type
+#endif
+
+    return 0;
+}
+
+static void __exit RalinkGdmaExit(void)
+{
+
+    printk("Disable Ralink GDMA Controller Module\n");
+#if defined (CONFIG_MIPS)
+    //Disable GDMA interrupt
+    GDMA_WRITE_REG(RALINK_REG_INTDIS, RALINK_INTCTL_DMA);
+#endif
+    free_irq(SURFBOARDINT_DMA, NULL);
+}
+
+module_init(RalinkGdmaInit);
+module_exit(RalinkGdmaExit);
+
+EXPORT_SYMBOL(GdmaI2sRx);
+EXPORT_SYMBOL(GdmaI2sTx);
+EXPORT_SYMBOL(GdmaPcmRx);
+EXPORT_SYMBOL(GdmaPcmTx);
+#if defined(CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+EXPORT_SYMBOL(GdmaSpiRx);
+EXPORT_SYMBOL(GdmaSpiTx);
+#endif
+EXPORT_SYMBOL(GdmaMem2Mem);
+EXPORT_SYMBOL(GdmaReqQuickIns);
+EXPORT_SYMBOL(GdmaMaskChannel);
+EXPORT_SYMBOL(GdmaUnMaskChannel);
+
+
+MODULE_DESCRIPTION("Ralink SoC GDMA Controller API Module");
+MODULE_AUTHOR("Steven Liu <steven_liu@ralinktech.com.tw>");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(MOD_VERSION);
Index: linux-3.10.108/sound/soc/mtk/ralink_gdma.h
===================================================================
--- /dev/null
+++ linux-3.10.108/sound/soc/mtk/ralink_gdma.h
@@ -0,0 +1,326 @@
+/*
+ ***************************************************************************
+ * Ralink Tech Inc.
+ * 5F., No.36, Taiyuan St., Jhubei City,
+ * Hsinchu County 302,
+ * Taiwan, R.O.C.
+ *
+ * (c) Copyright, Ralink Technology, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ ***************************************************************************
+ */
+
+#ifndef __RALINK_DMA_CTRL_H__
+#define __RALINK_DMA_CTRL_H__
+
+#include <asm/mach-ralink/rt_mmap.h>
+
+/*
+ * DEFINITIONS AND MACROS
+ */
+#define MOD_VERSION 			"0.4"
+
+#if defined (CONFIG_RALINK_MT7621) || defined (CONFIG_ARCH_MT7628)
+#define MAX_GDMA_CHANNEL		16
+#elif defined (CONFIG_RALINK_RT3052)
+#define MAX_GDMA_CHANNEL		8
+#elif defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7628)
+#define MAX_GDMA_CHANNEL		16
+#else
+#error Please Choose System Type
+#endif
+
+
+#define RALINK_GDMA_CTRL_BASE		(RALINK_GDMA_BASE)
+#if defined (CONFIG_RALINK_RT3052)
+#define RALINK_GDMAISTS			(RALINK_GDMA_BASE + 0x80)
+#define RALINK_GDMAGCT			(RALINK_GDMA_BASE + 0x88)
+#elif defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+#define RALINK_GDMA_UNMASKINT		(RALINK_GDMA_BASE + 0x200)
+#define RALINK_GDMA_DONEINT		(RALINK_GDMA_BASE + 0x204)
+#define RALINK_GDMA_GCT			(RALINK_GDMA_BASE + 0x220)
+#endif
+
+#define KSEG1                   0xa0000000
+#define PHYS_TO_VIRT(x)         ((void *)((x) | KSEG1))
+#define VIRT_TO_PHYS(x)         ((unsigned long)(x) & ~KSEG1)
+
+
+
+
+#if defined (CONFIG_ARCH_MT7623)
+#include <mach/sync_write.h>
+#define GDMA_READ_REG(phys)            (*(volatile unsigned int *)((phys)))
+#define GDMA_WRITE_REG(phys, val)      mt65xx_reg_sync_writel((val), (phys))
+
+#else
+#define GDMA_READ_REG(addr) 		(le32_to_cpu(*(volatile u32 *)(addr)))
+#define GDMA_WRITE_REG(addr, val)  	*((volatile uint32_t *)(addr)) = cpu_to_le32(val)
+
+
+
+#endif
+
+
+#define GET_GDMA_IP_VER			(GDMA_READ_REG(RALINK_GDMA_GCT) & 0x6) >> 1 //GDMA_GCT[2:1]
+
+#define RALINK_IRQ_ADDR                 RALINK_INTCL_BASE
+#if defined (CONFIG_RALINK_MT7621) || defined (CONFIG_ARCH_MT7628)
+#define RALINK_REG_INTENA               (RALINK_IRQ_ADDR + 0x80)
+#define RALINK_REG_INTDIS               (RALINK_IRQ_ADDR + 0x78)
+#else
+#define RALINK_REG_INTENA               (RALINK_IRQ_ADDR + 0x34)
+#define RALINK_REG_INTDIS               (RALINK_IRQ_ADDR + 0x38)
+#endif
+
+/* 
+ * 12bytes=GDMA Channel n Source Address(4) +
+ *         GDMA Channel n Destination Address(4) +
+ *         GDMA Channel n Control Register(4)
+ *
+ */
+#define GDMA_SRC_REG(ch)		(RALINK_GDMA_BASE + ch*16)
+#define GDMA_DST_REG(ch)		(GDMA_SRC_REG(ch) + 4)
+#define GDMA_CTRL_REG(ch)		(GDMA_DST_REG(ch) + 4)
+#define GDMA_CTRL_REG1(ch)		(GDMA_CTRL_REG(ch) + 4)
+
+//GDMA Interrupt Status Register
+#if defined (CONFIG_RALINK_RT3052)
+#define UNMASK_INT_STATUS(ch)           (ch+16)
+#elif defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+#define UNMASK_INT_STATUS(ch)           (ch)
+#endif
+#define TXDONE_INT_STATUS(ch)           (ch)
+
+//Control Reg0
+#define MODE_SEL_OFFSET			0
+#define CH_EBL_OFFSET			1
+#define CH_DONEINT_EBL_OFFSET		2
+#define BRST_SIZE_OFFSET		3
+#define DST_BRST_MODE_OFFSET		6
+#define SRC_BRST_MODE_OFFSET		7
+#define TRANS_CNT_OFFSET		16
+
+//Control Reg1
+#if defined (CONFIG_RALINK_RT3052)
+#define CH_UNMASKINT_EBL_OFFSET		4
+#define NEXT_UNMASK_CH_OFFSET		1
+#elif defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+#define CH_UNMASKINT_EBL_OFFSET		1
+#define NEXT_UNMASK_CH_OFFSET		3
+#endif
+#define COHERENT_INT_EBL_OFFSET		2
+#define CH_MASK_OFFSET			0
+
+
+#if defined (CONFIG_RALINK_RT3052)
+//Control Reg0
+#define DST_DMA_REQ_OFFSET		8
+#define SRC_DMA_REQ_OFFSET		12
+#elif defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620)  ||  defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+//Control Reg1
+#define DST_DMA_REQ_OFFSET		8
+#define SRC_DMA_REQ_OFFSET		16
+#endif
+
+#define GDMA_PCM0_RX0			0
+#define GDMA_PCM0_RX1			1
+#define GDMA_PCM0_TX0			2
+#define GDMA_PCM0_TX1			3
+
+#define GDMA_PCM1_RX0			4
+#define GDMA_PCM1_RX1			5
+#define GDMA_PCM1_TX0			6
+#define GDMA_PCM1_TX1			7
+
+#define GDMA_PCM_RX(i,j)		(0+((i)<<2)+j)
+#define GDMA_PCM_TX(i,j)        (2+((i)<<2)+j)
+
+#define GDMA_I2S_TX0			4
+#define GDMA_I2S_TX1			5
+#define GDMA_I2S_RX0			6
+#define GDMA_I2S_RX1			7
+
+#define GDMA_SPI_TX       13
+#define GDMA_SPI_RX       12
+
+
+// #define GDMA_DEBUG
+#ifdef GDMA_DEBUG
+#define GDMA_PRINT(fmt, args...) printk(KERN_INFO "GDMA: " fmt, ## args)
+#else
+#define GDMA_PRINT(fmt, args...) { }
+#endif
+
+/*
+ * TYPEDEFS AND STRUCTURES
+ */
+
+enum GdmaBusterMode {
+	INC_MODE=0,
+	FIX_MODE=1
+};
+
+enum GdmaBusterSize {
+	BUSTER_SIZE_4B=0, 	/* 1 transfer */
+	BUSTER_SIZE_8B=1, 	/* 2 transfer */
+	BUSTER_SIZE_16B=2,  	/* 4 transfer */
+	BUSTER_SIZE_32B=3,  	/* 8 transfer */
+	BUSTER_SIZE_64B=4  	/* 16 transfer */
+};
+
+enum GdmaDmaReqNum {
+#if defined (CONFIG_RALINK_RT3052)
+	DMA_REQ0=0,
+	DMA_NAND_REQ=1,
+	DMA_I2S_TX_REQ=2,
+	DMA_PCM_RX0_REQ=3,
+	DMA_PCM_RX1_REQ=4,
+	DMA_PCM_TX0_REQ=5,
+	DMA_PCM_TX1_REQ=6,
+	DMA_REG7=7,
+	DMA_MEM_REQ=8
+#elif defined (CONFIG_RALINK_RT3883) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) 
+	DMA_REQ0=0,
+	DMA_NAND_REQ=1,
+	DMA_I2S_TX_REQ=2,
+	DMA_I2S_RX_REQ=3,
+	DMA_PCM_RX0_REQ=4,
+	DMA_PCM_RX1_REQ=5,
+	DMA_PCM_TX0_REQ=6,
+	DMA_PCM_TX1_REQ=7,
+	DMA_CODEC0_REQ8=8,
+	DMA_CODEC1_REQ9=9,
+	DMA_REQ10=10,
+	DMA_REQ11=11,
+	DMA_REQ12=12,
+	DMA_REQ13=13,
+	DMA_REQ14=14,
+	DMA_REQ15=15,
+	
+	#if defined (CONFIG_RALINK_RT3883)
+		DMA_MEM_REQ=16
+	#elif defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) 
+		DMA_MEM_REQ=32
+	#endif
+	
+#elif defined(CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628) || defined (CONFIG_ARCH_MT7623)
+	DMA_REQ0=0,
+	DMA_NAND_REQ=1,
+	DMA_I2S_TX_REQ=2,
+	DMA_I2S_RX_REQ=3,
+	DMA_PCM_RX0_REQ=4,
+	DMA_PCM_RX1_REQ=5,
+	DMA_PCM_TX0_REQ=6,
+	DMA_PCM_TX1_REQ=7,
+	DMA_PCM_RX2_REQ=8,
+	DMA_PCM_RX3_REQ=9,
+	DMA_PCM_TX2_REQ=10,
+	DMA_PCM_TX3_REQ=11,
+	DMA_SPI_RX_REQ=12,
+	DMA_SPI_TX_REQ=13,	
+	DMA_MEM_REQ=32
+
+#elif defined (CONFIG_RALINK_RT6855A)
+	DMA_NAND_REQ=0,
+	DMA_I2S_TX_REQ=1,
+	DMA_I2S_RX_REQ=2,
+	DMA_REQ0=3,
+	DMA_PCM_RX0_REQ=4,
+	DMA_PCM_RX1_REQ=5,
+	DMA_PCM_TX0_REQ=6,
+	DMA_PCM_TX1_REQ=7,
+	DMA_CODEC0_REQ8=8,
+	DMA_CODEC1_REQ9=9,
+	DMA_REQ10=10,
+	DMA_REQ11=11,
+	DMA_REQ12=12,
+	DMA_REQ13=13,
+	DMA_REQ14=14,
+	DMA_REQ15=15,
+	DMA_MEM_REQ=32
+#else
+#error Please Choose System Type
+#endif
+};
+
+
+
+typedef struct {
+	uint32_t Src;
+	uint32_t Dst;
+	uint16_t TransCount;
+	uint8_t  SoftMode;
+	uint8_t  NextUnMaskCh;
+	uint8_t  ChMask;
+	uint8_t  CoherentIntEbl;
+	uint32_t  ChNum;
+	enum GdmaDmaReqNum SrcReqNum;
+	enum GdmaDmaReqNum DstReqNum;
+	enum GdmaBusterMode SrcBurstMode;
+	enum GdmaBusterMode DstBurstMode;
+	enum GdmaBusterSize BurstSize;
+	void (*DoneIntCallback)(uint32_t);
+	void (*UnMaskIntCallback)(uint32_t);
+} GdmaReqEntry;
+
+/*
+ * EXPORT FUNCTION
+ */
+int GdmaI2sTx(uint32_t Src, uint32_t Dst, uint8_t TxNo, uint16_t TransCount,
+		void (*DoneIntCallback)(uint32_t data), 
+		void (*UnMaskIntCallback)(uint32_t data));
+
+int GdmaI2sRx(uint32_t Src, uint32_t Dst, uint8_t RxNo, uint16_t TransCount,
+		void (*DoneIntCallback)(uint32_t data), 
+		void (*UnMaskIntCallback)(uint32_t data));
+
+int GdmaPcmRx(uint32_t Src, uint32_t Dst, uint8_t PcmNo, uint8_t RxNo, uint16_t TransCount,
+		void (*DoneIntCallback)(uint32_t data), 
+		void (*UnMaskIntCallback)(uint32_t data));
+
+int GdmaPcmTx(uint32_t Src, uint32_t Dst, uint8_t PcmNo, uint8_t TxNo, uint16_t TransCount,
+		void (*DoneIntCallback)(uint32_t data), 
+		void (*UnMaskIntCallback)(uint32_t data));
+		
+int GdmaSpiTx(uint32_t Src, uint32_t Dst, uint16_t TransCount,
+	void (*DoneIntCallback)(uint32_t data),
+	void (*UnMaskIntCallback)(uint32_t data));
+
+int GdmaSpiRx(uint32_t Src, uint32_t Dst, uint16_t TransCount,
+	void (*DoneIntCallback)(uint32_t data),
+	void (*UnMaskIntCallback)(uint32_t data));	
+
+
+int GdmaMem2Mem(uint32_t Src, uint32_t Dst, uint16_t TransCount, 
+		void (*DoneIntCallback)(uint32_t data)); 
+
+int GdmaMaskChannel(uint32_t ChNum);
+
+int GdmaUnMaskChannel(uint32_t ChNum);
+
+int GdmaReqQuickIns(uint32_t ChNum);
+
+
+#endif
Index: linux-3.10.108/arch/mips/ralink/Makefile
===================================================================
--- linux-3.10.108.orig/arch/mips/ralink/Makefile
+++ linux-3.10.108/arch/mips/ralink/Makefile
@@ -30,7 +30,6 @@ obj-$(CONFIG_MTK_MTD_NAND) +=  dev-nand.
 ifeq ($(CONFIG_RALINK_MT7621),y)
 obj-$(CONFIG_MTD_ANY_RALINK) +=  dev-nand.o
 endif
-obj-$(CONFIG_I2C_MTK) +=  i2c-slave.o
 
 obj-$(CONFIG_RALINK_RT3883) +=  ehci_ohci.o udc.o
 obj-$(CONFIG_RALINK_RT3352) +=  ehci_ohci.o udc.o
Index: linux-3.10.108/arch/mips/ralink/i2c-slave.c
===================================================================
--- linux-3.10.108.orig/arch/mips/ralink/i2c-slave.c
+++ linux-3.10.108/arch/mips/ralink/i2c-slave.c
@@ -22,16 +22,7 @@ static struct i2c_board_info mtk_i2c_inf
 		.platform_data = &eeprom_data
 	},
 	{
-		I2C_BOARD_INFO("codec_wm8960", I2S_WM8960),
-	},
-	{
-		I2C_BOARD_INFO("wm8960", ALSA_WM8960),
-	},
-	{
-		I2C_BOARD_INFO("codec_wm8751", I2S_WM8751),
-	},
-	{
-		I2C_BOARD_INFO("codec_wm8750", I2S_WM8750),
+		I2C_BOARD_INFO("es8311", 0x18),
 	},
 
 };
Index: linux-3.10.108/sound/core/Kconfig
===================================================================
--- linux-3.10.108.orig/sound/core/Kconfig
+++ linux-3.10.108/sound/core/Kconfig
@@ -7,12 +7,14 @@ config SND_PCM
 	select SND_TIMER
 
 config SND_HWDEP
+	default m if SND=m 
 	tristate
 
 config SND_RAWMIDI
 	tristate
 
 config SND_COMPRESS_OFFLOAD
+	default m if SND=m
 	tristate
 
 # To be effective this also requires INPUT - users should say:
Index: linux-3.10.108/drivers/base/regmap/Kconfig
===================================================================
--- linux-3.10.108.orig/drivers/base/regmap/Kconfig
+++ linux-3.10.108/drivers/base/regmap/Kconfig
@@ -10,9 +10,11 @@ config REGMAP
 	bool
 
 config REGMAP_I2C
+	default m 
 	tristate
 
 config REGMAP_SPI
+	default m 
 	tristate
 
 config REGMAP_MMIO
Index: linux-3.10.108/sound/soc/mtk/Kconfig
===================================================================
--- linux-3.10.108.orig/sound/soc/mtk/Kconfig
+++ linux-3.10.108/sound/soc/mtk/Kconfig
@@ -7,7 +7,6 @@ config SND_MT76XX_SOC
 	select I2C_COMPAT
 	select I2C_CHARDEV
 	select I2C_HELPER_AUTO
-	select I2C_RALINK
 	
 	help
 	  Say Y or M if you want to add support for codecs attached to
Index: linux-3.10.108/sound/soc/mtk/mt76xx_i2s.c
===================================================================
--- linux-3.10.108.orig/sound/soc/mtk/mt76xx_i2s.c
+++ linux-3.10.108/sound/soc/mtk/mt76xx_i2s.c
@@ -31,14 +31,13 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
-#include "drivers/char/ralink_gdma.h"
+#include "ralink_gdma.h"
 #include "mt76xx_i2s.h"
 
 /****************************/
 /*GLOBAL VARIABLE DEFINITION*/
 /****************************/
 extern i2s_config_type* pi2s_config;
-static int g_openFlag = 0;
 
 /****************************/
 /*FUNCTION DECLRATION		*/
@@ -46,8 +45,8 @@ static int g_openFlag = 0;
 static int mt76xx_i2s_set_fmt(struct snd_soc_dai *cpu_dai,\
 		unsigned int fmt);
 
-static int  mt76xx_i2s_shutdown(struct snd_pcm_substream *substream,
-		       struct snd_soc_dai *dai);
+//static int  mt76xx_i2s_shutdown(struct snd_pcm_substream *substream,
+//		       struct snd_soc_dai *dai);
 static int  mt76xx_i2s_startup(struct snd_pcm_substream *substream,
 		       struct snd_soc_dai *dai);
 static int mt76xx_i2s_hw_params(struct snd_pcm_substream *substream,\
@@ -58,10 +57,9 @@ static int mt76xx_i2s_rec_prepare(struct
 static int mt76xx_i2s_hw_free(struct snd_pcm_substream *substream,struct snd_soc_dai *dai);
 static int mt76xx_i2s_prepare(struct snd_pcm_substream *substream, struct snd_soc_dai *dai);
 
-//#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,20)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,14)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,20)
 static int mt76xx_i2s_drv_probe(struct platform_device *pdev);
-static void mt76xx_i2s_drv_remove(struct platform_device *pdev);
+static int mt76xx_i2s_drv_remove(struct platform_device *pdev);
 #endif
 /****************************/
 /*STRUCTURE DEFINITION		*/
@@ -77,21 +75,14 @@ static struct snd_soc_dai_ops mt76xx_i2s
 	.set_fmt   = mt76xx_i2s_set_fmt,
 	//.set_sysclk = mt76xx_i2s_set_sysclk,
 };
-//#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,20)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,14)
+
 const struct snd_soc_component_driver mt76xx_i2s_component = {
 	.name		= "mt76xx-i2s",
 };
-#endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
 struct snd_soc_dai_driver mt76xx_i2s_dai = {
-#else
-struct snd_soc_dai mt76xx_i2s_dai = {
-	.name = "mtk-i2s",
-#endif
 	.playback = {
-		.channels_min = 1,
+		.channels_min = 2,
 		.channels_max = 2,
 		.rates = (SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_11025|\
 		SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_22050|SNDRV_PCM_RATE_32000|\
@@ -101,7 +92,7 @@ struct snd_soc_dai mt76xx_i2s_dai = {
 				SNDRV_PCM_FMTBIT_S24_LE),
 	},
 	.capture = {
-		.channels_min = 1,
+		.channels_min = 2,
 		.channels_max = 2,
 		.rates = (SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_11025|\
 				SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_22050|SNDRV_PCM_RATE_32000|\
@@ -153,9 +144,9 @@ static int mt76xx_i2s_rec_prepare(struct
 	i2s_config_type* rtd = (i2s_config_type*)substream->runtime->private_data;
 	rtd->pss[SNDRV_PCM_STREAM_CAPTURE] = substream;
 	if(! rtd->i2sStat[SNDRV_PCM_STREAM_CAPTURE]) {
+		gdma_En_Switch(rtd, STREAM_CAPTURE, GDMA_I2S_EN);
 		i2s_reset_rx_param(rtd);
 		i2s_rx_config(rtd);
-		gdma_En_Switch(rtd, STREAM_CAPTURE, GDMA_I2S_EN);
 
 		if(rtd->bTxDMAEnable==0)
 			i2s_clock_enable(rtd);
@@ -166,25 +157,26 @@ static int mt76xx_i2s_rec_prepare(struct
 	return 0;
 }
 
-static int  mt76xx_i2s_shutdown(struct snd_pcm_substream *substream,
+/*static int  mt76xx_i2s_shutdown(struct snd_pcm_substream *substream,
 		       struct snd_soc_dai *dai)
 {
 	//i2s_config_type* rtd = (i2s_config_type*)substream->runtime->private_data;
 	//printk("******* %s *******\n", __func__);
 	return 0;
 }
-
+*/
 static int  mt76xx_i2s_startup(struct snd_pcm_substream *substream,
 		       struct snd_soc_dai *dai)
 {
-
-	//printk("******* %s *******\n", __func__);
-    	if((!pi2s_config->i2sStat[SNDRV_PCM_STREAM_PLAYBACK]) && (!pi2s_config->i2sStat[SNDRV_PCM_STREAM_CAPTURE])){
+    if((!pi2s_config->i2sStat[SNDRV_PCM_STREAM_PLAYBACK]) && 
+	   (!pi2s_config->i2sStat[SNDRV_PCM_STREAM_CAPTURE]) && 
+	   (pi2s_config->mmap_index == 0)){
 		i2s_startup();
     		if(!pi2s_config)
     			return -1;
     		i2s_reset_config(pi2s_config);
-    	}
+			
+    }
 	substream->runtime->private_data = pi2s_config;
 	return 0;
 }
@@ -193,10 +185,9 @@ static int mt76xx_i2s_hw_params(struct s
 				struct snd_pcm_hw_params *params,\
 				struct snd_soc_dai *dai){
 	unsigned int srate = 0;
-	unsigned long data;
+	//unsigned long data;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	i2s_config_type* rtd = runtime->private_data;
-
 	//printk("******* %s *******\n", __func__);
 	switch(params_rate(params)){
 	case 8000:
@@ -219,12 +210,13 @@ static int mt76xx_i2s_hw_params(struct s
 		//MSG("audio sampling rate %u should be %d ~ %d Hz\n", (u32)params_rate(params), MIN_SRATE_HZ, MAX_SRATE_HZ);
 		break;
 	}
-	if(srate){
+	if(srate){ 
 		if((rtd->bRxDMAEnable != GDMA_I2S_EN) && (rtd->bTxDMAEnable != GDMA_I2S_EN)){
 			rtd->srate = srate;
 			MSG("set audio sampling rate to %d Hz\n", rtd->srate);
 		}
 	}
+	
 
 	return 0;
 }
@@ -268,8 +260,7 @@ static int mt76xx_i2s_prepare(struct snd
 	return 0;
 }
 
-//#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,20)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,14)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,20)
 static int mt76xx_i2s_drv_probe(struct platform_device *pdev)
 {
 	//printk("****** %s ******\n", __func__);
@@ -277,9 +268,10 @@ static int mt76xx_i2s_drv_probe(struct p
 					&mt76xx_i2s_dai, 1);
 }
 
-static void mt76xx_i2s_drv_remove(struct platform_device *pdev)
+static int mt76xx_i2s_drv_remove(struct platform_device *pdev)
 {
 	snd_soc_unregister_component(&pdev->dev);	
+	return 0;
 }
 
 static struct platform_driver mt76xx_i2s_driver = {
Index: linux-3.10.108/sound/soc/mtk/mt76xx_i2s.h
===================================================================
--- linux-3.10.108.orig/sound/soc/mtk/mt76xx_i2s.h
+++ linux-3.10.108/sound/soc/mtk/mt76xx_i2s.h
@@ -14,5 +14,5 @@
 #include <linux/fs.h>
 #endif
 
-#include "../../../drivers/char/i2s/core/i2s_ctrl.h"
+#include "i2s_ctrl.h"
 #endif /* MTK_I2S_H_ */
Index: linux-3.10.108/sound/soc/mtk/mt76xx_machine.c
===================================================================
--- linux-3.10.108.orig/sound/soc/mtk/mt76xx_machine.c
+++ linux-3.10.108/sound/soc/mtk/mt76xx_machine.c
@@ -32,12 +32,9 @@
 #include <linux/i2c.h>
 #include <linux/ioport.h>
 #include <linux/delay.h>
-#include "drivers/char/ralink_gdma.h"
+#include "ralink_gdma.h"
 #include "mt76xx_i2s.h"
 #include "mt76xx_machine.h"
-#if defined(CONFIG_SND_SOC_WM8960)
-#include "../codecs/wm8960.h"
-#endif
 
 #define I2C_AUDIO_DEV_ID	(0)
 /****************************/
@@ -50,104 +47,48 @@ extern unsigned long i2s_codec_12Mhz[11]
 static int mt76xx_codec_clock_hwparams(struct snd_pcm_substream *substream,\
 				struct snd_pcm_hw_params *params);
 static int mt76xx_codec_startup(struct snd_pcm_substream *substream);
-static int mt76xx_codec_init(struct snd_soc_codec *codec);
-
-/****************************/
-/*GLOBAL VARIABLE DEFINITION*/
-/****************************/
-//#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,20)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,14)
+static int mt76xx_codec_init(struct snd_soc_pcm_runtime *rtd);
 extern struct snd_soc_dai_driver mt76xx_i2s_dai;
 extern struct snd_soc_platform_driver mt76xx_soc_platform;
-#else
-extern struct snd_soc_dai mt76xx_i2s_dai;
-extern struct snd_soc_platform mt76xx_soc_platform;
-#endif
-
-
 struct platform_device *mt76xx_audio_device;
 
-#if defined(CONFIG_SND_SOC_WM8960)
-extern struct snd_soc_dai wm8960_dai;
-extern struct snd_soc_codec_device soc_codec_dev_wm8960;
-#endif
-
-/****************************/
-/*STRUCTURE DEFINITION		*/
-/****************************/
 static struct snd_soc_ops mtk_audio_ops = {
 	.hw_params = mt76xx_codec_clock_hwparams,
 	.startup = mt76xx_codec_startup,
 };
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,20)
-#define CODEC_NAME	"wm8960.1-001a"
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,14)
-#define CODEC_NAME      "wm8960.0-001a"
-#endif
-
 static struct snd_soc_dai_link mtk_audio_dai = {
 	.name = "mtk_dai",
 	.stream_name = "WMserious PCM",
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
 	.cpu_dai_name	= "mt76xx-i2s",
-	.codec_dai_name	= "wm8960-hifi",
-	.codec_name	= CODEC_NAME,
+	.codec_dai_name	= "es8311-hifi",
+	.codec_name	= "es8311.0-0018",
 	.platform_name	= "mt76xx-pcm",
 	.ignore_pmdown_time = true,
-#else
-	.cpu_dai = &mt76xx_i2s_dai,
-	.codec_dai = &wm8960_dai,
-#endif
 	.init = mt76xx_codec_init,
 	.ops = &mtk_audio_ops,
 };
 
 static struct snd_soc_card mtk_audio_card = {
 	.name = "MTK APSoC I2S",
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
 	.owner = THIS_MODULE,
-#else
-	.platform = &mt76xx_soc_platform,
-#endif
 	.dai_link = &mtk_audio_dai,//I2S/Codec
 	.num_links = 1,
 };
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
-#else
-/*device init: card,codec,codec data*/
-static struct snd_soc_device mtk_audio_devdata = {
-	.card = &mtk_audio_card,
-	.codec_dev = &soc_codec_dev_wm8960,
-	.codec_data = NULL,
-};
-#endif
-
-/****************************/
-/*Function Body				*/
-/****************************/
-
 static int mt76xx_codec_clock_hwparams(struct snd_pcm_substream *substream,
 				struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *p = substream->private_data;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
 	struct snd_soc_dai *codec_dai = p->codec_dai;
-#else
-	struct snd_soc_dai *codec_dai = p->dai->codec_dai;
-#endif
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	i2s_config_type* rtd = runtime->private_data;
-	unsigned long data,index = 0;
-	unsigned long* pTable;
-	int mclk,ret,targetClk = 0;
+	unsigned long index = 0;
+	int mclk,targetClk = 0;
 
-	//printk("******* %s *******\n", __func__);
 	/*For duplex mode, avoid setting twice.*/
 	if((rtd->bRxDMAEnable == GDMA_I2S_EN) || (rtd->bTxDMAEnable == GDMA_I2S_EN))
 		return 0;
-	//printk("%s:%d \n",__func__,__LINE__);
 #if defined(CONFIG_I2S_MCLK_12MHZ)
 	mclk = 12000000;
 #elif defined(CONFIG_I2S_MCLK_12P288MHZ)
@@ -208,41 +149,13 @@ static int mt76xx_codec_clock_hwparams(s
 		//MSG("audio sampling rate %u should be %d ~ %d Hz\n", (u32)params_rate(params), MIN_SRATE_HZ, MAX_SRATE_HZ);
 		break;
 	}
-#if defined(CONFIG_SND_SOC_WM8960)
-	/*
-	 * There is a fixed divide by 4 in the PLL and a selectable
-	 * divide by N after the PLL which should be set to divide by 2 to meet this requirement.
-	 * */
-	ret = snd_soc_dai_set_pll(codec_dai, 0, 0,mclk, targetClk*2);
-	/* From app notes: allow Vref to stabilize to reduce clicks */
-	if(rtd->slave_en){
-		printk("WM8960 is in master mode\n");
-		ret = snd_soc_dai_set_clkdiv(codec_dai, WM8960_DCLKDIV, 0x1c4);
-		ret = snd_soc_dai_set_clkdiv(codec_dai, WM8960_SYSCLKDIV, 0x5);
-	}
 
-#endif
 	if(!rtd->slave_en)
 		snd_soc_dai_set_fmt(codec_dai,SND_SOC_DAIFMT_CBS_CFS|SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF);
 	else{
 		snd_soc_dai_set_fmt(codec_dai,SND_SOC_DAIFMT_CBM_CFM|SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF);
 	}
 	mdelay(5);
-
-#if defined(CONFIG_SND_SOC_WM8960)
-#if defined(CONFIG_I2S_MCLK_12MHZ)
-	pTable = i2s_codec_12Mhz;
-	data = pTable[index];
-#else
-	pTable = i2s_codec_12p288Mhz;
-	data = pTable[index];
-#endif
-	if(rtd->codec_pll_en)
-		ret = snd_soc_dai_set_clkdiv(codec_dai, WM8960_DACDIV, (data<<3)|0x5);
-	else
-		ret = snd_soc_dai_set_clkdiv(codec_dai, WM8960_DACDIV, (data<<3|0x4));
-#endif
-
 	return 0;
 }
 
@@ -251,21 +164,49 @@ static int mt76xx_codec_startup(struct s
 	//printk("******* %s *******\n", __func__);
 	return 0;
 }
-static int mt76xx_codec_init(struct snd_soc_codec *codec)
+static int mt76xx_codec_init(struct snd_soc_pcm_runtime *rtd)
 {
 
 	//printk("******* %s *******\n", __func__);
 	return 0;
 }
 
+static struct i2c_board_info i2c_board_info[] = {
+	{
+        I2C_BOARD_INFO("es8311", 0x18),
+	}
+};
+
+static struct platform_device *soc_mtk_i2s_dev;
+static struct platform_device *soc_mtk_pcm_dev;
+
 static int __init mt76xx_machine_init(void)
 {
 	//struct snd_soc_device *socdev = &mtk_audio_devdata;
-	struct i2c_adapter *adapter = NULL;
-	struct i2c_client *client = NULL;
+	//struct i2c_adapter *adapter = NULL;
+	//struct i2c_client *client = NULL;
 	int ret = 0;
+	struct i2c_adapter *adapter = NULL;
+        struct i2c_client *client = NULL;
 
-	printk("******* %s *******\n", __func__);
+	adapter = i2c_get_adapter(I2C_AUDIO_DEV_ID);
+	if (!adapter)
+		return -ENODEV;
+	client = i2c_new_device(adapter, &i2c_board_info[0]);
+	if (!client)
+		return -ENODEV;
+	i2c_get_clientdata(client);
+	i2c_put_adapter(adapter);
+
+	soc_mtk_i2s_dev =
+		platform_device_register_simple("mt76xx-i2s", -1, NULL, 0);
+	if (IS_ERR(soc_mtk_i2s_dev))
+		return PTR_ERR(soc_mtk_i2s_dev);
+
+	soc_mtk_pcm_dev =
+		platform_device_register_simple("mt76xx-pcm", -1, NULL, 0);
+	if (IS_ERR(soc_mtk_pcm_dev))
+		return PTR_ERR(soc_mtk_pcm_dev);
 
 	mt76xx_audio_device = platform_device_alloc("soc-audio",-1);
 	if (mt76xx_audio_device == NULL) {
@@ -305,17 +246,17 @@ err_device_alloc:
 
 static void __exit mt76xx_machine_exit(void)
 {	
-	printk("******* %s *******\n", __func__);
 
 	platform_device_unregister(mt76xx_audio_device);
-//#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,20)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,14)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,20)
 	/* Do nothing */
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
 	snd_soc_unregister_platform(&mt76xx_audio_device->dev);
 #else
 	snd_soc_unregister_platform(&mt76xx_soc_platform);
 #endif
+	platform_device_unregister(soc_mtk_i2s_dev);
+	platform_device_unregister(soc_mtk_pcm_dev);
 
 	mt76xx_audio_device = NULL;
 }
Index: linux-3.10.108/sound/soc/mtk/mt76xx_pcm.c
===================================================================
--- linux-3.10.108.orig/sound/soc/mtk/mt76xx_pcm.c
+++ linux-3.10.108/sound/soc/mtk/mt76xx_pcm.c
@@ -32,7 +32,9 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
-#include "drivers/char/ralink_gdma.h"
+#include <linux/delay.h>
+
+#include "ralink_gdma.h"
 #include "mt76xx_i2s.h"
 
 #define GDMA_PAGE_SIZE 		I2S_PAGE_SIZE
@@ -49,8 +51,7 @@ extern void i2s_tx_end_sleep_on(i2s_conf
 extern void i2s_rx_end_sleep_on(i2s_config_type* ptri2s_config);
 
 static int mt76xx_pcm_open(struct snd_pcm_substream *substream);
-static int mt76xx_pcm_new(struct snd_card *card,\
-	struct snd_soc_dai *dai, struct snd_pcm *pcm);
+static int mt76xx_pcm_new(struct snd_soc_pcm_runtime *rtd);
 static void mt76xx_pcm_free(struct snd_pcm *pcm);
 static int mt76xx_pcm_close(struct snd_pcm_substream *substream);
 static snd_pcm_uframes_t mt76xx_pcm_pointer(struct snd_pcm_substream *substream);
@@ -66,8 +67,7 @@ static int mt76xx_pcm_hw_free(struct snd
 static int mt76xx_pcm_free_dma_buffer(struct snd_pcm_substream *substream,int stream);
 static int mt76xx_pcm_allocate_dma_buffer(struct snd_pcm_substream *substream,int stream);
 
-//#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,20)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,14)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,10,20)
 static int mt76xx_platform_drv_probe(struct platform_device *pdev);
 static int mt76xx_platform_drv_remove(struct platform_device *pdev);
 #endif
@@ -84,7 +84,8 @@ static const struct snd_pcm_hardware mt7
 				SNDRV_PCM_INFO_PAUSE |
 				SNDRV_PCM_INFO_RESUME),
 #endif
-	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE|SNDRV_PCM_FMTBIT_S24_LE,
+	.rates 			= SNDRV_PCM_RATE_8000_48000,
 	.period_bytes_min	= GDMA_PAGE_SIZE,
 	.period_bytes_max	= GDMA_PAGE_SIZE,
 	.periods_min		= 1,
@@ -124,7 +125,7 @@ struct snd_soc_platform mt76xx_soc_platf
 
 static int mt76xx_pcm_close(struct snd_pcm_substream *substream){
 
-	//printk("******* %s *********\n", __func__);
+	//MSG("******* %s *********\n", __func__);
 	return 0;
 }
 
@@ -133,16 +134,16 @@ static snd_pcm_uframes_t mt76xx_pcm_poin
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	i2s_config_type* rtd = runtime->private_data;
 	unsigned int offset = 0;
-	int buff_frame_bond = bytes_to_frames(runtime, GDMA_PAGE_SIZE);
-	//printk("\n******* %s *********\n", __func__);
+	//int buff_frame_bond = bytes_to_frames(runtime, GDMA_PAGE_SIZE);
+	//MSG("\n******* %s *********\n", __func__);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
 		offset = bytes_to_frames(runtime, GDMA_PAGE_SIZE*rtd->tx_r_idx);
-		//printk("r:%d w:%d (%d) \n",rtd->tx_r_idx,rtd->tx_w_idx,(runtime->control->appl_ptr/buff_frame_bond)%GDMA_PAGE_NUM);
+		//MSG("r:%d w:%d (%d) \n",rtd->tx_r_idx,rtd->tx_w_idx,(runtime->control->appl_ptr/buff_frame_bond)%GDMA_PAGE_NUM);
 	}
 	else{
 		offset = bytes_to_frames(runtime, GDMA_PAGE_SIZE*rtd->rx_w_idx);
-		//printk("w:%d r:%d appl_ptr:%x\n",rtd->rx_w_idx,rtd->rx_r_idx,(runtime->control->appl_ptr/buff_frame_bond)%GDMA_PAGE_NUM);
+		//MSG("w:%d r:%d appl_ptr:%x\n",rtd->rx_w_idx,rtd->rx_r_idx,(runtime->control->appl_ptr/buff_frame_bond)%GDMA_PAGE_NUM);
 	}
 	return offset;
 }
@@ -152,22 +153,27 @@ static int mt76xx_pcm_trigger(struct snd
 {
 	int ret = 0;
 	i2s_config_type* rtd = (i2s_config_type*)substream->runtime->private_data;
-	struct snd_pcm_runtime *runtime= substream->runtime;
-/*
-	printk("******* %s *********\n", __func__);
-	printk("trigger cmd:%s\n",(cmd==SNDRV_PCM_TRIGGER_START)?"START":\
+	//struct snd_pcm_runtime *runtime= substream->runtime;
+
+	//MSG("******* %s *********\n", __func__);
+	MSG("%s:trigger cmd:%s\n",(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)?"PLAYBACK":"CAPTURE",\
+			(cmd==SNDRV_PCM_TRIGGER_START)?"START":\
 			(cmd==SNDRV_PCM_TRIGGER_RESUME)?"RESUME":\
 			(cmd==SNDRV_PCM_TRIGGER_PAUSE_RELEASE)?"PAUSE_RELEASE":\
 			(cmd==SNDRV_PCM_TRIGGER_STOP)?"STOP":\
 			(cmd==SNDRV_PCM_TRIGGER_SUSPEND)?"SUSPEND":\
 			(cmd==SNDRV_PCM_TRIGGER_PAUSE_PUSH)?"PAUSE_PUSH":"default");
-*/
+
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 			rtd->bTrigger[SNDRV_PCM_STREAM_PLAYBACK] = 1;
+			rtd->dmaStat[SNDRV_PCM_STREAM_PLAYBACK] = 1;
+			gdma_unmask_handler(GDMA_I2S_TX0);
 		} else {
 			rtd->bTrigger[SNDRV_PCM_STREAM_CAPTURE] = 1;
+			rtd->dmaStat[SNDRV_PCM_STREAM_CAPTURE] = 1;
+			gdma_unmask_handler(GDMA_I2S_RX0);
 		}
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
@@ -210,16 +216,16 @@ static int mt76xx_pcm_copy(struct snd_pc
         int rx_r_idx = 0;
         char *hwbuf = NULL;
 
-	//printk("******* %s *********\n", __func__);
+	//MSG("******* %s *********\n", __func__);
 	hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
 	//MSG("%s bur:%x\n",__func__,hwbuf);
-	//printk("hw_ptr:%d, buffer_size:%d, appl_prt:%d, boundary:%d\n", 
+	//MSG("hw_ptr:%d, buffer_size:%d, appl_prt:%d, boundary:%d\n", 
 	//		runtime->status->hw_ptr, runtime->buffer_size, runtime->control->appl_ptr, runtime->boundary);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
 		rtd->tx_w_idx = (rtd->tx_w_idx+1)%MAX_I2S_PAGE;
                 tx_w_idx = rtd->tx_w_idx;
-                //printk("put TB[%d - %x] for user write\n",rtd->tx_w_idx,pos);
+                //MSG("put TB[%d - %x] for user write\n",rtd->tx_w_idx,pos);
                 copy_from_user(rtd->pMMAPTxBufPtr[tx_w_idx], (char*)buf, I2S_PAGE_SIZE);	
 	}
 	else{
@@ -232,11 +238,53 @@ static int mt76xx_pcm_copy(struct snd_pc
 
 static int mt76xx_pcm_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
 {
-        int ret;
+        int ret = 0;
+		int i = 0;
         unsigned long size;
+		struct snd_dma_buffer *buf = &substream->dma_buffer;
+		i2s_config_type* rtd = (i2s_config_type*)substream->runtime->private_data;
+		int  dir = substream->stream;
+
+		mt76xx_pcm_free_dma_buffer(substream,substream->stream);
+		i2s_mmap_alloc(I2S_TOTAL_PAGE_SIZE,dir);
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			rtd->is_tx_mmap = 1;
+		else
+			rtd->is_rx_mmap = 1;
 
-        size = vma->vm_end-vma->vm_start;
-        //printk("******* %s: size :%x end:%x start:%x *******\n", __func__,size,vma->vm_end,vma->vm_start);
+		if(!buf->area){
+			MSG("<><><><><><>mt76xx_pcm_mmap<><><><>\n");
+			buf->dev.dev = NULL;
+			buf->private_data = NULL;
+			if(dir == SNDRV_PCM_STREAM_PLAYBACK){
+				for( i = 0 ; i < MAX_I2S_PAGE ; i ++ ){
+					rtd->pMMAPTxBufPtr[i] = rtd->pMMAPBufPtr[i];
+					memset(rtd->pMMAPTxBufPtr[i], 0, I2S_PAGE_SIZE);
+				}
+				buf->area = rtd->pMMAPTxBufPtr[0];
+			}
+			else{
+				for( i = 0 ; i < MAX_I2S_PAGE ; i ++ ){
+					rtd->pMMAPRxBufPtr[i] = rtd->pMMAPBufPtr[i + MAX_I2S_PAGE];
+					memset(rtd->pMMAPRxBufPtr[i], 0, I2S_PAGE_SIZE);
+				}
+				buf->area = rtd->pMMAPRxBufPtr[0];		
+			}
+			if (!buf->area)
+				return -ENOMEM;
+			buf->bytes = GDMA_TOTAL_PAGE_SIZE;
+		
+			buf->dev.type = SNDRV_DMA_TYPE_DEV;
+			buf->addr = i2s_mmap_phys_addr(rtd,dir);
+			
+			snd_pcm_set_runtime_buffer(substream, buf);
+		}
+
+		if(rtd->is_rx_mmap || rtd->is_tx_mmap)
+			rtd->bALSAMMAPEnable = 1;
+		
+        size = vma->vm_end - vma->vm_start;
+        MSG("******* %s: size :%lx end:%lx start:%lx *******\n", __func__,size,vma->vm_end,vma->vm_start);
         ret = i2s_mmap_remap(vma, size);
 
         return ret;
@@ -250,25 +298,25 @@ static int mt76xx_pcm_prepare(struct snd
 	//runtime->buffer_size = GDMA_PAGE_NUM*GDMA_PAGE_SIZE;
 	//runtime->boundary = (GDMA_PAGE_NUM*GDMA_PAGE_SIZE)/4;
 
-	//printk("******* %s *******\n", __func__);
+	MSG("******* %s *******\n", __func__);
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		//printk("===== %s:%s:%d =====\n", __FILE__, __func__, __LINE__);
-		mt76xx_pcm_allocate_dma_buffer(substream,SNDRV_PCM_STREAM_PLAYBACK);
+		//MSG("===== %s:%s:%d =====\n", __FILE__, __func__, __LINE__);
+		//mt76xx_pcm_allocate_dma_buffer(substream,SNDRV_PCM_STREAM_PLAYBACK);
 		
 		if(! rtd->dmaStat[SNDRV_PCM_STREAM_PLAYBACK]){
+			MSG("******* prepare: SNDRV_PCM_STREAM_PLAYBACK*******\n");
 			i2s_page_prepare(rtd,STREAM_PLAYBACK);
 			tasklet_init(&i2s_tx_tasklet, i2s_tx_task, (u32)rtd);
-			rtd->dmaStat[SNDRV_PCM_STREAM_PLAYBACK] = 1;
-			gdma_unmask_handler(GDMA_I2S_TX0);
+			//start or stop dma ?
 		}
 	} else {
-		mt76xx_pcm_allocate_dma_buffer(substream,SNDRV_PCM_STREAM_CAPTURE);
+		//mt76xx_pcm_allocate_dma_buffer(substream,SNDRV_PCM_STREAM_CAPTURE);
 
 		if(! rtd->dmaStat[SNDRV_PCM_STREAM_CAPTURE]){
+			MSG("******* prepare: SNDRV_PCM_STREAM_CAPTURE*******\n");
 			i2s_page_prepare(rtd,STREAM_CAPTURE); /* TX:enLabel=1; RX:enLabel=2 */
 			tasklet_init(&i2s_rx_tasklet, i2s_rx_task, (u32)rtd);
-			rtd->dmaStat[SNDRV_PCM_STREAM_CAPTURE] = 1;
-			gdma_unmask_handler(GDMA_I2S_RX0);
+			//rtd->dmaStat[SNDRV_PCM_STREAM_CAPTURE] = 1;
 		}
 	}
 
@@ -279,12 +327,17 @@ static int mt76xx_pcm_prepare(struct snd
 static int mt76xx_pcm_hw_params(struct snd_pcm_substream *substream,
 				 struct snd_pcm_hw_params *hw_params)
 {
-	struct snd_pcm_runtime *runtime = substream->runtime;
+	//struct snd_pcm_runtime *runtime = substream->runtime;
+	/*
 	i2s_config_type *rtd = (i2s_config_type*)runtime->private_data;
+	*/
 	int ret,i;
 	ret = i = 0;
+	
+	
+
 
-	//printk("******* %s *******\n", __func__);
+	//MSG("******* %s *******\n", __func__);
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
 		//i2s_page_prepare(rtd,STREAM_PLAYBACK);
 	} else {
@@ -297,25 +350,24 @@ static int mt76xx_pcm_hw_params(struct s
 static int mt76xx_pcm_hw_free(struct snd_pcm_substream *substream)
 {
 	i2s_config_type* rtd = (i2s_config_type*)substream->runtime->private_data;
-	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	//struct snd_dma_buffer *buf = &substream->dma_buffer;
 
-	//printk("******* %s *******\n", __func__);
+	MSG("******* %s *******\n", __func__);
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
 		if(rtd->dmaStat[SNDRV_PCM_STREAM_PLAYBACK]){
-
 			gdma_En_Switch(rtd,STREAM_PLAYBACK,GDMA_I2S_DIS);
 			i2s_tx_end_sleep_on(rtd);
 			tasklet_kill(&i2s_tx_tasklet);
-			i2s_tx_disable(rtd);
+			i2s_tx_disable(rtd);			
 			//mt76xx_pcm_free_dma_buffer(substream,substream->stream);
 			i2s_page_release(rtd,STREAM_PLAYBACK);
 			rtd->dmaStat[SNDRV_PCM_STREAM_PLAYBACK] = 0;
 		}
 		mt76xx_pcm_free_dma_buffer(substream,substream->stream);
+		rtd->is_tx_mmap = 0;
 	}
 	else{
 		if(rtd->dmaStat[SNDRV_PCM_STREAM_CAPTURE]){
-
 			gdma_En_Switch(rtd,STREAM_CAPTURE,GDMA_I2S_DIS);
 			i2s_rx_end_sleep_on(rtd);
 			tasklet_kill(&i2s_rx_tasklet);
@@ -325,6 +377,7 @@ static int mt76xx_pcm_hw_free(struct snd
 			rtd->dmaStat[SNDRV_PCM_STREAM_CAPTURE] = 0;
 		}
 		mt76xx_pcm_free_dma_buffer(substream,substream->stream);
+		rtd->is_rx_mmap = 0;
 	}
 	return 0;
 }
@@ -337,13 +390,17 @@ static int mt76xx_pcm_free_dma_buffer(st
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	i2s_config_type* rtd = (i2s_config_type*)substream->runtime->private_data;
 
-	//printk("******* %s *******\n", __func__);
 	if (!buf->area)
 		return 0;
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
 		i2s_memPool_free(rtd,STREAM_PLAYBACK);
-	else
+		printk("playback free_dma_buffer\n");
+	}
+	else{
 		i2s_memPool_free(rtd,STREAM_CAPTURE);
+		printk("capture free_dma_buffer\n");
+	}
+	printk("ptri2s_config->mmap_index:%d\n",rtd->mmap_index);
 	buf->area = NULL;
 	snd_pcm_set_runtime_buffer(substream, NULL);
 	return 0;
@@ -356,30 +413,32 @@ static int mt76xx_pcm_allocate_dma_buffe
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	i2s_config_type* rtd = (i2s_config_type*)substream->runtime->private_data;
 
-	//printk("******* %s *******\n", __func__);
+	//MSG("******* %s *******\n", __func__);
 	if(!buf->area){
-#if defined(CONFIG_I2S_MMAP)
-		//printk("\n############## MMAP ##############\n");
-		buf->dev.type = SNDRV_DMA_TYPE_DEV;
-#else
-		buf->dev.type = SNDRV_DMA_TYPE_UNKNOWN;
-#endif
 		buf->dev.dev = NULL;
 		buf->private_data = NULL;
-		if(stream == SNDRV_PCM_STREAM_PLAYBACK)
+		if(stream == SNDRV_PCM_STREAM_PLAYBACK){
 			buf->area = i2s_memPool_Alloc(rtd,STREAM_PLAYBACK);
-		else
+		}
+		else{
 			buf->area = i2s_memPool_Alloc(rtd,STREAM_CAPTURE);
 
+		}
 		if (!buf->area)
 			return -ENOMEM;
 		buf->bytes = GDMA_TOTAL_PAGE_SIZE;
-#if defined(CONFIG_I2S_MMAP)
-		buf->addr = i2s_mmap_phys_addr(rtd);
-#endif
+
+		if(rtd->is_tx_mmap || rtd->is_rx_mmap){
+			buf->dev.type = SNDRV_DMA_TYPE_DEV;
+			buf->addr = i2s_mmap_phys_addr(rtd,stream);
+		}
+		else{
+			buf->dev.type = SNDRV_DMA_TYPE_UNKNOWN;
+		}
+
 		snd_pcm_set_runtime_buffer(substream, buf);
 	} else{
-		//printk("Buffer have been allocated!\n");
+		//MSG("Buffer have been allocated!\n");
 	}
 
 	return 0;
@@ -389,10 +448,11 @@ static int mt76xx_pcm_open(struct snd_pc
 {
 	struct snd_pcm_runtime *runtime= substream->runtime;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	i2s_config_type* rtd = (i2s_config_type*)substream->runtime->private_data;
 	int stream = substream->stream;
 	int ret = 0;
 
-	//printk("******* %s *******\n", __func__);
+	//MSG("******* %s *******\n", __func__);
 	snd_soc_set_runtime_hwparams(substream, &mt76xx_pcm_hwparam);
 	/* ensure that buffer size is a multiple of period size */
 	ret = snd_pcm_hw_constraint_integer(runtime,
@@ -400,6 +460,9 @@ static int mt76xx_pcm_open(struct snd_pc
 	if (ret < 0)
 		goto out;
 
+	ret = snd_pcm_hw_constraint_minmax(runtime,SNDRV_PCM_HW_PARAM_BUFFER_SIZE,runtime->hw.period_bytes_min*2,runtime->hw.period_bytes_min*2);
+	if (ret < 0)
+		goto out;
 #if 1
 	if(stream == SNDRV_PCM_STREAM_PLAYBACK){
 		ret = mt76xx_pcm_allocate_dma_buffer(substream,
@@ -410,7 +473,6 @@ static int mt76xx_pcm_open(struct snd_pc
 				SNDRV_PCM_STREAM_CAPTURE);
 	}
 #endif
-
 	if (ret)
 		goto out;
 
@@ -423,37 +485,35 @@ static int mt76xx_pcm_open(struct snd_pc
 
 
 
-static int mt76xx_pcm_new(struct snd_card *card,
-	struct snd_soc_dai *dai, struct snd_pcm *pcm)
+static int mt76xx_pcm_new(struct snd_soc_pcm_runtime *rtd)
 {
-	int ret = 0;
+//	int ret = 0;
 
-	//printk("******* %s *******\n", __func__);
+	//MSG("******* %s *******\n", __func__);
 	return 0;
 }
 
 static void mt76xx_pcm_free(struct snd_pcm *pcm)
 {
-	struct snd_pcm_substream *substream;
+	/*struct snd_pcm_substream *substream;
 	struct snd_dma_buffer *buf;
 	i2s_config_type* rtd;
 	int stream;
-
-	//printk("******* %s *******\n", __func__);
-	return 0;
+*/
+	//MSG("******* %s *******\n", __func__);
+	//return 0;
 }
 
-//#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,20)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,14)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,20)
 static int mt76xx_platform_drv_probe(struct platform_device *pdev)
 {
-	//printk("******* %s *******\n", __func__);
+	//MSG("******* %s *******\n", __func__);
 	return snd_soc_register_platform(&pdev->dev, &mt76xx_soc_platform);
 }
 
 static int mt76xx_platform_drv_remove(struct platform_device *pdev)
 {
-	//printk("******* %s *******\n", __func__);
+	//MSG("******* %s *******\n", __func__);
 	snd_soc_unregister_platform(&pdev->dev);
 	return 0;
 }
@@ -471,7 +531,7 @@ static struct platform_driver mt76xx_pcm
 static int __init mt76xx_pcm_init(void)
 {
 
-	//printk("******* %s *******\n", __func__);
+	//MSG("******* %s *******\n", __func__);
 	return platform_driver_register(&mt76xx_pcm_driver);
 }
 
@@ -483,13 +543,13 @@ static void __exit mt76xx_pcm_exit(void)
 static int __init mt76xx_pcm_init(void)
 {
 
-	//printk("******* %s *******\n", __func__);
+	//MSG("******* %s *******\n", __func__);
 	return snd_soc_register_platform(&mt76xx_soc_platform);
 }
 
 static void __exit mt76xx_pcm_exit(void)
 {
-	//printk("******* %s *******\n", __func__);
+	//MSG("******* %s *******\n", __func__);
 	snd_soc_unregister_platform(&mt76xx_soc_platform);
 }
 #endif
@@ -499,3 +559,4 @@ module_exit(mt76xx_pcm_exit);
 MODULE_AUTHOR("Dora Chen");
 MODULE_DESCRIPTION("MTK APSoC I2S DMA driver");
 MODULE_LICENSE("GPL");
+
Index: linux-3.10.108/sound/soc/soc-core.c
===================================================================
--- linux-3.10.108.orig/sound/soc/soc-core.c
+++ linux-3.10.108/sound/soc/soc-core.c
@@ -2111,22 +2111,31 @@ EXPORT_SYMBOL_GPL(snd_soc_free_ac97_code
 
 unsigned int snd_soc_read(struct snd_soc_codec *codec, unsigned int reg)
 {
-	unsigned int ret;
+	int ret = 0;
+	int val = 0;
 
-	ret = codec->read(codec, reg);
-	dev_dbg(codec->dev, "read %x => %x\n", reg, ret);
-	trace_snd_soc_reg_read(codec, reg, ret);
-
-	return ret;
+	if (codec->control_data)
+		ret = regmap_read(codec->control_data, reg, &val);
+	else if (codec->read)
+		val = codec->read(codec, reg);
+	else
+		ret = -EIO;
+	if(ret < 0)
+		return ret;
+	else
+		return val;
 }
 EXPORT_SYMBOL_GPL(snd_soc_read);
 
 unsigned int snd_soc_write(struct snd_soc_codec *codec,
 			   unsigned int reg, unsigned int val)
 {
-	dev_dbg(codec->dev, "write %x = %x\n", reg, val);
-	trace_snd_soc_reg_write(codec, reg, val);
-	return codec->write(codec, reg, val);
+	if (codec->control_data)
+		return regmap_write(codec->control_data, reg, val);
+	else if (codec->write)
+		return codec->write(codec, reg, val);
+	else
+		return -EIO;
 }
 EXPORT_SYMBOL_GPL(snd_soc_write);
 
Index: linux-3.10.108/sound/soc/soc-dapm.c
===================================================================
--- linux-3.10.108.orig/sound/soc/soc-dapm.c
+++ linux-3.10.108/sound/soc/soc-dapm.c
@@ -1503,8 +1503,11 @@ static void dapm_pre_sequence_async(void
 				"ASoC: Failed to turn on bias: %d\n", ret);
 	}
 
-	/* Prepare for a STADDBY->ON or ON->STANDBY transition */
-	if (d->bias_level != d->target_bias_level) {
+	/* Prepare for a transition to ON or away from ON */
+	if ((d->target_bias_level == SND_SOC_BIAS_ON &&
+	     d->bias_level != SND_SOC_BIAS_ON) ||
+	    (d->target_bias_level != SND_SOC_BIAS_ON &&
+	     d->bias_level == SND_SOC_BIAS_ON)) {
 		ret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_PREPARE);
 		if (ret != 0)
 			dev_err(d->dev,
