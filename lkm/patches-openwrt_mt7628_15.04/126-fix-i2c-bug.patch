Index: linux-3.10.108/drivers/i2c/busses/i2c-mtk.c
===================================================================
--- linux-3.10.108.orig/drivers/i2c/busses/i2c-mtk.c
+++ linux-3.10.108/drivers/i2c/busses/i2c-mtk.c
@@ -1,265 +1,265 @@
+// #define DEBUG
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/reset.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/platform_device.h>
+#include <linux/of_platform.h>
 #include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/err.h>
 
 #include <asm/mach-ralink/rt_mmap.h>
-#include "i2c-mtk.h"
+#define I2C_DRV_NAME        "mt-i2c"
 
+#define REG_SM0CFG2_REG		0x28
+#define REG_SM0CTL0_REG		0x40
+#define REG_SM0CTL1_REG		0x44
+#define REG_SM0D0_REG		0x50
+#define REG_SM0D1_REG		0x54
+#define REG_PINTEN_REG		0x5C
+#define REG_PINTST_REG		0x60
+#define REG_PINTCL_REG		0x64
+
+/* REG_SM0CFG2_REG */
+#define SM0CFG2_IS_AUTOMODE	BIT(0)
+
+/* REG_SM0CTL0_REG */
+#define SM0CTL0_ODRAIN		BIT(31)
+#define SM0CTL0_CLK_DIV_MASK	(0x7FF << 16)
+#define SM0CTL0_CLK_DIV_MAX	0x7ff
+#define SM0CTL0_CS_STATUS       BIT(4)
+#define SM0CTL0_SCL_STATE       BIT(3)
+#define SM0CTL0_SDA_STATE       BIT(2)
+#define SM0CTL0_EN              BIT(1)
+#define SM0CTL0_SCL_STRETCH     BIT(0)
+
+/* REG_SM0CTL1_REG */
+#define SM0CTL1_ACK_MASK	(0xFF << 16)
+#define SM0CTL1_PGLEN_MASK	(0x7 << 8)
+#define SM0CTL1_PGLEN(x)	(((x - 1) << 8) & SM0CTL1_PGLEN_MASK)
+#define SM0CTL1_READ		(5 << 4)
+#define SM0CTL1_READ_LAST	(4 << 4)
+#define SM0CTL1_STOP		(3 << 4)
+#define SM0CTL1_WRITE		(2 << 4)
+#define SM0CTL1_START		(1 << 4)
+#define SM0CTL1_MODE_MASK	(0x7 << 4)
+#define SM0CTL1_TRI		BIT(0)
+
+/* timeout waiting for I2C devices to respond (clock streching) */
+#define TIMEOUT_MS              1000
+#define DELAY_INTERVAL_US       100
+
+struct mtk_i2c {
+	void __iomem *base;
+	struct device *dev;
+	struct i2c_adapter adap;
+	u32 cur_clk;
+	u32 clk_div;
+	u32 flags;
+};
 
-static int delay_timing = PERI_CLK / (MAX_MODE_SPEED * 2);
+static void mtk_i2c_w32(struct mtk_i2c *i2c, u32 val, unsigned reg)
+{
+	dev_dbg(i2c->dev, "i2c write reg:0x%x,val:0x%x\n", reg, val);
+	iowrite32(val, i2c->base + reg);
+}
 
-s32 i2c_set_speed(mt_i2c *i2c)
+static u32 mtk_i2c_r32(struct mtk_i2c *i2c, unsigned reg)
 {
-	u32 clk_div = 0;
-		
-	clk_div = PERI_CLK / i2c->speed;
-	delay_timing = clk_div / 2;
-	
-	spin_lock(&i2c->lock);
-
-#if defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628)
-    REG_CMD(I2C_SM0CTL0_REG) = SM0_ODRAIN_PULL | SM0_VSYNC_PULSE | SM0_WAIT_H | SM0_EN | (clk_div << 16);
-#if defined (CONFIG_I2C_MANUAL_MODE)
-    REG_CMD(I2C_AUTOMODE_REG) = 0;
-#else
-	REG_CMD(I2C_AUTOMODE_REG) = 1;
-#endif
-#else
-	REG_CMD(I2C_CLKDIV_REG) = CLKDIV_VALUE;
-#endif
-	spin_unlock(&i2c->lock);
-	
-	return 0;
+	u32 val = ioread32(i2c->base + reg);
+	dev_dbg(i2c->dev, "i2c read reg:0x%x,val:0x%x\n", reg, val);
+	return val;
 }
 
-void mt_i2c_init_hw(mt_i2c *i2c)
+static int poll_down_timeout(void __iomem *addr, u32 mask)
 {
-	u32 val;
-#if defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628)	
-	i2c->speed = MAX_MODE_SPEED;
-#else
-	i2c->speed = ST_MODE_SPEED;
-#endif
-	spin_lock(&i2c->lock);
-	REG_CMD(GPIO_MODE_REG) &= I2C_MODE;	
-
-    // reset i2c block 
-    val = REG_CMD(RSTCTRL_REG);
-	val |= RALINK_I2C_RST;
-    REG_CMD(RSTCTRL_REG) = val;
-
-	val = val & ~RALINK_I2C_RST;
-    REG_CMD(RSTCTRL_REG) = val;
-
-	udelay(300);
-
-	REG_CMD(I2C_CONFIG_REG) = CFG_DEFAULT;
-	spin_unlock(&i2c->lock);
-	
-	i2c_set_speed(i2c);
-}
-
-#ifdef CONFIG_I2C_MANUAL_MODE
-/* Currently only support 1 byte address EEPROM for MANUAL mode */
-static void manual_mode_read(struct i2c_msg* msg)
-{
-	int i, cnt;
-	u32 reg, data0, data1;
-
-	REG_CMD(I2C_SM0CTL1_REG) = SM0_MODE_START;	/* re-start */
-	REG_CMD(I2C_SM0D0_REG) = (msg->addr << 1) | READ_CMD;	/* Write address for read */
-	udelay(delay_timing);
-
-	REG_CMD(I2C_SM0CTL1_REG) = SM0_MODE_WRITE_DATA;
-	udelay(delay_timing);
-	
-	for (cnt = 0; cnt < msg->len; cnt += (2 * SM0_DATA_COUNT)) {
-		if ((msg->len - cnt) > (2 * SM0_DATA_COUNT))
-			reg = SM0_MODE_READ_ACK | SM0_MAX_PGLEN;
-		else
-			reg = SM0_MODE_READ_NACK | SM0_PGLEN((msg->len - cnt) - 1);
-
-		REG_CMD(I2C_SM0CTL1_REG) = reg; /* read data */
-		udelay(delay_timing);
-
-		data0 = REG_CMD(I2C_SM0D0_REG);
-		data1 = REG_CMD(I2C_SM0D1_REG);
-
-		for (i = 0; i < (msg->len - cnt); i++) {
-			if (i < SM0_DATA_COUNT)
-				msg->buf[cnt + i] = (data0 >> SM0_DATA_SHIFT(i)) & 0xff;
-			else
-				msg->buf[cnt + i] = (data1 >> SM0_DATA_SHIFT(i)) & 0xff;
+	unsigned long timeout = jiffies + msecs_to_jiffies(TIMEOUT_MS);
+	int current_delay = 1;
+
+	do {
+		if (!(readl_relaxed(addr) & mask))
+			return 0;
+
+		if (current_delay > 0 && current_delay < 10) {
+			udelay(current_delay);
+		} else if (current_delay >= 10) {
+			usleep_range(current_delay, current_delay + 50);
 		}
-	}
+		current_delay *= current_delay;
+		if (current_delay > DELAY_INTERVAL_US) {
+			current_delay = DELAY_INTERVAL_US;
+		}
+	} while (time_before(jiffies, timeout));
 
-	REG_CMD(I2C_SM0CTL1_REG) = SM0_MODE_STOP;	/* stop */
+	return (readl_relaxed(addr) & mask) ? -EAGAIN : 0;
 }
 
-static void manual_mode_write(struct i2c_msg* msg)
+static int mtk_i2c_wait_idle(struct mtk_i2c *i2c)
 {
-	int i, cnt;
-	u32 data0, data1, reg;
-	
-	REG_CMD(I2C_SM0CTL1_REG) = SM0_MODE_START;	/* Start */
-	REG_CMD(I2C_SM0D0_REG) = (msg->addr << 1) | WRITE_CMD;	/* write address for write */
-	udelay(delay_timing);
-
-	REG_CMD(I2C_SM0CTL1_REG) = SM0_MODE_WRITE_DATA;
-	udelay(delay_timing);
-	
-	for (cnt = 0; cnt < msg->len; cnt += (2 * SM0_DATA_COUNT)) {
-		data0 = data1 = 0;
-		for (i = 0; i < (msg->len - cnt); i++) {
-			if (i < SM0_DATA_COUNT)
-				data0 |= msg->buf[cnt + i] << SM0_DATA_SHIFT(i);
-			else
-				data1 |= msg->buf[cnt + i] << SM0_DATA_SHIFT(i);
-		}
-		REG_CMD(I2C_SM0D0_REG) = data0;
-		REG_CMD(I2C_SM0D1_REG) = data1;
-		udelay(delay_timing);
-	
-		if ((msg->len - i) >= (2 * SM0_DATA_COUNT))
-			reg = SM0_MODE_WRITE_DATA | SM0_MAX_PGLEN;
-		else
-			reg = SM0_MODE_WRITE_DATA | SM0_PGLEN((msg->len - cnt) - 1);
-		
-		REG_CMD(I2C_SM0CTL1_REG) = reg; /* write data */
-		udelay(delay_timing);
+	int ret;
 
-		while(!(REG_CMD(I2C_SM0CTL0_REG) & SM0_ACK));
-	}
+	ret = poll_down_timeout(i2c->base + REG_SM0CTL1_REG, SM0CTL1_TRI);
+	if (ret < 0)
+		dev_dbg(i2c->dev, "idle err(%d)\n", ret);
 
-	if ((msg + 1)->flags == I2C_M_RD)
-		return;
-	else	
-		REG_CMD(I2C_SM0CTL1_REG) = SM0_MODE_STOP;	/* stop */
+	return ret;
 }
 
-static s32 mtk_i2c_master_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg* msgs, s32 num) 
+static void mtk_i2c_reset(struct mtk_i2c *i2c)
 {
-	int left_num = num;
-
-	while (left_num) {
-		if (msgs->flags & I2C_M_TEN) {
-			printk("10 bits addr not supported\n");
-			return -EINVAL;
-		}
-
-		if (msgs->len > MAX_SIZE) {
-			printk("please reduce data length\n");
-			return -EINVAL;
-		}
-		
-		if (msgs->flags & I2C_M_RD)
-			manual_mode_read(msgs);
-		else
-			manual_mode_write(msgs);
-		
-		msgs++;
-		left_num--;
-	}
+	device_reset(i2c->adap.dev.parent);
+	barrier();
+	mtk_i2c_w32(i2c, ((i2c->clk_div << 16) & SM0CTL0_CLK_DIV_MASK)
+		   | SM0CTL0_EN
+		   | SM0CTL0_SCL_STRETCH, REG_SM0CTL0_REG);
+	mtk_i2c_w32(i2c, 0, REG_SM0CFG2_REG);
+}
 
-	msleep(1);
-	return num - left_num;
+static void mtk_i2c_dump_reg(struct mtk_i2c *i2c)
+{
+	dev_dbg(i2c->dev, "SM0CFG2 %08x, SM0CTL0 %08x, SM0CTL1 %08x, " \
+			"SM0D0 %08x, SM0D1 %08x\n",
+			mtk_i2c_r32(i2c, REG_SM0CFG2_REG),
+			mtk_i2c_r32(i2c, REG_SM0CTL0_REG),
+			mtk_i2c_r32(i2c, REG_SM0CTL1_REG),
+			mtk_i2c_r32(i2c, REG_SM0D0_REG),
+			mtk_i2c_r32(i2c, REG_SM0D1_REG));
 }
-#else
-static s32 mtk_i2c_wait_tx_done(void)
+
+static int mtk_i2c_check_ack(struct mtk_i2c *i2c, u32 expected)
 {
-	while(!(REG_CMD(I2C_STATUS_REG) & SDOEMPTY));
-	return 0;
+	u32 ack = readl_relaxed(i2c->base + REG_SM0CTL1_REG);
+	u32 ack_expected = (expected << 16) & SM0CTL1_ACK_MASK;
+	return ((ack & ack_expected) == ack_expected) ? 0 : -ENXIO;
 }
 
-static s32 mtk_i2c_wait_rx_done(void)
+static int mtk_i2c_master_start(struct mtk_i2c *i2c)
 {
-	while(!(REG_CMD(I2C_STATUS_REG) & DATARDY));
-	return 0;
+	mtk_i2c_w32(i2c, SM0CTL1_START | SM0CTL1_TRI, REG_SM0CTL1_REG);
+	return mtk_i2c_wait_idle(i2c);
 }
 
-static s32 mtk_i2c_wait(void)
+static int mtk_i2c_master_stop(struct mtk_i2c *i2c)
 {
-	while(REG_CMD(I2C_STATUS_REG) & DATABUSY);
-	return 0;
+	mtk_i2c_w32(i2c, SM0CTL1_STOP | SM0CTL1_TRI, REG_SM0CTL1_REG);
+	return mtk_i2c_wait_idle(i2c);
 }
 
-static s32 mtk_i2c_handle_msg(struct i2c_adapter *i2c_adap, struct i2c_msg* msg) 
+static int mtk_i2c_master_cmd(struct mtk_i2c *i2c, u32 cmd, int page_len)
 {
-	s32 i = 0, j = 0, pos = 0;
-	s32 nblock = msg->len / READ_BLOCK;
-	s32 rem = msg->len % READ_BLOCK;
-
-	if (msg->flags & I2C_M_TEN) {
-		printk("10 bits addr not supported\n");
-		return -EINVAL;
-	}
+	mtk_i2c_w32(i2c, cmd | SM0CTL1_TRI | SM0CTL1_PGLEN(page_len), REG_SM0CTL1_REG);
+	return mtk_i2c_wait_idle(i2c);
+}
+static int mtk_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
+		int num)
+{
+	struct mtk_i2c *i2c;
+	struct i2c_msg *pmsg;
+	u16 addr;
+	int i, j, ret, len, page_len;
+	u32 cmd;
+	u32 data[2];
 
-	if (msg->len > MAX_SIZE) {
-		printk("please reduce data length\n");
-		return -EINVAL;
-	}
+	i2c = i2c_get_adapdata(adap);
 
-	if ((msg->flags & I2C_M_RD)) {
-		for(i = 0; i < nblock; i++) {
-			mtk_i2c_wait();
-			REG_CMD(I2C_BYTECNT_REG) = READ_BLOCK-1;
-			REG_CMD(I2C_STARTXFR_REG) = READ_CMD;
-			for(j=0; j < READ_BLOCK; j++) {
-				mtk_i2c_wait_rx_done();
-				msg->buf[pos++] = REG_CMD(I2C_DATAIN_REG);
-			}
-		}
+	for (i = 0; i < num; i++) {
+		pmsg = &msgs[i];
+
+		dev_dbg(i2c->dev, "addr: 0x%x, len: %d, flags: 0x%x\n",
+				pmsg->addr, pmsg->len, pmsg->flags);
+
+		/* wait hardware idle */
+		if ((ret = mtk_i2c_wait_idle(i2c)))
+			goto err_timeout;
+
+		/* start sequence */
+		if ((ret = mtk_i2c_master_start(i2c)))
+			goto err_timeout;
 
-		mtk_i2c_wait();
-		REG_CMD(I2C_BYTECNT_REG) = rem-1;
-		REG_CMD(I2C_STARTXFR_REG) = READ_CMD;
-		for(i = 0; i < rem; i++) {
-			mtk_i2c_wait_rx_done();
-			msg->buf[pos++] = REG_CMD(I2C_DATAIN_REG);
+		/* write address */
+		if (pmsg->flags & I2C_M_TEN) {
+			/* 10 bits address */
+			addr = 0xf0 | ((pmsg->addr >> 7) & 0x06);
+			addr |= (pmsg->addr & 0xff) << 8;
+			if (pmsg->flags & I2C_M_RD)
+				addr |= 1;
+			mtk_i2c_w32(i2c, addr, REG_SM0D0_REG);
+			if ((ret = mtk_i2c_master_cmd(i2c, SM0CTL1_WRITE, 2)))
+				goto err_timeout;
+		} else {
+			/* 7 bits address */
+			addr = pmsg->addr << 1;
+			if (pmsg->flags & I2C_M_RD)
+				addr |= 1;
+			mtk_i2c_w32(i2c, addr, REG_SM0D0_REG);
+			if ((ret = mtk_i2c_master_cmd(i2c, SM0CTL1_WRITE, 1)))
+				goto err_timeout;
 		}
-	} else {
-		rem = msg->len;
-		mtk_i2c_wait();
-		REG_CMD(I2C_BYTECNT_REG) = rem-1;
-		for(i = 0; i < rem; i++) {
-			REG_CMD(I2C_DATAOUT_REG) = msg->buf[i];
-			if(i == 0)
-				REG_CMD(I2C_STARTXFR_REG) = WRITE_CMD;		
-			mtk_i2c_wait_tx_done();
+
+		/* check address ACK */
+		if (!(pmsg->flags & I2C_M_IGNORE_NAK)) {
+			if ((ret = mtk_i2c_check_ack(i2c, BIT(0))))
+				goto err_ack;
 		}
-		msleep(2);
-	}
 
-	return 0;
-}
+		/* transfer data */
+		j = 0;
+		for (len = pmsg->len; len > 0; len -= 8) {
+			page_len = (len >= 8) ? 8 : len;
+
+			if (pmsg->flags & I2C_M_RD) {
+				cmd = (len > 8) ? SM0CTL1_READ : SM0CTL1_READ_LAST;
+			} else {
+				memset(data,0,sizeof(data));
+				memcpy(data, &pmsg->buf[j], page_len);
+				mtk_i2c_w32(i2c, data[0], REG_SM0D0_REG);
+				mtk_i2c_w32(i2c, data[1], REG_SM0D1_REG);
+				cmd = SM0CTL1_WRITE;
+			}
 
+			if ((ret = mtk_i2c_master_cmd(i2c, cmd, page_len)))
+				goto err_timeout;
 
-static s32 mtk_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, s32 num)
-{
-	s32 im = 0;
-	s32 ret = 0;
- 
-	REG_CMD(I2C_DEVADDR_REG) = msgs[0].addr;
-	REG_CMD(I2C_ADDR_REG) = 0;
-	
-	for (im = 0; ret == 0 && im != num; im++) {
-		ret = mtk_i2c_handle_msg(adap, &msgs[im]);
+			if (pmsg->flags & I2C_M_RD) {
+				memset(data,0,sizeof(data));
+				data[0] = mtk_i2c_r32(i2c, REG_SM0D0_REG);
+				data[1] = mtk_i2c_r32(i2c, REG_SM0D1_REG);
+				memcpy(&pmsg->buf[j], data, page_len);
+			} else {
+				if (!(pmsg->flags & I2C_M_IGNORE_NAK)) {
+					if ((ret = mtk_i2c_check_ack(i2c, (1 << page_len) - 1)))
+						goto err_ack;
+				}
+			}
+			j += 8;
+		}
 	}
 
-	if(ret)
-		return ret;
+	if ((ret = mtk_i2c_master_stop(i2c)))
+		goto err_timeout;
+
+	/* the return value is number of executed messages */
+	ret = i;
+
+	return ret;
 
-	return im;   
+err_ack:
+	if ((ret = mtk_i2c_master_stop(i2c)))
+		goto err_timeout;
+	return -ENXIO;
+
+err_timeout:
+	mtk_i2c_dump_reg(i2c);
+	mtk_i2c_reset(i2c);
+	return ret;
 }
-#endif
 
-static u32 mtk_i2c_func(struct i2c_adapter *adap)
+static u32 mtk_i2c_func(struct i2c_adapter *a)
 {
 	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
 }
@@ -269,64 +269,84 @@ static const struct i2c_algorithm mtk_i2
 	.functionality	= mtk_i2c_func,
 };
 
+static void mtk_i2c_init(struct mtk_i2c *i2c)
+{
+	i2c->clk_div = 40000000 / i2c->cur_clk - 1;
+	if (i2c->clk_div < 99)
+		i2c->clk_div = 99;
+	if (i2c->clk_div > SM0CTL0_CLK_DIV_MAX)
+		i2c->clk_div = SM0CTL0_CLK_DIV_MAX;
+
+	mtk_i2c_reset(i2c);
+}
+
 
 static s32 mt_i2c_remove(struct platform_device *pdev)
 {
-	mt_i2c *i2c = platform_get_drvdata(pdev);
+	struct mtk_i2c *i2c = platform_get_drvdata(pdev);
+
+	i2c_del_adapter(&i2c->adap);
 
-	if (i2c) {
-		platform_set_drvdata(pdev, NULL);
-		i2c_del_adapter(&i2c->adap);
-		kfree(i2c);
-	}
 	return 0;
 }
 
 static s32 mt_i2c_probe(struct platform_device *pdev)
 {
 	struct resource *res;
-	s32 ret;
-	mt_i2c *i2c = NULL;
+	struct mtk_i2c *i2c;
+	struct i2c_adapter *adap;
+	int ret;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res)
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resource found\n");
 		return -ENODEV;
+	}
 
-	if (!request_mem_region(res->start, resource_size(res), pdev->name))
-		return -ENOMEM;
-		
-	if (NULL == (i2c = kzalloc(sizeof(mt_i2c), GFP_KERNEL)))
+	i2c = devm_kzalloc(&pdev->dev, sizeof(struct mtk_i2c), GFP_KERNEL);
+	if (!i2c) {
+		dev_err(&pdev->dev, "failed to allocate i2c_adapter\n");
 		return -ENOMEM;
-
-	i2c->id	 				= pdev->id;
-	i2c->dev 				= &i2c->adap.dev;
-	i2c->adap.dev.parent	= &pdev->dev;
-	i2c->adap.nr			= i2c->id;	
-	i2c->adap.owner			= THIS_MODULE;
-	i2c->adap.class 		= I2C_CLASS_HWMON | I2C_CLASS_SPD;
-	i2c->adap.timeout 		= HZ;
-	i2c->adap.algo 			= &mtk_i2c_algo;
-	i2c->adap.algo_data		= NULL;
-
-	snprintf(i2c->adap.name, sizeof(i2c->adap.name), I2C_DRV_NAME);
-	
-	spin_lock_init(&i2c->lock);
-
-	mt_i2c_init_hw(i2c);
-
-	i2c_set_adapdata(&i2c->adap, i2c);
-	ret = i2c_add_numbered_adapter(&i2c->adap);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to add i2c bus to i2c core\n");
-		goto free;
 	}
+
+	// i2c->base = devm_ioremap_resource(&pdev->dev, res);
+	i2c->base = RALINK_I2C_BASE;
+	dev_dbg(&pdev->dev,"RALINK_I2C_BASE:0x%x i2c base: 0x%x\n",RALINK_I2C_BASE, i2c->base);
+	if (IS_ERR(i2c->base))
+		return PTR_ERR(i2c->base);
+
+	i2c->dev = &pdev->dev;
+
+	if (of_property_read_u32(pdev->dev.of_node,
+				"clock-frequency", &i2c->cur_clk))
+		i2c->cur_clk = 100000;
+
+	adap = &i2c->adap;
+	adap->owner = THIS_MODULE;
+	adap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
+	adap->algo = &mtk_i2c_algo;
+	adap->algo_data	= NULL;
+	adap->nr = pdev->id;
+	adap->retries = 3;
+	adap->timeout = HZ;
+	adap->dev.parent = &pdev->dev;
+	i2c_set_adapdata(adap, i2c);
+	adap->dev.of_node = pdev->dev.of_node;
+	strlcpy(adap->name, dev_name(&pdev->dev), sizeof(adap->name));
+
 	platform_set_drvdata(pdev, i2c);
 
-	return ret;
+	mtk_i2c_init(i2c);
+
+	ret = i2c_add_adapter(adap);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to add adapter\n");
+		return ret;
+	}
+
+	dev_info(&pdev->dev, "clock %u kHz\n",
+			i2c->cur_clk/1000);
 
-free:
-	i2c_del_adapter(&i2c->adap);
-	kfree(i2c);
 	return ret;
 }
 
