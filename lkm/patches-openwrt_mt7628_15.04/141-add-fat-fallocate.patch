Index: linux-3.10.108/fs/fat/file.c
===================================================================
--- linux-3.10.108.orig/fs/fat/file.c
+++ linux-3.10.108/fs/fat/file.c
@@ -19,6 +19,100 @@
 #include <linux/security.h>
 #include "fat.h"
 
+#include <linux/falloc.h>
+
+static long fat_fallocate(struct file *file, int mode, loff_t offset, loff_t len);
+static int fat_cont_expand(struct inode *inode, loff_t size);
+extern int fat_add_cluster(struct inode *inode);
+
+/*从linux kernel4.9版本移植fat_fallocate函数——by yujun 20230926*/
+/*
+ * Preallocate space for a file. This implements fat's fallocate file
+ * operation, which gets called from sys_fallocate system call. User
+ * space requests len bytes at offset. If FALLOC_FL_KEEP_SIZE is set
+ * we just allocate clusters without zeroing them out. Otherwise we
+ * allocate and zero out clusters via an expanding truncate.
+ */
+static long fat_fallocate(struct file *file, int mode,
+			  loff_t offset, loff_t len)
+{
+	int nr_cluster; /* Number of clusters to be allocated */
+	loff_t mm_bytes; /* Number of bytes to be allocated for file */
+	loff_t ondisksize; /* block aligned on-disk size in bytes*/
+	struct inode *inode = file->f_mapping->host;
+	struct super_block *sb = inode->i_sb;
+	struct msdos_sb_info *sbi = MSDOS_SB(sb);
+	int err = 0;
+	unsigned int blkbits = inode->i_blkbits;
+	sector_t iblock = offset >> blkbits;
+	unsigned long mapped_blocks;
+	sector_t phys;
+	
+	/* No support for hole punch or other fallocate flags. */
+	if (mode & ~FALLOC_FL_KEEP_SIZE)
+		return -EOPNOTSUPP;
+
+	/* No support for dir */
+	if (!S_ISREG(inode->i_mode))
+		return -EOPNOTSUPP;
+
+	mutex_lock(&inode->i_mutex);
+	if (mode & FALLOC_FL_KEEP_SIZE) {
+		ondisksize = inode->i_blocks << 9;
+		if ((offset + len) <= ondisksize)
+			goto error;
+
+		/* First compute the number of clusters to be allocated */
+		mm_bytes = offset + len - ondisksize;
+		nr_cluster = (mm_bytes + (sbi->cluster_size - 1)) >>
+			sbi->cluster_bits;
+
+		/* Start the allocation.We are not zeroing out the clusters */
+		while (nr_cluster-- > 0) {
+			err = fat_add_cluster(inode);
+			if (err)
+				goto error;
+			
+			/*更新文件size和相关数据结构——by yujun 20231012*/		
+			if(MSDOS_I(inode)->mmu_private < ondisksize){
+				MSDOS_I(inode)->mmu_private = ondisksize;
+			}
+			mapped_blocks = sbi->sec_per_clus;
+			MSDOS_I(inode)->mmu_private += mapped_blocks << sb->s_blocksize_bits;
+		
+			for(; iblock < (MSDOS_I(inode)->mmu_private >> blkbits); iblock++){
+				err = fat_bmap(inode, iblock, &phys, &mapped_blocks, 1);
+				if (err)
+					goto error;
+				if(!phys)
+					printk("==%s(%d)==iblock=%d===offset=%u==len=%u=\n", __func__, __LINE__, \
+					iblock, (unsigned int)offset, (unsigned int)len);
+				BUG_ON(!phys);
+			}
+			
+			inode->i_size = MSDOS_I(inode)->mmu_private;
+			inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;	
+			mark_inode_dirty(inode);
+			if (IS_SYNC(inode)) {
+				int err;
+				err = write_inode_now(inode, 1);		
+			}
+			/*更新文件size和相关数据结构——by yujun 20231012*/	
+		}	
+	} else {
+		if ((offset + len) <= i_size_read(inode))
+			goto error;
+
+		/* This is just an expanding truncate */
+		err = fat_cont_expand(inode, (offset + len));
+	}
+
+error:
+	mutex_unlock(&inode->i_mutex);
+	return err;
+}
+
+
 static int fat_ioctl_get_attributes(struct inode *inode, u32 __user *user_attr)
 {
 	u32 attr;
@@ -177,6 +271,7 @@ const struct file_operations fat_file_op
 #if defined (CONFIG_SPLICE_NET_SUPPORT)
 	.splice_from_socket = generic_splice_from_socket,
 #endif
+	.fallocate	= fat_fallocate,
 };
 
 static int fat_cont_expand(struct inode *inode, loff_t size)
Index: linux-3.10.108/fs/fat/inode.c
===================================================================
--- linux-3.10.108.orig/fs/fat/inode.c
+++ linux-3.10.108/fs/fat/inode.c
@@ -39,7 +39,7 @@ static int fat_default_codepage = CONFIG
 static char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;
 
 
-static int fat_add_cluster(struct inode *inode)
+int fat_add_cluster(struct inode *inode)
 {
 	int err, cluster;
 
