<?xml version="1.0" encoding="utf-8"?>

<!--
    Copyright (c) 2006-2018, Alexis Royer, http://alexis.royer.free.fr/CLI

    All rights reserved.

    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

        * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation
          and/or other materials provided with the distribution.
        * Neither the name of the CLI library project nor the names of its contributors may be used to endorse or promote products derived from this software
          without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->


<xsl:stylesheet
    version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:cli="http://alexis.royer.free.fr/CLI">
<xsl:output method="text" encoding="utf-8"/>


<!-- CLI static creation -->
<xsl:param name="B_CliStaticCreation" select="0"/>
<!-- Variables prefix -->
<xsl:param name="STR_VarPrefix" select="'m_pcli_'"/>
<!-- Classes prefix -->
<xsl:param name="STR_ClassPrefix" select="''"/>
<!-- Indentation -->
<xsl:param name="STR_Indent" select="'    '"/>
<xsl:param name="STR_UserIndent" select="'/* &gt; */ '"/>
<!-- CLI class name -->
<xsl:param name="STR_CliClassName">
    <xsl:value-of select="$STR_ClassPrefix"/>
    <xsl:call-template name="T_MkCppName">
        <xsl:with-param name="STR_String" select="/cli:cli/@name"/>
    </xsl:call-template>
</xsl:param>



<!-- Global variables -->
<xsl:variable name="STR_Endl"><xsl:text>
</xsl:text></xsl:variable>


<!-- Root template -->
<xsl:template match="/cli:cli">

    <xsl:text>//! @file</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:text>//! @author cli2cpp.xsl - CLI library 2.9 (Alexis Royer, http://alexis.royer.free.fr/CLI/)</xsl:text><xsl:value-of select="$STR_Endl"/>
    <!--<xsl:text>//! @date </xsl:text><xsl:value-of select="date:date-time()"/><xsl:value-of select="$STR_Endl"/>-->
    <xsl:text>//! @warning File auto-generated by 'cli2cpp.xsl' - Do not edit!</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:value-of select="$STR_Endl"/>


    <!-- Pre-compiled headers -->
    <xsl:text>// ----- Pre-compiled headers -----</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:text>#include "cli/pch.h"</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:value-of select="$STR_Endl"/>

    <!-- Head section -->
    <xsl:call-template name="T_ExtraCpp">
        <xsl:with-param name="STR_Option" select="'head'"/>
    </xsl:call-template>
    <xsl:value-of select="$STR_Endl"/>

    <xsl:call-template name="T_Include"/>

    <!-- Include section -->
    <xsl:call-template name="T_ExtraCpp">
        <xsl:with-param name="STR_Option" select="'include'"/>
    </xsl:call-template>
    <xsl:value-of select="$STR_Endl"/>

    <!-- Types section -->
    <xsl:call-template name="T_ExtraCpp">
        <xsl:with-param name="STR_Option" select="'types'"/>
    </xsl:call-template>
    <xsl:value-of select="$STR_Endl"/>

    <!-- Vars section -->
    <xsl:call-template name="T_ExtraCpp">
        <xsl:with-param name="STR_Option" select="'vars'"/>
    </xsl:call-template>
    <xsl:value-of select="$STR_Endl"/>

    <xsl:call-template name="T_MenuDeclaration"/>

    <xsl:call-template name="T_NodeCreation"/>

    <!-- Body section -->
    <xsl:call-template name="T_ExtraCpp">
        <xsl:with-param name="STR_Option" select="'body'"/>
    </xsl:call-template>
    <xsl:value-of select="$STR_Endl"/>

    <!-- Tail section -->
    <xsl:call-template name="T_ExtraCpp">
        <xsl:with-param name="STR_Option" select="'tail'"/>
    </xsl:call-template>
    <xsl:value-of select="$STR_Endl"/>

</xsl:template>


<xsl:template name="T_ExtraCpp">
    <xsl:param name="STR_Option"/>

    <xsl:choose>
    <xsl:when test="$STR_Option='members'"><xsl:call-template name="T_Indent1"/></xsl:when>
    <xsl:when test="$STR_Option='constructor'"><xsl:call-template name="T_Indent2"/></xsl:when>
    <xsl:otherwise><xsl:call-template name="T_Indent0"/></xsl:otherwise>
    </xsl:choose>
        <xsl:text>// ----- Extra cpp (option='</xsl:text><xsl:value-of select="$STR_Option"/><xsl:text>') -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>

    <xsl:if test="cli:cpp[@option=$STR_Option] and ($STR_Option='members' or $STR_Option='constructor')">
        <xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/>
    </xsl:if>
    <xsl:for-each select="cli:cpp[@option=$STR_Option]">
        <xsl:choose>
        <xsl:when test="$STR_Option='members'"><xsl:call-template name="T_Indent1"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/></xsl:call-template></xsl:when>
        <xsl:when test="$STR_Option='constructor'"><xsl:call-template name="T_Indent2"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/></xsl:call-template></xsl:when>
        <xsl:otherwise><xsl:call-template name="T_Indent0"></xsl:call-template></xsl:otherwise>
        </xsl:choose>
            <xsl:apply-templates select="."/>
            <xsl:value-of select="$STR_Endl"/>
    </xsl:for-each>
    <xsl:if test="cli:cpp[@option=$STR_Option] and ($STR_Option='members' or $STR_Option='constructor')">
        <xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/>
    </xsl:if>
</xsl:template>

<xsl:template name="T_Include">
    <xsl:text>// ----- Includes -----</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:text>#include "cli/common.h"</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:value-of select="$STR_Endl"/>
</xsl:template>

<xsl:template name="T_MenuDeclaration">
    <xsl:variable name="STR_ClassName">
        <xsl:call-template name="T_Node2Class"/>
    </xsl:variable>
    <xsl:variable name="STR_SuperClass">
        <xsl:choose>
        <xsl:when test="self::cli:cli">cli::Cli</xsl:when>
        <xsl:otherwise>cli::Menu</xsl:otherwise>
        </xsl:choose>
    </xsl:variable>

    <xsl:if test="self::cli:cli">
        <xsl:call-template name="T_Indent0"/>
            <xsl:text>// ----- Cli class definition -----</xsl:text><xsl:value-of select="$STR_Endl"/>
    </xsl:if>
    <xsl:call-template name="T_Indent0"/>
        <xsl:text>class </xsl:text><xsl:value-of select="$STR_ClassName"/>
        <xsl:text> : public </xsl:text><xsl:value-of select="$STR_SuperClass"/>
        <xsl:text> {</xsl:text><xsl:value-of select="$STR_Endl"/>

        <!-- Sub-menus at root only. -->
        <xsl:call-template name="T_MenuSubMenus"/>

        <!-- Node declarations. -->
        <xsl:call-template name="T_MenuMembers"/>

        <!-- Constructor -->
        <xsl:call-template name="T_MenuConstructor"/>

        <!-- Destructor. -->
        <xsl:call-template name="T_MenuDestructor"/>

        <!-- Populating nodes. -->
        <xsl:call-template name="T_MenuPopulate"/>

        <!-- Menu implementation. -->
        <xsl:call-template name="T_MenuExecute"/>

        <!-- Menu handlers. -->
        <xsl:call-template name="T_MenuHandlers"/>

    <xsl:call-template name="T_Indent0"/>
        <xsl:text>};</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:if test="self::cli:cli">
        <xsl:value-of select="$STR_Endl"/>
    </xsl:if>

</xsl:template>

<xsl:template name="T_MenuSubMenus">
    <!-- Sub menus, only for CLI object -->
    <xsl:if test="self::cli:cli">
        <xsl:call-template name="T_Indent1"/>
            <xsl:text>// ----- Sub-menus -----</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:for-each select=".//cli:menu[not(@ref)]">
            <xsl:call-template name="T_MenuDeclaration"/>
            <xsl:value-of select="$STR_Endl"/>
        </xsl:for-each>
        <xsl:value-of select="$STR_Endl"/>
    </xsl:if>
    <!-- Any menu, reference to the owner CLI object -->
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>// ----- Owner CLI -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>private: </xsl:text>
        <xsl:for-each select="/cli:cli"><xsl:call-template name="T_Node2Class"/></xsl:for-each>
        <xsl:text>* m_pcliOwnerCli;</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
</xsl:template>

<xsl:template name="T_MenuMembers">
    <xsl:variable name="STR_Class"><xsl:call-template name="T_Node2Class"/></xsl:variable>
    <xsl:variable name="STR_Var"><xsl:call-template name="T_Node2Var"/></xsl:variable>
    <xsl:variable name="I_IndentOffset"><xsl:call-template name="T_IndentOffset"/></xsl:variable>

    <!-- Menus -->
    <xsl:if test="self::cli:cli">
        <xsl:call-template name="T_Indent1"/>
            <xsl:text>// ----- Menus -----</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <!-- Self -->
        <xsl:call-template name="T_DeclareNode">
            <xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 1"/>
        </xsl:call-template>
        <!-- Effective menus -->
        <xsl:for-each select=".//cli:menu[@name]">
            <xsl:call-template name="T_DeclareNode">
                <xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 1"/>
            </xsl:call-template>
        </xsl:for-each>
    </xsl:if>

    <!-- Sub-nodes -->
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>// ----- Node members -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_DeclareSubNodes">
        <xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 1"/>
    </xsl:call-template>

    <!-- Members section -->
    <xsl:call-template name="T_ExtraCpp">
        <xsl:with-param name="STR_Option" select="'members'"/>
    </xsl:call-template>

    <xsl:value-of select="$STR_Endl"/>
</xsl:template>

    <xsl:template name="T_DeclareSubNodes">
        <xsl:param name="I_IndentCount" select="0"/>

        <xsl:for-each select="cli:*">
        <xsl:choose>
        <xsl:when test="self::cli:help"><!-- No population for help nodes. Help nodes generate help arguments. --></xsl:when>
        <xsl:when test="self::cli:comment"><!-- No population for comment nodes. Comment nodes are handled through simple function calls before populating the menu. --></xsl:when>
        <xsl:when test="self::cli:cpp or self::cli:java or self::cli:handler"><!-- No population for target language nodes. --></xsl:when>
        <xsl:when test="self::cli:menu"><!-- Do not populate menus which are defined at the cli level. --></xsl:when>
        <xsl:when test="self::cli:tag[@ref]"><!-- tag[@ref] instances are created at the very end, in the T_MenuPopulate template,
                                                  but their reference do not need to be remembered (see T_CreateNode). --></xsl:when>
        <xsl:otherwise>
            <xsl:call-template name="T_DeclareNode">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
            </xsl:call-template>
            <xsl:call-template name="T_DeclareSubNodes">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 1"/>
            </xsl:call-template>
        </xsl:otherwise>
        </xsl:choose>
        </xsl:for-each>
    </xsl:template>

    <xsl:template name="T_DeclareNode">
        <xsl:param name="I_IndentCount" select="0"/>
        <xsl:param name="STR_Indent">
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:variable name="STR_Class">
            <xsl:call-template name="T_Node2Class"/>
        </xsl:variable>
        <xsl:variable name="STR_Var">
            <xsl:call-template name="T_Node2Var">
                <xsl:with-param name="B_UseOwnerCli" select="0"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="STR_ParentVar">
            <xsl:for-each select="parent::cli:*">
                <xsl:call-template name="T_Node2Var"/>
            </xsl:for-each>
        </xsl:variable>

        <xsl:value-of select="$STR_Indent"/>
            <xsl:text>private: </xsl:text>
            <xsl:value-of select="$STR_Class"/>
            <xsl:text>* </xsl:text>
            <xsl:value-of select="$STR_Var"/>
            <xsl:text>;</xsl:text>
            <xsl:value-of select="$STR_Endl"/>

    </xsl:template>

<xsl:template name="T_MenuConstructor">
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>// ----- Constructor -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>public: explicit </xsl:text>
        <xsl:call-template name="T_Node2Class"/>
        <xsl:text>(void) :</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_Indent2"/>
        <!-- Initialization -->
        <xsl:choose>
        <xsl:when test="self::cli:cli">cli::Cli</xsl:when>
        <xsl:when test="self::cli:menu">cli::Menu</xsl:when>
        <xsl:otherwise>
            <xsl:call-template name="T_Error">
                <xsl:with-param name="STR_Message">no parent CLI class for element <xsl:value-of select="name()"/></xsl:with-param>
            </xsl:call-template>
        </xsl:otherwise>
        </xsl:choose>
        <xsl:text>(</xsl:text>
            <xsl:call-template name="T_CreateNodeParams"/>
        <xsl:text>)</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>{</xsl:text>
        <xsl:value-of select="$STR_Endl"/>

        <!-- Populate -->
        <xsl:if test="self::cli:cli">
            <xsl:call-template name="T_Indent2"/>
                <xsl:text>Populate();</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:if>
        <!-- Constructor section -->
        <xsl:call-template name="T_ExtraCpp">
            <xsl:with-param name="STR_Option" select="'constructor'"/>
        </xsl:call-template>

    <xsl:call-template name="T_Indent1"/>
        <xsl:text>}</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:value-of select="$STR_Endl"/>
</xsl:template>

<xsl:template name="T_MenuDestructor">
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>// ----- Destructor -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>public: virtual ~</xsl:text>
        <xsl:call-template name="T_Node2Class"/>
        <xsl:text>(void) {</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>}</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:value-of select="$STR_Endl"/>
</xsl:template>

<xsl:template name="T_MenuPopulate">
    <xsl:variable name="STR_Class"><xsl:call-template name="T_Node2Class"/></xsl:variable>
    <xsl:variable name="STR_Var"><xsl:call-template name="T_Node2Var"/></xsl:variable>
    <xsl:variable name="I_IndentOffset"><xsl:call-template name="T_IndentOffset"/></xsl:variable>

    <xsl:call-template name="T_Indent1"/>
        <xsl:text>// ----- Populate -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_Indent1"/><xsl:text>public: void Populate(void) {</xsl:text><xsl:value-of select="$STR_Endl"/>

    <!-- CLI reference -->
    <xsl:call-template name="T_Indent2"/>
        <xsl:text>// CLI reference</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_Indent2"/>
        <xsl:text>m_pcliOwnerCli = dynamic_cast&lt;</xsl:text>
        <xsl:for-each select="/cli:cli"><xsl:call-template name="T_Node2Class"/></xsl:for-each>
        <xsl:text>*&gt;(const_cast&lt;cli::Cli*&gt;(&amp; GetCli()));</xsl:text>
        <xsl:value-of select="$STR_Endl"/>

    <!-- Comment patterns -->
    <xsl:if test="self::cli:cli">
        <xsl:variable name="STR_Indent"><xsl:call-template name="T_Indent2"/></xsl:variable>

        <xsl:value-of select="$STR_Indent"/>
            <xsl:text>// Comment line patterns</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:for-each select="./cli:comment">
            <xsl:value-of select="$STR_Indent"/>
                <xsl:text>AddCommentLinePattern("</xsl:text>
                <xsl:value-of select="@start"/>
                <xsl:text>");</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:for-each>
    </xsl:if>

    <!-- Populate menus -->
    <xsl:if test="self::cli:cli">
        <xsl:variable name="STR_Indent"><xsl:call-template name="T_Indent2"/></xsl:variable>

        <xsl:value-of select="$STR_Indent"/>
            <xsl:text>// Create menus and populate</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <!-- Self CLI reference setting -->
        <xsl:value-of select="$STR_Indent"/>
            <xsl:call-template name="T_Node2Var"/>
            <xsl:text> = this;</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <!-- Create the menus -->
        <xsl:for-each select=".//cli:menu[@name]">
            <xsl:value-of select="$STR_Indent"/>
                <xsl:call-template name="T_Node2Var"/>
                <xsl:text> = dynamic_cast&lt;</xsl:text>
                    <xsl:call-template name="T_Node2Class"/>
                <xsl:text>*&gt;(</xsl:text>
                    <xsl:text>&amp; AddMenu(</xsl:text>
                        <xsl:text>new </xsl:text><xsl:call-template name="T_Node2Class"/><xsl:text>()</xsl:text>
                    <xsl:text>)</xsl:text>
                <xsl:text>);</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:for-each>
        <!-- Populate them -->
        <xsl:for-each select=".//cli:menu[@name]">
            <xsl:value-of select="$STR_Indent"/>
                <xsl:call-template name="T_Node2Var"/>
                <xsl:text>->Populate();</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:for-each>
    </xsl:if>

    <!-- Sub-nodes -->
    <xsl:call-template name="T_Indent2"/>
        <xsl:text>// Local nodes</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_CreateSubNodes">
        <xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 2"/>
    </xsl:call-template>
    <!-- tag[@ref] items are processed at the very end -->
    <xsl:variable name="xml_CurrentMenu" select="."/>
    <xsl:call-template name="T_Indent"><xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 2"/></xsl:call-template>
        <xsl:text>// tag[@ref] -> tag[@id] connections</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:for-each select=".//cli:tag[@ref]">
    <xsl:if test="not(ancestor::cli:menu[@name and ancestor::cli:*[.=$xml_CurrentMenu]])">
        <xsl:call-template name="T_CreateNode">
            <xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 2"/>
        </xsl:call-template>
    </xsl:if>
    </xsl:for-each>

    <xsl:call-template name="T_Indent1"/><xsl:text>}</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:value-of select="$STR_Endl"/>
</xsl:template>

    <xsl:template name="T_CreateSubNodes">
        <xsl:param name="I_IndentCount" select="0"/>

        <xsl:for-each select="cli:*">
        <xsl:choose>
        <xsl:when test="self::cli:help"><!-- No population for help nodes. Help nodes generate help arguments. --></xsl:when>
        <xsl:when test="self::cli:comment"><!-- No population for comment nodes. Comment nodes are handled through simple function calls before populating the menu. --></xsl:when>
        <xsl:when test="self::cli:cpp or self::cli:java or self::cli:handler"><!-- No population for target language nodes. --></xsl:when>
        <xsl:when test="self::cli:menu[@name] and parent::cli:cli"><!-- Do not populate menus which are defined at the cli level. --></xsl:when>
        <xsl:when test="self::cli:tag[@ref]"><!-- No population for tag[@ref] right now.
                                                  Because tag[@id] could be processed later, tag[@ref] will be processed at the very end,
                                                  in the T_MenuPopulate template. --></xsl:when>
        <xsl:otherwise>
            <xsl:call-template name="T_CreateNode">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
            </xsl:call-template>
            <xsl:choose>
            <xsl:when test="self::cli:cli[@name]"><!-- Should never occur. --></xsl:when>
            <xsl:when test="self::cli:menu[@name]"><!-- Do not populate menus, this is done directly at the cli level. --></xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="T_CreateSubNodes">
                    <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 1"/>
                </xsl:call-template>
            </xsl:otherwise>
            </xsl:choose>
        </xsl:otherwise>
        </xsl:choose>
        </xsl:for-each>
    </xsl:template>

    <xsl:template name="T_CreateNode">
        <xsl:param name="I_IndentCount" select="0"/>
        <xsl:param name="B_WithCreateParams" select="1"/>
        <xsl:variable name="STR_Indent">
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="STR_Class">
            <xsl:call-template name="T_Node2Class"/>
        </xsl:variable>
        <xsl:variable name="STR_Var">
            <xsl:call-template name="T_Node2Var"/>
        </xsl:variable>
        <xsl:variable name="STR_ParentVar">
            <xsl:for-each select="parent::cli:*">
                <xsl:call-template name="T_Node2Var"/>
            </xsl:for-each>
        </xsl:variable>

        <xsl:value-of select="$STR_Indent"/>
            <xsl:if test="not(self::cli:tag[@ref]) and not(self::cli:menu)">
                <xsl:value-of select="$STR_Var"/>
                <xsl:text> = dynamic_cast&lt;</xsl:text>
                <xsl:value-of select="$STR_Class"/>
                <xsl:text>*&gt;(&amp; </xsl:text>
            </xsl:if>
                <xsl:value-of select="$STR_ParentVar"/>
                <xsl:choose>
                <xsl:when test="self::cli:menu">
                    <xsl:text>->SetMenuRef(</xsl:text>
                        <xsl:text>new cli::MenuRef(</xsl:text>
                            <xsl:choose>
                            <xsl:when test="self::cli:menu[@name]">
                                <xsl:text>*</xsl:text><xsl:call-template name="T_Node2Var"/>
                            </xsl:when>
                            <xsl:when test="self::cli:menu[@ref]">
                                <xsl:variable name="STR_MenuId" select="@ref"/>
                                <xsl:variable name="STR_MenuRef">
                                    <xsl:for-each select="//cli:menu[@name=$STR_MenuId]">
                                        <xsl:text>*</xsl:text><xsl:call-template name="T_Node2Var"/>
                                    </xsl:for-each>
                                </xsl:variable>
                                <xsl:if test="string-length($STR_MenuRef) = 0">
                                    <xsl:call-template name="T_Error">
                                        <xsl:with-param name="STR_Message"><xsl:text>No such menu '</xsl:text><xsl:value-of select="$STR_MenuId"/><xsl:text>'</xsl:text></xsl:with-param>
                                    </xsl:call-template>
                                </xsl:if>
                                <xsl:value-of select="$STR_MenuRef"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:call-template name="T_Error">
                                    <xsl:with-param name="STR_Message">missing menu/@name or menu/@ref attribute</xsl:with-param>
                                </xsl:call-template>
                            </xsl:otherwise>
                            </xsl:choose>
                        <xsl:text>)</xsl:text>
                    <xsl:text>)</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>->AddElement(</xsl:text>
                        <xsl:text>new </xsl:text><xsl:value-of select="$STR_Class"/><xsl:text>(</xsl:text>
                            <xsl:if test="$B_WithCreateParams">
                                <xsl:call-template name="T_CreateNodeParams"/>
                            </xsl:if>
                        <xsl:text>)</xsl:text>
                    <xsl:text>)</xsl:text>
                </xsl:otherwise>
                </xsl:choose>
            <xsl:if test="not(self::cli:tag[@ref]) and not(self::cli:menu)">
                <xsl:text>)</xsl:text>
            </xsl:if>
            <xsl:text>;</xsl:text>
            <xsl:value-of select="$STR_Endl"/>

    </xsl:template>

    <xsl:template name="T_CreateNodeParams">
        <xsl:variable name="STR_ElementRef">
            <xsl:choose>
            <xsl:when test="self::cli:tag[@ref]">
                <xsl:variable name="STR_TagId" select="@ref"/>
                <xsl:variable name="STR_TagRef">
                    <xsl:for-each select="//cli:tag[@id=$STR_TagId]">
                        <xsl:text>*</xsl:text><xsl:call-template name="T_Node2Var"/>
                    </xsl:for-each>
                </xsl:variable>
                <xsl:if test="string-length($STR_TagRef) = 0">
                    <xsl:call-template name="T_Error">
                        <xsl:with-param name="STR_Message"><xsl:text>No such tag identifier '</xsl:text><xsl:value-of select="$STR_TagId"/><xsl:text>'</xsl:text></xsl:with-param>
                    </xsl:call-template>
                </xsl:if>
                <xsl:value-of select="$STR_TagRef"/>
            </xsl:when>
            <xsl:when test="self::cli:menu[@ref]">
                <xsl:variable name="STR_MenuId" select="@ref"/>
                <xsl:variable name="STR_MenuRef">
                    <xsl:for-each select="//cli:menu[@name=$STR_MenuId]">
                        <xsl:text>*</xsl:text><xsl:call-template name="T_Node2Var"/>
                    </xsl:for-each>
                </xsl:variable>
                <xsl:if test="string-length($STR_MenuRef) = 0">
                    <xsl:call-template name="T_Error">
                        <xsl:with-param name="STR_Message"><xsl:text>No such menu '</xsl:text><xsl:value-of select="$STR_MenuId"/><xsl:text>'</xsl:text></xsl:with-param>
                    </xsl:call-template>
                </xsl:if>
                <xsl:value-of select="$STR_MenuRef"/>
            </xsl:when>
            </xsl:choose>
            </xsl:variable>
        <xsl:variable name="B_ElementRef" select="string-length($STR_ElementRef)"/>
        <xsl:variable name="STR_Keyword">
            <xsl:choose>
            <xsl:when test="self::cli:cli or self::cli:menu">
                <xsl:value-of select="@name"/>
            </xsl:when>
            <xsl:when test="self::cli:keyword">
                <xsl:value-of select="@string"/>
            </xsl:when>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="B_Keyword" select="string-length($STR_Keyword)"/>
        <xsl:variable name="B_Help">
            <xsl:choose>
            <xsl:when test="self::cli:tag">0</xsl:when>
            <xsl:when test="self::cli:menu[@ref]">0</xsl:when>
            <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
        <xsl:when test="self::cli:tag[@id and @hollow='yes']">
            <xsl:text>true</xsl:text>
        </xsl:when>
        <xsl:when test="self::cli:tag[@id]">
            <xsl:text>false</xsl:text>
        </xsl:when>
        <xsl:when test="not($B_ElementRef=0)">
            <xsl:value-of select="$STR_ElementRef"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:if test="not($B_Keyword=0)">
                <xsl:text>"</xsl:text>
                <xsl:value-of select="$STR_Keyword"/>
                <xsl:text>"</xsl:text>
            </xsl:if>
            <xsl:if test="$B_Keyword and $B_Help">
                <xsl:text>, </xsl:text>
            </xsl:if>
            <xsl:if test="not($B_Help=0)">
                <xsl:text>cli::Help()</xsl:text>
                <xsl:for-each select="cli:help">
                    <xsl:variable name="STR_Lang">
                        <xsl:choose>
                        <xsl:when test="@lang='en'">
                            <xsl:text>cli::Help::LANG_EN</xsl:text>
                        </xsl:when>
                        <xsl:when test="@lang='fr'">
                            <xsl:text>cli::Help::LANG_FR</xsl:text>
                        </xsl:when>
                        </xsl:choose>
                    </xsl:variable>

                    <xsl:if test="string-length($STR_Lang) &gt; 0">
                        <xsl:text>.AddHelp(</xsl:text>
                            <xsl:value-of select="$STR_Lang"/>
                            <xsl:text>, </xsl:text>
                            <xsl:text>"</xsl:text>
                            <xsl:value-of select="."/>
                            <xsl:text>"</xsl:text>
                        <xsl:text>)</xsl:text>
                    </xsl:if>
                </xsl:for-each>
            </xsl:if>
        </xsl:otherwise>
        </xsl:choose>
    </xsl:template>


<xsl:template name="T_MenuExecute">
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>// ----- Menu execution -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>

    <xsl:call-template name="T_ImplementMenu"/>

    <!--<xsl:value-of select="$STR_Endl"/>-->
</xsl:template>

    <xsl:template name="T_ImplementMenu">
        <xsl:variable name="STR_Class">
            <xsl:call-template name="T_Node2Class"/>
        </xsl:variable>
        <xsl:variable name="I_IndentOffset">
            <xsl:call-template name="T_IndentOffset"/>
        </xsl:variable>

        <!-- Execution method -->
        <xsl:call-template name="T_Indent1"/>
        <xsl:text>public: virtual const bool Execute(const cli::CommandLine&amp; CLI_CmdLine) const {</xsl:text>
            <xsl:value-of select="$STR_Endl"/>

            <xsl:call-template name="T_Indent2"/>
                <xsl:text>{</xsl:text>
                <xsl:value-of select="$STR_Endl"/>

            <!-- Trace -->
            <xsl:call-template name="T_Indent3"/>
                <xsl:text>static const cli::TraceClass CLI_EXECUTION(</xsl:text>
                    <xsl:text>"CLI_EXECUTION", </xsl:text>
                    <xsl:text>cli::Help()</xsl:text>
                        <xsl:text>.AddHelp(cli::Help::LANG_EN, "CLI Execution traces")</xsl:text>
                        <xsl:text>.AddHelp(cli::Help::LANG_FR, "Traces d'exécution du CLI")</xsl:text>
                <xsl:text>);</xsl:text>
                <xsl:value-of select="$STR_Endl"/>

            <!-- Step variables -->
            <xsl:call-template name="T_Indent3"/>
                <xsl:text>cli::CommandLineIterator cli_Elements(CLI_CmdLine);</xsl:text>
                <xsl:value-of select="$STR_Endl"/>

            <!-- Call implementation on the menu object -->
            <xsl:call-template name="T_ImplementMenuExecution">
                <xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 3"/>
            </xsl:call-template>

            <!-- Finishing -->
            <xsl:call-template name="T_Indent2"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
            <xsl:call-template name="T_Indent2"/>
                <xsl:text>return false;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>

        <xsl:call-template name="T_Indent1"/>
            <xsl:text>}</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:value-of select="$STR_Endl"/>
    </xsl:template>

    <xsl:template name="T_ImplementMenuExecution">
        <xsl:param name="I_IndentCount" select="0"/>
        <xsl:variable name="STR_Indent0">
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 0"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="STR_Indent1">
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 1"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="STR_Indent2">
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 2"/>
            </xsl:call-template>
        </xsl:variable>

        <!-- Top comment -->
        <xsl:value-of select="$STR_Indent0"/>
            <xsl:text>// </xsl:text>
            <xsl:call-template name="T_Node2Desc"/>
            <xsl:value-of select="$STR_Endl"/>

        <!-- Top label -->
        <xsl:if test="self::cli:tag[@hollow='yes']">
            <xsl:value-of select="$STR_Indent0"/>
                <xsl:text>goto </xsl:text>
                <xsl:call-template name="T_Node2EndLabel"/>
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:if>
        <xsl:value-of select="$STR_Indent0"/>
            <xsl:call-template name="T_Node2TopLabel"/>
            <xsl:text>: ;</xsl:text>
            <xsl:value-of select="$STR_Endl"/>

        <!-- Start the block -->
        <xsl:choose>
        <xsl:when test="self::cli:cli or self::cli:menu or self::cli:tag[@ref]">
            <xsl:value-of select="$STR_Indent0"/>
            <xsl:text>{</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:when test="self::cli:tag[@id]">
            <xsl:value-of select="$STR_Indent0"/>
            <xsl:text>do {</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="$STR_Indent0"/>
            <xsl:text>if (cli_Elements == *</xsl:text><xsl:call-template name="T_Node2Var"/><xsl:text>) {</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:otherwise>
        </xsl:choose>

        <!-- Step it -->
        <xsl:if test="not(self::cli:tag or self::cli:endl)">
            <xsl:value-of select="$STR_Indent1"/>
                <xsl:text>if (! cli_Elements.StepIt()) return false;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:if>

        <!-- Trace current keyword -->
        <xsl:value-of select="$STR_Indent1"/>
            <xsl:text>cli::GetTraces().Trace(CLI_EXECUTION) </xsl:text>
            <xsl:text>&lt;&lt; "context = \"</xsl:text><xsl:call-template name="T_Node2Desc"/><xsl:text>\", " </xsl:text>
            <xsl:text>&lt;&lt; "word = " </xsl:text>
            <xsl:text>&lt;&lt; (</xsl:text>
                <xsl:text>dynamic_cast&lt;const cli::Endl*&gt;(*cli_Elements) </xsl:text>
                <xsl:text>? "&lt;CR&gt;" </xsl:text>
                <xsl:text>: (const char*) (*cli_Elements)->GetKeyword()) </xsl:text>
            <xsl:text>&lt;&lt; cli::endl;</xsl:text><xsl:value-of select="$STR_Endl"/>

        <!-- Execution -->
        <xsl:if test="count(cli:cpp[not(@*)]) &gt; 0">
            <xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/>
            <xsl:for-each select="cli:cpp[not(@*)]">
                <xsl:call-template name="T_Indent">
                    <xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/>
                    <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 1"/>
                </xsl:call-template>
                    <xsl:apply-templates select="."/>
                    <xsl:value-of select="$STR_Endl"/>
            </xsl:for-each>
            <xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/>
        </xsl:if>

        <!-- Sub-elements -->
        <xsl:call-template name="T_SubElements">
            <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 1"/>
        </xsl:call-template>

        <!-- Final jump -->
        <xsl:choose>
        <xsl:when test="self::cli:tag[@id]">
            <xsl:value-of select="$STR_Indent1"/>
                <xsl:text>goto </xsl:text>
                <xsl:call-template name="T_Node2EndLabel"/>
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:when test="self::cli:tag[@ref]"></xsl:when>
        <xsl:when test="self::cli:endl"></xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="$STR_Indent1"/>
                <xsl:text>return false;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:otherwise>
        </xsl:choose>

        <!-- End the block -->
        <xsl:choose>
        <xsl:when test="self::cli:tag[@id]">
            <xsl:value-of select="$STR_Indent0"/>
                <xsl:text>} while(true);</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="$STR_Indent0"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:otherwise>
        </xsl:choose>

        <!-- End label -->
        <xsl:value-of select="$STR_Indent0"/>
            <xsl:call-template name="T_Node2EndLabel"/>
            <xsl:text>: ;</xsl:text>
            <xsl:value-of select="$STR_Endl"/>

    </xsl:template>

    <xsl:template name="T_SubElements">
        <xsl:param name="I_IndentCount" select="0"/>
        <xsl:param name="XML_JumpTag"/>

        <xsl:variable name="STR_Indent">
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
        <xsl:when test="self::cli:endl">
            <xsl:value-of select="$STR_Indent"/>
                <xsl:text>return true;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:when test="self::cli:tag[@ref]">
            <xsl:variable name="STR_Tag" select="@ref"/>

            <xsl:choose>
            <xsl:when test="parent::cli:tag[@id=$STR_Tag]">
                <xsl:call-template name="T_Error">
                    <xsl:with-param name="STR_Message">tag reference '<xsl:value-of select="$STR_Tag"/>' directly located in the tag</xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="ancestor::cli:tag[@id=$STR_Tag]">
                <!-- The referenced tag is an ancestor -->
                <!-- Simply look for this one and make the references -->
                <xsl:for-each select="ancestor::cli:tag[@id=$STR_Tag]">
                    <xsl:choose>
                    <xsl:when test="$XML_JumpTag">
                        <xsl:call-template name="T_SubElements">
                            <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                            <xsl:with-param name="XML_JumpTag" select="$XML_JumpTag"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="T_SubElements">
                            <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                            <xsl:with-param name="XML_JumpTag" select="."/>
                        </xsl:call-template>
                    </xsl:otherwise>
                    </xsl:choose>
                </xsl:for-each>
            </xsl:when>
            <xsl:otherwise>
                <!-- The referenced tag is not an ancestor -->
                <!-- Look for tags in the whole document and make the references -->
                <xsl:for-each select="//cli:tag[@id=$STR_Tag]">
                    <xsl:choose>
                    <xsl:when test="$XML_JumpTag">
                        <xsl:call-template name="T_SubElements">
                            <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                            <xsl:with-param name="XML_JumpTag" select="$XML_JumpTag"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="T_SubElements">
                            <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                            <xsl:with-param name="XML_JumpTag" select="."/>
                        </xsl:call-template>
                    </xsl:otherwise>
                    </xsl:choose>
                </xsl:for-each>
            </xsl:otherwise>
            </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
            <xsl:for-each select="cli:keyword|cli:param|cli:tag|cli:endl">
                <xsl:choose>
                <xsl:when test="not($XML_JumpTag)">
                    <xsl:call-template name="T_ImplementMenuExecution">
                        <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="$XML_JumpTag">
                    <xsl:variable name="STR_JumpLabel"><xsl:for-each select="$XML_JumpTag"><xsl:call-template name="T_Node2TopLabel"/></xsl:for-each></xsl:variable>

                    <xsl:choose>
                    <xsl:when test="self::cli:tag[@ref]">
                        <xsl:call-template name="T_SubElements">
                            <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                            <xsl:with-param name="XML_JumpTag" select="$XML_JumpTag"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:when test="self::cli:tag[@hollow='yes']"><!-- Do nothing --></xsl:when>
                    <xsl:when test="self::cli:tag[@id]">
                        <xsl:call-template name="T_SubElements">
                            <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                            <xsl:with-param name="XML_JumpTag" select="$XML_JumpTag"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:when test="self::cli:param">
                        <xsl:value-of select="$STR_Indent"/>
                            <xsl:text>if (cli_Elements == *</xsl:text><xsl:call-template name="T_Node2Var"/><xsl:text>) </xsl:text>
                            <xsl:text>goto </xsl:text><xsl:value-of select="$STR_JumpLabel"/><xsl:text>;</xsl:text><xsl:value-of select="$STR_Endl"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$STR_Indent"/>
                            <xsl:text>if (cli_Elements == *</xsl:text><xsl:call-template name="T_Node2Var"/><xsl:text>) </xsl:text>
                            <xsl:text>goto </xsl:text><xsl:value-of select="$STR_JumpLabel"/><xsl:text>;</xsl:text><xsl:value-of select="$STR_Endl"/>
                    </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                </xsl:choose>
            </xsl:for-each>
        </xsl:otherwise>
        </xsl:choose>

    </xsl:template>

    <xsl:template name="T_MenuHandlers">
        <xsl:variable name="STR_Class"><xsl:call-template name="T_Node2Class"/></xsl:variable>

        <!-- Error handler -->
        <xsl:if test="self::cli:cli">
            <xsl:call-template name="T_Indent1"/>
                <xsl:text>public: virtual const bool OnError(const cli::ResourceString&amp; location, const cli::ResourceString&amp; message) const {</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
            <xsl:for-each select="cli:handler[@name='error']">
                <xsl:if test="cli:cpp"><xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/></xsl:if>
                <xsl:for-each select="cli:cpp">
                    <xsl:call-template name="T_Indent2"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/></xsl:call-template>
                        <xsl:apply-templates select="."/>
                        <xsl:value-of select="$STR_Endl"/>
                </xsl:for-each>
                <xsl:if test="cli:cpp"><xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/></xsl:if>
            </xsl:for-each>
            <xsl:call-template name="T_Indent2"/>
                <xsl:text>return Cli::OnError(location, message);</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
            <xsl:call-template name="T_Indent1"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
            <xsl:value-of select="$STR_Endl"/>
        </xsl:if>

        <!-- Exit handler -->
        <xsl:call-template name="T_Indent1"/>
            <xsl:text>public: virtual void OnExit(void) const {</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:for-each select="cli:handler[@name='exit']">
            <xsl:if test="cli:cpp"><xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/></xsl:if>
            <xsl:for-each select="cli:cpp">
                <xsl:call-template name="T_Indent2"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/></xsl:call-template>
                    <xsl:apply-templates select="."/>
                    <xsl:value-of select="$STR_Endl"/>
            </xsl:for-each>
            <xsl:if test="cli:cpp"><xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/></xsl:if>
        </xsl:for-each>
        <xsl:call-template name="T_Indent1"/>
            <xsl:text>}</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:value-of select="$STR_Endl"/>

        <!-- Prompt handler -->
        <xsl:call-template name="T_Indent1"/>
            <xsl:text>public: virtual const cli::tk::String OnPrompt(void) const {</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:for-each select="cli:handler[@name='prompt']">
            <xsl:if test="cli:cpp"><xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/></xsl:if>
            <xsl:for-each select="cli:cpp">
                <xsl:call-template name="T_Indent2"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/></xsl:call-template>
                    <xsl:apply-templates select="."/>
                    <xsl:value-of select="$STR_Endl"/>
            </xsl:for-each>
            <xsl:if test="cli:cpp"><xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/></xsl:if>
        </xsl:for-each>
        <xsl:call-template name="T_Indent2"/>
            <xsl:text>return Menu::OnPrompt();</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:call-template name="T_Indent1"/>
            <xsl:text>}</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:value-of select="$STR_Endl"/>
    </xsl:template>

<xsl:template name="T_NodeCreation">
    <xsl:variable name="STR_Class">
        <xsl:for-each select="/cli:cli">
        <xsl:call-template name="T_Node2Class"/>
        </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="STR_Var">
        <xsl:for-each select="/cli:cli">
        <xsl:call-template name="T_Node2Var">
            <xsl:with-param name="B_UseOwnerCli" select="0"/>
        </xsl:call-template>
        </xsl:for-each>
    </xsl:variable>

    <xsl:text>// ----- Node creation -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>

    <!-- CLI object creation -->
    <xsl:if test="not($B_CliStaticCreation = 0)">
        <xsl:value-of select="$STR_Class"/>
            <xsl:text> </xsl:text>
            <xsl:value-of select="$STR_Var"/>
            <xsl:text>;</xsl:text>
            <xsl:value-of select="$STR_Endl"/>

        <xsl:if test="/cli:cli/@cpp">
            <xsl:text>cli::Cli* </xsl:text>
                <xsl:value-of select="/cli:cli/@cpp"/>
                <xsl:text> = &amp; </xsl:text>
                <xsl:value-of select="$STR_Var"/>
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:if>
    </xsl:if>

    <xsl:value-of select="$STR_Endl"/>
</xsl:template>

<xsl:template name="T_Node2Desc">
    <!-- Recursive call -->
    <xsl:if test="not(self::cli:cli) and not(self::cli:menu[@name])">
        <xsl:for-each select="parent::cli:*">
            <xsl:call-template name="T_Node2Desc"/>
        </xsl:for-each>
        <xsl:text> </xsl:text>
    </xsl:if>

    <!-- Current item description -->
    <xsl:choose>
    <xsl:when test="self::cli:cli"><xsl:value-of select="@name"/><xsl:text>&gt;</xsl:text></xsl:when>
    <xsl:when test="self::cli:menu[@name]"><xsl:value-of select="@name"/><xsl:text>&gt;</xsl:text></xsl:when>
    <xsl:when test="self::cli:keyword"><xsl:value-of select="@string"/></xsl:when>
    <xsl:when test="self::cli:param"><xsl:text>$</xsl:text><xsl:value-of select="@id"/></xsl:when>
    <xsl:when test="self::cli:tag[@id]"><xsl:text>[</xsl:text><xsl:value-of select="@id"/><xsl:text>:]</xsl:text></xsl:when>
    <xsl:when test="self::cli:tag[@ref]"><xsl:text>[-&gt; </xsl:text><xsl:value-of select="@ref"/><xsl:text>]</xsl:text></xsl:when>
    <xsl:when test="self::cli:endl"><xsl:text>&lt;CR&gt;</xsl:text></xsl:when>
    <xsl:otherwise><xsl:text>???</xsl:text></xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template name="T_Node2Var">
    <xsl:param name="B_UseOwnerCli" select="1"/>

    <!-- Menu: access through the m_pcliOwnerCli member. -->
    <xsl:if test="(self::cli:cli or self::cli:menu[@name]) and $B_UseOwnerCli">
        <xsl:text>m_pcliOwnerCli-&gt;</xsl:text>
    </xsl:if>

    <!-- variable prefix -->
    <xsl:value-of select="$STR_VarPrefix"/>

    <!-- element type -->
    <xsl:choose>
    <xsl:when test="self::cli:tag[@ref]"><xsl:text>tagref</xsl:text></xsl:when>
    <xsl:when test="self::cli:menu[@ref]"><xsl:text>menuref</xsl:text></xsl:when>
    <xsl:otherwise>
        <xsl:call-template name="T_MkCppName">
            <xsl:with-param name="STR_String" select="local-name(.)"/>
        </xsl:call-template>
    </xsl:otherwise>
    </xsl:choose>

    <!-- element name -->
    <xsl:choose>
    <xsl:when test="self::cli:keyword">
        <xsl:text>_</xsl:text>
        <xsl:call-template name="T_MkCppName">
            <xsl:with-param name="STR_String" select="@string"/>
        </xsl:call-template>
    </xsl:when>
    <xsl:when test="self::cli:param">
        <xsl:text>_</xsl:text>
        <xsl:call-template name="T_MkCppName">
            <xsl:with-param name="STR_String" select="@id"/>
        </xsl:call-template>
    </xsl:when>
    </xsl:choose>

    <!-- id -->
    <xsl:text>_</xsl:text>
    <xsl:call-template name="T_Node2Id"/>
</xsl:template>
<xsl:template name="T_Node2Id">
    <xsl:param name="STR_Separator" select="''"/>
    <xsl:variable name="I_Count" select="count(preceding-sibling::cli:*)"/>

    <!-- Recursive call -->
    <xsl:if test="parent::cli:* and not(parent::cli:cli)">
        <xsl:for-each select="parent::cli:*">
            <xsl:call-template name="T_Node2Id">
                <xsl:with-param name="STR_Separator"><xsl:if test="$I_Count &gt;= 26+26"><xsl:text>_</xsl:text></xsl:if></xsl:with-param>
            </xsl:call-template>
        </xsl:for-each>
    </xsl:if>
    <!-- Generate id part based on the position of the node regarding its preceding-sibling.
         Start with a,b,c...x,y,z,A,B,C...X,Y,Z, then numbers from 0 seperated with '_' if numbers follow each others. -->
    <xsl:choose>
        <xsl:when test="$I_Count = 0"><xsl:text>a</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 1"><xsl:text>b</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 2"><xsl:text>c</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 3"><xsl:text>d</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 4"><xsl:text>e</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 5"><xsl:text>f</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 6"><xsl:text>g</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 7"><xsl:text>h</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 8"><xsl:text>i</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 9"><xsl:text>j</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 10"><xsl:text>k</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 11"><xsl:text>l</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 12"><xsl:text>m</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 13"><xsl:text>n</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 14"><xsl:text>o</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 15"><xsl:text>p</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 16"><xsl:text>q</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 17"><xsl:text>r</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 18"><xsl:text>s</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 19"><xsl:text>t</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 20"><xsl:text>u</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 21"><xsl:text>v</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 22"><xsl:text>w</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 23"><xsl:text>x</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 24"><xsl:text>y</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 25"><xsl:text>z</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+0"><xsl:text>A</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+1"><xsl:text>B</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+2"><xsl:text>C</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+3"><xsl:text>D</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+4"><xsl:text>E</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+5"><xsl:text>F</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+6"><xsl:text>G</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+7"><xsl:text>H</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+8"><xsl:text>I</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+9"><xsl:text>J</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+10"><xsl:text>K</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+11"><xsl:text>L</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+12"><xsl:text>M</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+13"><xsl:text>N</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+14"><xsl:text>O</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+15"><xsl:text>P</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+16"><xsl:text>Q</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+17"><xsl:text>R</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+18"><xsl:text>S</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+19"><xsl:text>T</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+20"><xsl:text>U</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+21"><xsl:text>V</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+22"><xsl:text>W</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+23"><xsl:text>X</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+24"><xsl:text>Y</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+25"><xsl:text>Z</xsl:text></xsl:when>
        <xsl:otherwise><xsl:value-of select="number($I_Count)-26-26"/><xsl:value-of select="$STR_Separator"/></xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template name="T_Node2Class">
    <xsl:choose>
    <xsl:when test="self::cli:cli">
        <xsl:value-of select="$STR_CliClassName"/>
    </xsl:when>
    <xsl:when test="self::cli:menu[@name]">
        <xsl:value-of select="$STR_ClassPrefix"/>
        <xsl:call-template name="T_MkCppName">
            <xsl:with-param name="STR_String" select="@name"/>
        </xsl:call-template>
    </xsl:when>
    <xsl:when test="self::cli:menu[@ref]"><xsl:text>cli::MenuRef</xsl:text></xsl:when>
    <xsl:when test="self::cli:menu">
        <xsl:call-template name="T_Error">
            <xsl:with-param name="STR_Message">
                <xsl:text>menu node should either have @name or @ref attribute.</xsl:text>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:when>
    <xsl:when test="self::cli:keyword"><xsl:text>cli::Keyword</xsl:text></xsl:when>
    <xsl:when test="self::cli:param">
        <xsl:choose>
        <xsl:when test="@type='string'"><xsl:text>cli::ParamString</xsl:text></xsl:when>
        <xsl:when test="@type='int'"><xsl:text>cli::ParamInt</xsl:text></xsl:when>
        <xsl:when test="@type='float'"><xsl:text>cli::ParamFloat</xsl:text></xsl:when>
        <xsl:when test="@type='host'"><xsl:text>cli::ParamHost</xsl:text></xsl:when>
        <xsl:when test="not(@type)">
            <xsl:call-template name="T_Error">
                <xsl:with-param name="STR_Message">
                    <xsl:text>missing @type attribute</xsl:text>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
            <xsl:call-template name="T_Error">
                <xsl:with-param name="STR_Message">
                    <xsl:text>unknown param type '</xsl:text><xsl:value-of select="@type"/><xsl:text>'</xsl:text>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:otherwise>
        </xsl:choose>
    </xsl:when>
    <xsl:when test="self::cli:endl"><xsl:text>cli::Endl</xsl:text></xsl:when>
    <xsl:when test="self::cli:tag[@id]"><xsl:text>cli::SyntaxTag</xsl:text></xsl:when>
    <xsl:when test="self::cli:tag[@ref]"><xsl:text>cli::SyntaxRef</xsl:text></xsl:when>
    <xsl:when test="self::cli:tag">
        <xsl:call-template name="T_Error">
            <xsl:with-param name="STR_Message">
                <xsl:text>tag node should either have @id or @ref attribute.</xsl:text>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:when>
    <xsl:when test="self::cli:help or self::cli:comment">
        <xsl:call-template name="T_Error">
            <xsl:with-param name="STR_Message">
                <xsl:text>(internal) no corresponding class for cli node '</xsl:text><xsl:value-of select="local-name(.)"/><xsl:text>'</xsl:text>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
        <xsl:call-template name="T_Error">
            <xsl:with-param name="STR_Message">
                <xsl:text>unknown cli node '</xsl:text><xsl:value-of select="local-name(.)"/><xsl:text>'</xsl:text>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template name="T_Node2TopLabel">
    <xsl:call-template name="T_Node2Var">
        <xsl:with-param name="B_UseOwnerCli" select="0"/>
    </xsl:call-template>
    <xsl:text>_top_lbl</xsl:text>
</xsl:template>

<xsl:template name="T_Node2EndLabel">
    <xsl:call-template name="T_Node2Var">
        <xsl:with-param name="B_UseOwnerCli" select="0"/>
    </xsl:call-template>
    <xsl:text>_end_lbl</xsl:text>
</xsl:template>

<xsl:template name="T_Indent0">
    <xsl:param name="STR_UserIndent" select="''"/>
    <xsl:variable name="I_Offset"><xsl:call-template name="T_IndentOffset"/></xsl:variable>
    <xsl:call-template name="T_Indent"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/><xsl:with-param name="I_IndentCount" select="$I_Offset + 0"/></xsl:call-template>
</xsl:template>
<xsl:template name="T_Indent1">
    <xsl:param name="STR_UserIndent" select="''"/>
    <xsl:variable name="I_Offset"><xsl:call-template name="T_IndentOffset"/></xsl:variable>
    <xsl:call-template name="T_Indent"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/><xsl:with-param name="I_IndentCount" select="$I_Offset + 1"/></xsl:call-template>
</xsl:template>
<xsl:template name="T_Indent2">
    <xsl:param name="STR_UserIndent" select="''"/>
    <xsl:variable name="I_Offset"><xsl:call-template name="T_IndentOffset"/></xsl:variable>
    <xsl:call-template name="T_Indent"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/><xsl:with-param name="I_IndentCount" select="$I_Offset + 2"/></xsl:call-template>
</xsl:template>
<xsl:template name="T_Indent3">
    <xsl:param name="STR_UserIndent" select="''"/>
    <xsl:variable name="I_Offset"><xsl:call-template name="T_IndentOffset"/></xsl:variable>
    <xsl:call-template name="T_Indent"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/><xsl:with-param name="I_IndentCount" select="$I_Offset + 3"/></xsl:call-template>
</xsl:template>

    <xsl:template name="T_IndentOffset">
        <xsl:choose>
        <xsl:when test="self::cli:cli">0</xsl:when>
        <xsl:when test="self::cli:menu">1</xsl:when>
        <xsl:when test="parent::cli:*"><xsl:for-each select="parent::cli:*"><xsl:call-template name="T_IndentOffset"/></xsl:for-each></xsl:when><!-- [contrib: yuhuawen, 2011, Saxon / Xalan compliance] -->
        <xsl:otherwise>0</xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="T_Indent">
        <xsl:param name="STR_UserIndent" select="''"/>
        <xsl:param name="I_IndentCount" select="0"/>

        <xsl:variable name="i_IndentCount">
            <xsl:choose>
            <xsl:when test="string-length($STR_Indent) &lt;= 0"><xsl:value-of select="$I_IndentCount"/></xsl:when>
            <xsl:otherwise><xsl:value-of select="$I_IndentCount - (string-length($STR_UserIndent) div string-length($STR_Indent))"/></xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:if test="string-length($STR_UserIndent) &gt; 0">
            <xsl:value-of select="$STR_UserIndent"/>
        </xsl:if>
        <xsl:if test="$i_IndentCount &gt; 0">
            <xsl:value-of select="$STR_Indent"/>
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$i_IndentCount - 1"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>

<xsl:template match="cli:cpp">
    <xsl:apply-templates/>
</xsl:template>

<xsl:template match="cli:value-of[@param]">
    <xsl:variable name="STR_Param" select="@param"/>
    <xsl:for-each select="ancestor::cli:param[@id=$STR_Param][position()=1]">
        <xsl:text>(*</xsl:text><xsl:call-template name="T_Node2Var"/><xsl:text>)</xsl:text>
    </xsl:for-each>
</xsl:template>
<xsl:template match="cli:out">
    <xsl:text>GetOutputStream()</xsl:text>
</xsl:template>
<xsl:template match="cli:err">
    <xsl:text>GetErrorStream()</xsl:text>
</xsl:template>

<xsl:template name="T_MkCppName">
    <xsl:param name="STR_String"/>

    <!-- Replace every special character with an underscore. -->
    <xsl:variable name="STR_SpecialChar" select="' :&lt;&gt;*|+-()#.'"/>
    <xsl:variable name="STR_SpecialMask" select="translate($STR_SpecialChar,$STR_SpecialChar,'______________________________________________')"/><!-- Note: Excess characters in the third argument of translate are ignored. -->
    <!-- Replace every accented character with its non-accented equivalent. -->
    <xsl:variable name="STR_AccentedChar" select="'áàâäçéèêëíìîïóòôöúùûü'"/>
    <xsl:variable name="STR_AccentedMask" select="'aaaaceeeeiiiioooouuuu'"/>
    <!-- Concatenate character sequences and masks. -->
    <xsl:variable name="STR_Char"><xsl:value-of select="$STR_SpecialChar"/><xsl:value-of select="$STR_AccentedChar"/></xsl:variable>
    <xsl:variable name="STR_Mask"><xsl:value-of select="$STR_SpecialMask"/><xsl:value-of select="$STR_AccentedMask"/></xsl:variable>

    <!-- Check constants. -->
    <xsl:if test="not(string-length($STR_SpecialMask) = string-length($STR_SpecialChar))">
        <xsl:call-template name="T_Error">
            <xsl:with-param name="STR_Message">cli2cpp.xsl: Internal error in template T_MkCppName</xsl:with-param>
        </xsl:call-template>
    </xsl:if>

    <!-- Operate translation. -->
    <xsl:value-of select="translate($STR_String,$STR_Char,$STR_Mask)"/>
</xsl:template>

<xsl:template name="T_Error">
    <xsl:param name="STR_Message"/>

    <xsl:message terminate="yes">
        <xsl:text>Error: </xsl:text>
        <xsl:value-of select="$STR_Message"/>
        <xsl:value-of select="$STR_Endl"/>
    </xsl:message>
</xsl:template>

</xsl:stylesheet>

